1
00:00:00,000 --> 00:00:01,829
이번 영상에서는 한가지 키워드에 관해 얘기하겠습니다.

2
00:00:01,829 --> 00:00:04,380
바로 enum인데요.

3
00:00:04,380 --> 00:00:05,819
enum은 typedef나 struct, union과 비슷합니다.

4
00:00:05,819 --> 00:00:08,460
새로운 타입의 변수를

5
00:00:08,460 --> 00:00:10,050
정의할 수 있게 해주죠.

6
00:00:10,050 --> 00:00:11,690
하지만 enum은 특별한 점이 있습니다.

7
00:00:11,690 --> 00:00:13,349
그것은 단지 새로운 타입의 변수를 

8
00:00:13,349 --> 00:00:14,519
정의할 뿐만 아니라

9
00:00:14,519 --> 00:00:16,910
상수도 정의할 수 있다는 것이죠.

11
00:00:16,910 --> 00:00:19,529
좀 더 분명하게 설명해드리기 위해서

12
00:00:19,529 --> 00:00:21,810
enum을 어떻게 정의하는 지

13
00:00:21,810 --> 00:00:26,300
보여드리겠습니다.

14
00:00:26,300 --> 00:00:30,570
먼저 enum을 적고요.

15
00:00:30,570 --> 00:00:33,090
이름 e_list를 예시로 적겠습니다.

16
00:00:33,090 --> 00:00:36,390
이제 안에 val1을 넣고요.

17
00:00:36,390 --> 00:00:38,820
val2, val3,

18
00:00:38,820 --> 00:00:43,530
val4, 그리고 pouet. 항상 같은 것을

19
00:00:43,530 --> 00:00:45,120
쓸 필요는 없습니다.

20
00:00:45,120 --> 00:00:47,090
세미콜론으로 닫아줍니다.

21
00:00:47,090 --> 00:00:48,780
이제 어떻게 쓰이는지 봅시다.

22
00:00:48,780 --> 00:00:51,000
가장 흥미로운 부분이죠.

23
00:00:51,000 --> 00:00:52,920
보시겠지만 

25
00:00:55,379 --> 00:00:56,820
이렇게 쓸 수 있습니다.

26
00:00:56,820 --> 00:01:06,210
컴파일하면 짜잔.

27
00:01:06,210 --> 00:01:08,070
무슨 일이 일어났을까요.

28
00:01:08,070 --> 00:01:09,510
보았다시피 val1은

29
00:01:09,510 --> 00:01:12,540
여기, 메인 안에 정의되었죠.

30
00:01:12,540 --> 00:01:14,760
실질적으론 존재하지 않는 변수인데 말이죠.

31
00:01:14,760 --> 00:01:16,500
이번 키워드 enum을 선언한 그 단순한 사실만으로  

32
00:01:16,500 --> 00:01:17,670
제가 말했다시피

33
00:01:17,670 --> 00:01:18,689
상수를 만들 수 있습니다

34
00:01:18,689 --> 00:01:19,979
자, 이렇게 괄호 안에 

35
00:01:19,979 --> 00:01:21,420
상수 val1, val2를 선언한 겁니다.

36
00:01:21,420 --> 00:01:23,939
그 값은 0이고요. 이제 상수 val2의 값을

37
00:01:23,939 --> 00:01:30,360
출력해보면

38
00:01:30,360 --> 00:01:30,979
1이 나올 겁니다.

39
00:01:30,979 --> 00:01:33,720
enum을 선언하면, 

40
00:01:33,720 --> 00:01:34,860
컴파일러는 가장 먼저 

41
00:01:34,860 --> 00:01:36,299
첫 번째 값으로 0을 넣고

42
00:01:36,299 --> 00:01:37,710
그다음 값으로 +1을 넣어줍니다. 

43
00:01:37,710 --> 00:01:39,720
그다음으로 또 +1의 값을 넣어주고요.

44
00:01:39,720 --> 00:01:41,840
그렇게 계속 갑니다. 그러면

45
00:01:41,840 --> 00:01:44,640
enum에서 마지막에 있는 pouet은

46
00:01:44,640 --> 00:01:46,950
어떤 값을 가지게 될까요

47
00:01:46,950 --> 00:01:51,210
0 1 2 3 4니까 4를 가집니다.

48
00:01:51,210 --> 00:01:54,119
좋습니다. enum에 대해 알아야 할 다른 점은

49
00:01:54,119 --> 00:01:55,710
반드시 값이 0에서부터 

50
00:01:55,710 --> 00:01:57,960
시작할 필요는 없다는 것이지요.

51
00:01:57,960 --> 00:01:59,310
원한다면 시작 값을 직접 지정해 줄 수도 있습니다.

52
00:01:59,310 --> 00:02:01,710
예로 12를 주겠습니다. 이 경우 pouet은

53
00:02:01,710 --> 00:02:02,969
16이 되겠죠.

54
00:02:02,969 --> 00:02:05,159
왜냐하면 12에서부터 시작했고 

55
00:02:05,159 --> 00:02:07,619
12 + 4는 16입니다. 원한다면 모든 상숫값을

56
00:02:07,619 --> 00:02:09,598
재정의해 줄 수도 있습니다.

58
00:02:09,598 --> 00:02:11,090
예를 들어 여기에 

59
00:02:11,090 --> 00:02:12,910
12 말고 다른 걸 넣어봅시다.

60
00:02:12,910 --> 00:02:17,569
1.3. 문제가 생겼네요.

61
00:02:17,569 --> 00:02:19,879
먼저 enum은 정수로 된 상수여야만 합니다.

62
00:02:19,879 --> 00:02:22,879
그러니 1.3을 넣을 순 없죠.

63
00:02:22,879 --> 00:02:24,890
제대로 동작하지 않습니다.

64
00:02:24,890 --> 00:02:28,069
따옴표로 엮은 문자열이나

65
00:02:28,069 --> 00:02:29,360
그냥 문자열도 안 됩니다.

66
00:02:29,360 --> 00:02:31,220
하지만 이건 됩니다.

67
00:02:31,220 --> 00:02:33,470
문자 하나, 그러니까 ‘a’와 같은 것들 말이죠.

68
00:02:33,470 --> 00:02:38,120
왜냐하면 문자를 쓴 경우,

70
00:02:38,120 --> 00:02:40,160
결국엔 컴파일러가 그 값을 

71
00:02:40,160 --> 00:02:41,780
숫자로 바꾸기 때문이죠.

72
00:02:41,780 --> 00:02:43,700
이 ‘c’는 c의 ASCII 값을 의미합니다. 

73
00:02:43,700 --> 00:02:45,290
그러니 결국 숫자 값이기 때문에

74
00:02:45,290 --> 00:02:47,030
상수로서 잘 작동하는 것이죠.

76
00:02:47,030 --> 00:02:49,640
정수로 쓰일 수 있기 때문에 문제가 생기지 않습니다.

77
00:02:49,640 --> 00:02:50,660
만약 int형보다도 긴 어떤 값을 

78
00:02:50,660 --> 00:02:53,780
쓴다면, 예를 들어

79
00:02:53,780 --> 00:02:56,360
50억의 값을 넣는다면...

80
00:02:56,360 --> 00:03:00,769
그러니까

81
00:03:00,769 --> 00:03:03,920
제 생각에 50억을 넣으면 문제가 있을 겁니다.

82
00:03:03,920 --> 00:03:08,780
앗 이런. enum의 타입이 변했네요.

83
00:03:08,780 --> 00:03:12,160
int형이 아니라 unsigned long형을

84
00:03:12,160 --> 00:03:15,350
만들었네요.
 
85
00:03:15,350 --> 00:03:18,440
음. 이건 저도 몰랐어요.

86
00:03:18,440 --> 00:03:19,819
저도 여러분과 함께 배웠네요.

87
00:03:19,819 --> 00:03:21,799
별로 심각한 건 아닙니다. 이런 실험은 해본 적이 없을 뿐이죠.

88
00:03:21,799 --> 00:03:23,660
어쨌거나 보시다시피

89
00:03:23,660 --> 00:03:25,370
상수에 따라 형이 변합니다.

90
00:03:25,370 --> 00:03:26,599
하지만 여기서 기억해야 할 중요한 사실은

91
00:03:26,599 --> 00:03:28,849
반드시 정수여야 한다는 것이죠.

92
00:03:28,849 --> 00:03:30,980
그것이 signed이든 unsigned이든 말입니다.

93
00:03:30,980 --> 00:03:32,450
long이든 short이든 뭐든지요.

94
00:03:32,450 --> 00:03:34,730
정수인 것이야말로 제일

95
00:03:34,730 --> 00:03:37,220
중요한 점입니다. 이제 만약
 
96
00:03:37,220 --> 00:03:40,099
val1 = 5라 적고

97
00:03:40,099 --> 00:03:42,049
더불어 val3 역시

98
00:03:42,049 --> 00:03:44,109
5와 같다고 쓴다면

99
00:03:44,109 --> 00:03:46,430
저를 막을 수 있는 것은 없습니다.

100
00:03:46,430 --> 00:03:47,930
같은 값을 두 번 쓰지 못할 

101
00:03:47,930 --> 00:03:49,639
이유는 없습니다.

102
00:03:49,639 --> 00:03:50,480
보면 pouet은 이제

103
00:03:50,480 --> 00:03:52,609
7의 값을 가지고 있습니다. 왜냐하면

104
00:03:52,609 --> 00:03:54,560
val4는 그전 변숫값에 +1한 값을 가지고 있고

105
00:03:54,560 --> 00:03:56,269
pouet은 그것에 +1한 값을 가지고 있으니까요.

106
00:03:56,269 --> 00:03:57,769
그렇게 해서 5 + 2

107
00:03:57,769 --> 00:04:00,169
7이 되지요. 만약 val2의 값을

108
00:04:00,169 --> 00:04:02,540
출력해보면

109
00:04:02,540 --> 00:04:07,760
6이 나올 겁니다.

110
00:04:07,760 --> 00:04:08,980
이제 두 번째 enum을 만들어 보죠.

111
00:04:08,980 --> 00:04:11,990
두 번째 목록은

112
00:04:11,990 --> 00:04:15,470
e_list2라고 짓겠습니다. 

113
00:04:15,470 --> 00:04:17,720
안에는 val1을 넣고

114
00:04:17,720 --> 00:04:22,760
아 세미콜론 넣는 것을 깜박했군요.

115
00:04:22,760 --> 00:04:26,240
컴파일러를 다시 실행시키면, 

116
00:04:26,240 --> 00:04:28,610
여기와 여기, 문제가 있군요.

117
00:04:28,610 --> 00:04:30,020
enum의 가장 어려운 점이죠.

118
00:04:30,020 --> 00:04:31,940
enum은

119
00:04:31,940 --> 00:04:32,750
스코프를 써서 활용됩니다. 

120
00:04:32,750 --> 00:04:35,180
그 안에 val1을 적으면

121
00:04:35,180 --> 00:04:36,440
그러자마자 바로 상수를 하나 정의한 것이지요.

122
00:04:36,440 --> 00:04:39,890
이 상수는 전역 변수로서 모든 스코프 안에서 활용됩니다.

123
00:04:39,890 --> 00:04:41,990
그러니 val1이 이미 여기에 존재하므로

124
00:04:41,990 --> 00:04:43,910
다른 enum에 val1을 적는다면

126
00:04:43,910 --> 00:04:46,480
이미 정의됐다고 경고문을 띄웁니다.

127
00:04:46,480 --> 00:04:49,790
그러니까 enum을 쓸 땐 조심하십시오.

128
00:04:49,790 --> 00:04:50,990
enum 자체의 이름이 중요한 게 아니라

129
00:04:50,990 --> 00:04:53,060
그 안에 넣는 상수들의 이름이

130
00:04:53,060 --> 00:04:55,160
중요하다는 거죠.

131
00:04:55,160 --> 00:04:57,650
이건 정말 매우 중요하니까

132
00:04:57,650 --> 00:04:59,930
조심하십시오. 그리고 또 한 가지 알려드릴 것은

133
00:04:59,930 --> 00:05:02,360
컴파일할 때에

134
00:05:02,360 --> 00:05:03,590
자동형 변환을 하지 않도록

135
00:05:03,590 --> 00:05:06,650
요구할 수 있다는 겁니다.

136
00:05:06,650 --> 00:05:09,200
그러니까 enum에게 알맞은 타입을

137
00:05:09,200 --> 00:05:11,060
쓰고 있는지 확인하도록 하는 것이죠.

138
00:05:11,060 --> 00:05:12,740
갑자기 enum list를 쓰지 않고

139
00:05:12,740 --> 00:05:14,570
바로 뒤에 int형을 받는 것 같은

140
00:05:14,570 --> 00:05:16,520
일이 일어나지 않도록 말이죠.

141
00:05:16,520 --> 00:05:19,040
enum은 반환 값을 가리고 싶을 때 

143
00:05:19,040 --> 00:05:21,170
자주 사용됩니다.

144
00:05:21,170 --> 00:05:22,820
반환에 성공했을 때, 예를 들어

145
00:05:22,820 --> 00:05:24,620
0을 반환하게 하거나
 
146
00:05:24,620 --> 00:05:25,640
에러가 있을 땐 특정 값을

147
00:05:25,640 --> 00:05:27,560
반환하게 하도록 할 수 있죠.

148
00:05:27,560 --> 00:05:29,810
그것이 enum입니다. 그 작업에 안성맞춤이죠.

149
00:05:29,810 --> 00:05:31,130
웹을 좀 다뤄본 사람이라면 

150
00:05:31,130 --> 00:05:32,570
404 에러를 알 겁니다.

151
00:05:32,570 --> 00:05:34,820
404는 웹사이트의 대답을 보여주는, 

152
00:05:34,820 --> 00:05:36,160
인용문 형태의 에러입니다. 

153
00:05:36,160 --> 00:05:38,060
401이나 503 등의 에러를

154
00:05:38,060 --> 00:05:40,790
본 적이 있을 겁니다. 

155
00:05:40,790 --> 00:05:42,230
이제 enum을 배웠으니 

156
00:05:42,230 --> 00:05:45,080
0과 같은 http의 enum 타입 에러를

157
00:05:45,080 --> 00:05:48,140
해석할 수 있게 됐습니다.

158
00:05:48,140 --> 00:05:51,740
200은 SUCCESS이고 404는 NOT_FOUND

159
00:05:51,740 --> 00:05:53,300
다른 것들은 코드한 것에 따라 다른 의미가 있겠죠.

160
00:05:53,300 --> 00:05:54,530
이렇게 함으로써 에러가 무엇인지

161
00:05:54,530 --> 00:05:56,870
무엇이 반환되었는지 

162
00:05:56,870 --> 00:05:58,400
읽기 수월해집니다.

163
00:05:58,400 --> 00:06:01,190
404 같은 불명확한 것들보단 말이죠.

165
00:06:01,190 --> 00:06:02,570
이제 그 대신 NOT_FOUND를

166
00:06:02,570 --> 00:06:04,370
쓸 수 있게 됐습니다.

167
00:06:04,370 --> 00:06:07,280
정리하자면, enum은 매우 유용하고 

168
00:06:07,280 --> 00:06:09,320
강력한 도구입니다. 하지만 

169
00:06:09,320 --> 00:06:09,890
남용하진 마십쇼.

170
00:06:09,890 --> 00:06:12,650
왜냐하면 상수는 때때로

171
00:06:12,650 --> 00:06:14,480
보다 효과적이지만 너무 많은

172
00:06:14,480 --> 00:06:15,790
enum은

173
00:06:15,790 --> 00:06:17,590
코드를 엉키게 하고

174
00:06:17,590 --> 00:06:18,820
enum들이 서로 대치하는 상황이

175
00:06:18,820 --> 00:06:19,330
생길 수 있으니까요.

176
00:06:19,330 --> 00:06:21,520
그러니 재사용할 때는 주의하시고요.

177
00:06:21,520 --> 00:06:23,560
매우 유용하지만

178
00:06:23,560 --> 00:06:26,670
알맞게 사용해야 합니다.
<< translated by mseo, yeslee, inyang, mki, and ji-kim ;) >>