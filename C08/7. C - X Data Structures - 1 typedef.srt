1
00:00:00,000 --> 00:00:02,669
이번 영상에서 새로운 키워드 “typedef”에 대해서 이야기해봅시다

2
00:00:02,919 --> 00:00:06,209
“typedef”는 고유의 변수 타입을 정의하도록 만들어주는 키워드입니다

3
00:00:06,520 --> 00:00:10,080
사실 우리 고유의 “type”을 정의하는 것이 아니라, 다른 변수 타입을 재정의하는 것입니다

4
00:00:10,260 --> 00:00:14,860
이걸 왜 하는지 궁금해하실 것 같으니, 바로 보여드리겠습니다

5
00:00:15,880 --> 00:00:21,100
예를 들어 이걸 쓰길 원한다면… b, c…

6
00:00:21,100 --> 00:00:24,480
여기 모두 int 타입인

7
00:00:25,020 --> 00:00:29,120
a, b, c 세 개의 변수를 막 정의했습니다

8
00:00:30,120 --> 00:00:32,120
만약 지금 "int *a, b, c"를 쓴다면,

9
00:00:32,920 --> 00:00:34,920
모두 “int *”타입일까요?

10
00:00:34,930 --> 00:00:39,719
모두 포인터일까요? 가장 쉽게 확인하는 법은,

11
00:00:39,940 --> 00:00:42,059
“b = a”를 사용해서 변수가 같은지 보는 것입니다

12
00:00:42,700 --> 00:00:44,700
컴파일러가 에러를 말하네요 “안돼!”

13
00:00:45,370 --> 00:00:50,189
호환성 문제가 있습니다, 왜냐하면 a는 “int형 포인터 타입”이고, b는 “int 타입"이기 때문입니다

14
00:00:50,879 --> 00:00:56,189
“int *a, b, c”의 의미는 “a”는 int형 포인터이고 “b”, “c”는 int입니다

15
00:00:57,039 --> 00:00:59,039
만약 *을 넣어서 “*a, *b, *c”로 하면,

16
00:00:59,230 --> 00:01:01,230
문제는 해결될 것입니다

17
00:01:01,600 --> 00:01:04,650
잘 동작하는군요, 이미 아셨겠지만, 이렇게 하는 것은 실용적이지 않습니다

18
00:01:05,740 --> 00:01:09,030
만약 많은 변수가 있을 때 이렇게 하는 건 좀 짜증이 날 겁니다
자… 이 문제에 대한 해결책이 있습니다

19
00:01:09,400 --> 00:01:12,359
이제 내 고유의 변수를 정의할 겁니다

20
00:01:13,600 --> 00:01:16,169
고마워요 “typedef”, 이를 위해 “typedef”를 씁시다

21
00:01:16,869 --> 00:01:22,769
그다음, 다시 이름을 부여하고 싶은 타입을 적습니다, 그래서 “int *”에 이름을 지을 겁니다

22
00:01:23,650 --> 00:01:24,790
예를 들어… “pouet”

23
00:01:24,790 --> 00:01:26,790
혹은… “int_p”

24
00:01:27,070 --> 00:01:30,059
좋아요, 그럼 이걸 “int_p”라고 부릅시다

25
00:01:30,790 --> 00:01:32,320
그럼 만약 지금 “int_p”를 여기에 쓰면…

26
00:01:32,320 --> 00:01:34,210
보시다시피 a, b, c 모두 “int_p”입니다

27
00:01:34,210 --> 00:01:38,460
그래서 이들 모두 타입이 “int *”입니다

28
00:01:39,189 --> 00:01:40,750
동작하나요?

29
00:01:40,750 --> 00:01:42,040
동작합니다!!

30
00:01:42,040 --> 00:01:45,749
변수 모두 “int *”라는 것을 확인했고, 모두 “int *”로 써먹을 수 있습니다

31
00:01:45,880 --> 00:01:49,199
만약 예를 들어, int “z”를 만들고

32
00:01:49,930 --> 00:01:52,619
“b = &z”라고 하면…

33
00:01:53,350 --> 00:01:55,350
어떻게 될까요?

34
00:01:55,420 --> 00:01:56,860
동작합니다!

35
00:01:56,860 --> 00:01:58,919
그래서 “typedef”는 “int *”에 새로운 이름을 부여할 수 있도록 해줍니다

36
00:01:59,560 --> 00:02:01,649
또 알아야 할 중요한 점은, “typedef”는 마지막에 세미콜론(;)으로 끝납니다

37
00:02:02,079 --> 00:02:07,349
“typedef”는 어느 지점에서 실행이 될 “키워드”입니다

38
00:02:07,350 --> 00:02:08,739
여러분은 텍스트를 대체하는 전처리기 명령어인 #define을 보셨습니다

39
00:02:08,739 --> 00:02:11,128
“typedef”는 텍스트를 대체하는 것이 아닙니다

40
00:02:11,320 --> 00:02:16,049
“typedef”는 키워드이고 지금은 제일 위에 있기 때문에 전역 스코프에 속합니다

41
00:02:16,540 --> 00:02:18,190
예를 들어, 만약 이걸

42
00:02:18,190 --> 00:02:23,729
여기에 옮기면, 여전히 잘 동작하는 것을 볼 수 있습니다, 왜냐하면 ; 이전에 정의되었기 때문입니다

43
00:02:24,490 --> 00:02:26,490
그런데 만약 함수의 끝에 typedef를 넣으면…

44
00:02:27,070 --> 00:02:30,449
더는 동작하지 않습니다, 왜냐구요?


45
00:02:30,610 --> 00:02:35,520
간단히 말하면, “int_p”가 이 라인에서 아직 정의되지 않았기 때문입니다
여기선 “int_p”가 뭔지 아직 모릅니다

46
00:02:35,950 --> 00:02:41,310
만약 지금 typedef를 스코프 안에 넣으면,

47
00:02:43,000 --> 00:02:47,580
“typedef int * int_p” 짠! 어디 봅시다!

48
00:02:49,300 --> 00:02:53,130
동작하지 않습니다! 왜냐구요? “typedef”는 오직 스코프 안에서만 정의되기 때문이에요

49
00:02:54,580 --> 00:02:56,580
이게 “typedef”를 사용하는 법입니다

50
00:02:57,280 --> 00:02:59,640
“typedef”의 다른 장점은,

51
00:03:00,340 --> 00:03:02,080
예를 들어,

52
00:03:02,080 --> 00:03:04,440
integer를 사용해서 뭔가를 했는데,

53
00:03:05,080 --> 00:03:11,759
타입을 double이나 float 혹은 다른 것으로 바꿔야 한다면

54
00:03:12,100 --> 00:03:16,230
“typedef”를 바꾸면 됩니다

55
00:03:16,750 --> 00:03:19,410
그리고 심지어 “typedef”를 조합할 수도 있습니다

56
00:03:19,989 --> 00:03:21,989
float를 가지고 좀 놀아보도록 하죠

57
00:03:22,269 --> 00:03:26,669
float를 “my_variable”이라고 하고, 이걸 “my_variable_p”라고 부릅시다

58
00:03:28,120 --> 00:03:33,720
가볼까요~ 이제 “int_p”를 “my_variable_p”라고 하고

59
00:03:37,660 --> 00:03:40,580
여기에 “my_variable”을 쓸 수 있습니다

60
00:03:42,400 --> 00:03:46,080
이 코드는 컴파일되고 동작하여야 합니다, 터미널을 깨끗하게 지워주고

61
00:03:46,600 --> 00:03:48,010
컴파일하면 잘 동작합니다!

62
00:03:48,010 --> 00:03:50,240
타입이 무엇이든…

63
00:03:50,340 --> 00:03:54,860
미안합니다, 잠시만요! “my_variable”을 넣는 것을 까먹었습니다, 이제 조합해서…

64
00:03:55,080 --> 00:03:59,920
짠! 다시 실행하면, 잘 동작합니다

65
00:04:00,100 --> 00:04:07,140
지금 “a, b, c”는 float 포인터이고, “z”는 float입니다

66
00:04:07,240 --> 00:04:09,240
만약 지금 제 코드를 바꾸지 않고, 이걸 “double”로 바꾸면

67
00:04:09,760 --> 00:04:12,569
여전히 동작하고, 이제는 float가 아니라 double로 동작합니다

68
00:04:12,790 --> 00:04:17,579
이게 타입의 이름을 재정의하는 방법입니다, “typedef”는 많은 장점이 있고, 나중에 보시겠지만,

69
00:04:17,579 --> 00:04:22,138
제가 struct와 union 영상에서 “typedef”를 사용하는 것을 보실 겁니다
<< translated by inyang, ji-kim, mseo, yeslee and mki :) >>
