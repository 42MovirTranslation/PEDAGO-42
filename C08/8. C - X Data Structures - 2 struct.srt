1
00:00:00,000 --> 00:00:02,070
이번 비디오에서는 struct 키워드에 대해 알아보겠습니다

2
00:00:02,560 --> 00:00:07,500
"struct"는 "typedef"와 유사합니다, 스코프에 따른 동작 방식도 똑같고

3
00:00:07,599 --> 00:00:10,799
새로운 변수의 자료형을 정의할 수도 있습니다

4
00:00:10,860 --> 00:00:14,580
"typedef"가 단지 이미 존재하는 변수 유형을 가지고

5
00:00:14,889 --> 00:00:18,509
새 이름을 붙여서 새로운 자료형을 정의할 수 있도록 해주었다면,

6
00:00:18,640 --> 00:00:23,580
"struct"는 기존의 자료형을 하나의 단일한 "구조체"로 결합하여

7
00:00:24,039 --> 00:00:30,688
새로운 자료형을 만들 수 있게 해줍니다, 예시를 봅시다

8
00:00:31,330 --> 00:00:34,680
tab이라고 이름 붙인 int 배열이 있다고 상상해봅시다

9
00:00:35,610 --> 00:00:40,020
이 배열은 2D 공간에서 다른 점을 나타냅니다

10
00:00:40,150 --> 00:00:44,400
"tab[3][2]"는 2D 공간의 점들을 의미하며
각각의 점은 정수 값을 좌표로 삼습니다

11
00:00:45,010 --> 00:00:50,129
지금까지 어떤 문제도 없지만, 오해의 소지가 있을 수는 있습니다

12
00:00:50,620 --> 00:00:52,620
three points in 2-D
2줄 3칸짜리 좌표이거나

13
00:00:52,690 --> 00:00:57,719
3줄 2칸짜리 좌표일지 말이에요, 어떻게 만들었냐에 따라 달라지잖아요, 
어디에나 적용이 가능한 건 아니예요

14
00:00:58,120 --> 00:01:02,099
일반적으로, 사람들은 2줄 3칸으로 보지만, 실제로는

15
00:01:02,440 --> 00:01:06,569
언제나 6칸의 배열이 될 것입니다

16
00:01:07,300 --> 00:01:11,009
따라서 "tab[3][2]"가 어떤 식으로 존재하는지 명확하지 않다는 걸 여러분은 알 수 있습니다

17
00:01:11,009 --> 00:01:12,580
우리에겐 2차원의 점들이 있습니다

18
00:01:12,580 --> 00:01:14,440
더 자세히 알아볼까요

19
00:01:14,440 --> 00:01:17,459
값을 이렇게 넣었습니다, tab[0][0] = 1… 이런 식으로요

20
00:01:17,710 --> 00:01:23,820
그리고 여기를 봐야 해요, tab[2] = tab[0]이라고 썼습니다

21
00:01:24,369 --> 00:01:26,369
포인트 [0]을

22
00:01:26,979 --> 00:01:30,059
포인트 [2]에 복사하고 싶다고 썼어요, 무슨 일이 일어날까요

23
00:01:33,280 --> 00:01:34,570
에러가 났네요!

24
00:01:34,570 --> 00:01:40,139
컴파일러는 내가 하려고 하는 것을 이해하지 못했고, int[2]에 뭔가를 할당하려고 했긴 했는데…

25
00:01:40,780 --> 00:01:42,340
글쎄요, 명확하지 않네요

26
00:01:42,340 --> 00:01:47,280
컴파일러는 “이런 작업 못 합니다”라고 말합니다, "struct"를 사용하면 이런 종류의 작업을 수행할 수 있습니다

27
00:01:47,280 --> 00:01:49,280
시간을 조금 절약할 수 있습니다

28
00:01:49,360 --> 00:01:53,400
이제 "sturct" 자료형의 새 변수를 작성하는 법을 보여드리겠습니다

29
00:01:53,660 --> 00:01:59,800
간단히 말해서, 선언하면 됩니다, 그래서 일단 키워드인 struct를 쓰고, 이름을 적어줍시다

30
00:02:00,640 --> 00:02:02,640
이 뒤에 우리는 “{};”를 넣어야 합니다

31
00:02:02,890 --> 00:02:09,630
그리고 중괄호 안에 우리의 struct를 구성하는 다른 것을 씁니다

32
00:02:10,060 --> 00:02:12,149
여기에 x를 나타내는 int와 y를 나타내는 int를 가지고…

33
00:02:13,000 --> 00:02:15,000
이제 이걸 어떻게 쓸까요?

34
00:02:15,370 --> 00:02:19,080
간단합니다, 여기에 "struct s_point"라고 씁니다

35
00:02:19,780 --> 00:02:21,780
그리고 이건([2]) 삭제하겠습니다

36
00:02:23,830 --> 00:02:28,199
이제 길이가 3인 struct s_point 배열을 선언합니다

37
00:02:28,930 --> 00:02:30,760
여기까지는 매우 쉽습니다

38
00:02:30,760 --> 00:02:38,070
이제, 더 이상 [0][0]을 액세스할 수 없습니다, 따라서 tab은 struct s_point의 배열이므로

39
00:02:38,380 --> 00:02:45,130
tab[0]도 struct s_point입니다, 이걸 어떻게 액세스 할 수 있을까요, ‘x’를 사용하면 됩니다

40
00:02:45,520 --> 00:02:50,900
y는 ‘.y’로 액세스하려면 간단합니다, 여기에 tab[1]이 표시하고…

41
00:02:51,160 --> 00:02:55,680
“struct s_point.x”로 액세스할 수도 있고
“struct s_point.y”로도 액세스 할 수 있습니다.

42
00:02:55,940 --> 00:02:58,500
그리고… ‘.y’로 대체할게요

43
00:03:00,660 --> 00:03:02,140
여긴 ‘.x’ 그리고 얍

44
00:03:02,540 --> 00:03:05,620
다시 컴파일하면, 이번에는 동작합니다

45
00:03:05,870 --> 00:03:10,600
값을 보여줄 뿐만 아니라 이 줄이 완벽하게 동작한다는 것도 중요한 부분입니다

46
00:03:11,750 --> 00:03:13,750
왜냐면 여기 왼쪽에

47
00:03:13,970 --> 00:03:18,550
"struct s_point"형의 tab[2]가 있고, 오른쪽 또한 같은 "struct s_point"형의 tab[0]가 있습니다

48
00:03:18,680 --> 00:03:22,540
컴파일러는 "struct s_point"가 무엇인지 알고 있습니다, struct은 두 개의 int형 변수를 만들어 묶어두고

49
00:03:22,760 --> 00:03:25,989
직접 복사할 수 있기 때문에 정말 유용합니다

50
00:03:26,690 --> 00:03:31,269
struct 안의 값은 세트입니다, 이건 좌표이고,

51
00:03:31,459 --> 00:03:35,079
이전에 두 개의 정수로 이루어진 tab과는 다릅니다, 이제 의미가 있고, 함께 정의됩니다

52
00:03:35,290 --> 00:03:39,130
이렇게해서 여러분이 만든 구조체를 다른 구조체로 복사할 수 있습니다

53
00:03:39,200 --> 00:03:43,239
그리고 한 점을 다른 점으로 어떻게 복사하는지도 이해했습니다, 멋지지 않나요?

54
00:03:43,450 --> 00:03:48,429
tab[0][0]을 tab[1][0]에, tab[0][1]을 tab[1][1]에 각각 복사해야 했지만

55
00:03:49,190 --> 00:03:54,380
두 개의 복사본을 만드는 대신에 이젠 한 번에 두 가지를 복사합니다

56
00:03:55,620 --> 00:03:57,620
또 다른 것을 보여드릴게요

57
00:03:57,870 --> 00:03:59,070
이걸 어떻게 쓰는지 보여드릴게요

58
00:03:59,070 --> 00:04:05,959
"tab[0].x"가 있습니다

59
00:04:06,930 --> 00:04:11,599
(*tab).x로 쓰여있죠, tab[0]은 *tab과 같습니다

60
00:04:12,390 --> 00:04:19,850
"->x"는 tab을 참조하고 (== "*tab") 난 뒤에 "."을 사용하는 것과 같습니다

61
00:04:21,149 --> 00:04:22,139
->x는 tab을 참조하고 .을 사용하는 것과 같습니다

62
00:04:27,690 --> 00:04:31,130
따라서 화살표는 역참조(*)와 점(.)을 함께 쓰는 것입니다

63
00:04:31,710 --> 00:04:38,180
그래서 이건 그저 똑같은 것을 쓰는 또 다른 방법일 뿐입니다
이게 동작한다는 것을 보여주기 위해… 컴파일하면… 아무 문제가 없습니다

64
00:04:39,090 --> 00:04:41,090
또 다른 중요한 것은

65
00:04:41,310 --> 00:04:45,859
"typedef"와 "struct"를 동시에 사용할 수 있습니다. 거의 항상 이런 식으로 쓰는데

66
00:04:45,860 --> 00:04:51,290
재정의할 때 "struct s_point"를 두 번 쓰는 건 실용적이지 않죠, 여기에 "typedef"를 씁니다

67
00:04:52,380 --> 00:04:57,980
"typedef" 이후에는 재정의할 자료형을 주어야 하니 "struct s_point"를 주고

68
00:04:58,169 --> 00:05:00,169
이걸 "t_point" 라고 할게요

69
00:05:00,750 --> 00:05:03,410
이 라인에서 사용하려면, t_point라고 바꿔주어야 합니다

70
00:05:06,600 --> 00:05:08,370
대체해야 합니다

71
00:05:08,370 --> 00:05:11,060
짠, 컴파일이 되고 잘 작동합니다

72
00:05:11,730 --> 00:05:13,759
이렇게 "struct" 와 "typedef"를 같이 사용해보았습니다

73
00:05:14,100 --> 00:05:19,100
동시에 정의한 struct s_point의 이름을 변경했습니다,
컴파일러의 입장에선 아무런 문제가 되지 않습니다

74
00:05:19,100 --> 00:05:24,200
따라서 방금 정의한 "struct s_point"도 이름이 바뀌었습니다

75
00:05:24,510 --> 00:05:28,459
(진짜로 이름이 바뀐 건 아닙니다… "struct s_point"를 사용할 수 있긴 합니다)

76
00:05:28,919 --> 00:05:34,249
이제는 "struct s_point" 대신에 "t_point"를 사용할 수 있습니다, 더 쓰기도 쉽죠

77
00:05:34,250 --> 00:05:36,709
이렇게 "typedef"와 "struct"를 함께 사용하는 것을 권장합니다

78
00:05:37,950 --> 00:05:42,469
마지막으로 중요한 것은 다음과 같습니다

79
00:05:43,470 --> 00:05:47,989
각 유형마다 크기가 있다는 것을 알고 있을 겁니다

80
00:05:48,600 --> 00:05:49,870
이제 여기 있는 건 쓸모가 없으니 지울게요

81
00:05:49,870 --> 00:05:54,270
sizeof라는 키워드를 사용할 것입니다, 다른 동영상에서 이미 봤을 수도 있습니다

82
00:05:55,420 --> 00:06:01,469
이 키워드는 변수의 크기를 검색할 수 있는 키워드입니다

83
00:06:01,660 --> 00:06:05,999
컴파일을 할 때, 이것은 컴파일러의 키워드입니다

84
00:06:06,580 --> 00:06:08,580
여기서 만약 "sizeof(i)"를 쓴다면

85
00:06:08,710 --> 00:06:14,070
i의 크기를 알 수 있습니다

86
00:06:14,560 --> 00:06:17,760
그러니 여기에 "sizeof(tab[0])"라고 쓰면

87
00:06:19,390 --> 00:06:24,390
"t_point"의 크기를 알 수 있으므로 "struct s_point"의 크기를 알 수 있습니다

88
00:06:26,590 --> 00:06:31,679
"4"와 "8"이 출력이 되었네요, "8"은 구조체에 2개의 정수가 있어서겠죠

89
00:06:33,810 --> 00:06:38,850
구조체의 또 다른 장점은 서로 다른 자료형의 변수를 멤버로 추가할 수 있다는 것입니다

90
00:06:38,850 --> 00:06:42,239
꼭 같은 자료형만 추가하라는 법은 없어요, 예시를 위해 char *name을 쓸게요

91
00:06:42,760 --> 00:06:44,760
여기서, 이건 지금 좌표를 나타내는 것이 아닙니다

92
00:06:45,070 --> 00:06:45,820
(이 좌표에는 int x와 int y가 들어 있습니다)

93
00:06:45,820 --> 00:06:50,489
하지만 이름을 줄 수 있습니다, 그리고 내가 이 좌표를 복사하고 싶다면

94
00:06:50,490 --> 00:06:54,090
이 정보는 struct의 일부이므로 이름도 복사합니다, 주의하세요
이 복사는 “* char”를 복사하여 주소를 복사하는 겁니다

95
00:06:54,400 --> 00:06:58,830
메모리 주소 안에 있는 값들 까지 복사하지는 않습니다, 주의하세요

96
00:06:59,290 --> 00:07:01,180
제가 보여드리고 싶은 것은

97
00:07:01,180 --> 00:07:08,310
다시 컴파일하고 실행하면, t_point의 크기는 16입니다

98
00:07:08,560 --> 00:07:12,179
첫 번째 int는 크기가 4였고 두 번째 int가 더해져서 8이 되고

99
00:07:12,400 --> 00:07:18,810
제 pc의 64비트 운영체제에서 char *는 8이어서
4 + 4 = 8 + 8 = 16이 됩니다

100
00:07:19,120 --> 00:07:21,120
짜잔! 이제 우리는 크기가 16인 구조체 하나를

101
00:07:21,520 --> 00:07:23,380
가지게 되었습니다

102
00:07:23,380 --> 00:07:27,659
이것을 이해하는 것은 중요합니다,
그래서 여기 이 구조체 하나를 할당할 때마다

103
00:07:27,850 --> 00:07:32,100
16bytes 로 할당된다는 것을 기억하시면 됩니다

104
00:07:33,080 --> 00:07:34,669
우리가 더 큰 구조체를 사용하기 시작할 때에

105
00:07:34,669 --> 00:07:38,978
이런 점은 주의해야 할 부분입니다, 사용하지 않는 영역이 있을 수도 있어요

106
00:07:39,440 --> 00:07:43,059
몇 개의 작은 구조체로 나누는 것도 좋지만, 이 일은 나중에 생각하도록 합시다

107
00:07:43,610 --> 00:07:46,900
여기까지, 오늘은 "struct"에 대한 거의 모든 것을 알아보았습니다

108
00:07:47,479 --> 00:07:48,770
여기 있는 모든 부분을 이해하셨길 바라요

109
00:07:48,770 --> 00:07:49,940
구조체는 매우 유용하고

110
00:07:49,940 --> 00:07:54,729
C가 아닌 다른 언어에서도 많이 사용됩니다

111
00:07:55,070 --> 00:07:58,119
또한 객체와 OOP을 이루는 중요한 컨셉트라고 할 수 있습니다,
이건 나중에 가서 더 볼 기회가 있을 겁니다

112
00:07:58,669 --> 00:08:03,309
구조체를 두려워하지 말고 써보세요 매우 중요하고 유용한 도구입니다
<< translated by inyang, ji-kim, yeslee, mki and mseo :) >>
