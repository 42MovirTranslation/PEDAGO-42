1
00:00:00,000 --> 00:00:04,080
이번 영상에서는 컴파일에 대해 이야기해봅시다. 제일 처음 영상에서

2
00:00:04,080 --> 00:00:07,290
“gcc” 프로그램을 사용해서 컴파일했는데,

3
00:00:07,290 --> 00:00:09,480
사실 Mac에서는 “clang”을 사용합니다

4
00:00:09,480 --> 00:00:12,840
여러분들은 프로그램을 컴파일하기 위해 “gcc”를 사용합니다

5
00:00:12,840 --> 00:00:14,880
그리고 이게 한 과정인 것 같은 느낌을 받습니다

6
00:00:14,880 --> 00:00:17,340
여러분들은 여러 유형의 오류들을 겪었지만
무슨 일이 일어났는지 완전히 이해할 수 없었습니다

7
00:00:17,340 --> 00:00:23,100
이제야 이런 것들에 대해 이야기할 겁니다,
참고로 “gcc”는 3단계의 컴파일 과정을 가집니다

8
00:00:23,100 --> 00:00:26,460
첫 번째로, “전처리"라는 과정을 거칩니다

9
00:00:26,460 --> 00:00:30,599
여기 예로, 전처리기 명령어인 ‘#include’를 봅시다

10
00:00:30,599 --> 00:00:33,780
이건 다음 영상에서 모든 전처리기 명령어에 대해 설명할 때 다시 볼 것입니다

11
00:00:33,780 --> 00:00:38,219
컴파일의 첫 번째 단계입니다

12
00:00:38,219 --> 00:00:41,340
어떻게 동작하는지 보여드리겠습니다

13
00:00:41,340 --> 00:00:44,340
“main.c”파일을 가지고 “cpp”를 실행하면, (“cpp”는 전처리 과정을 보여줍니다)

14
00:00:44,340 --> 00:00:47,640
이게 다예요

15
00:00:47,640 --> 00:00:53,940
아무것도 없는 것을 볼 수 있습니다, 
아무런 전처리기 명령어가 없기 때문입니다

16
00:00:53,940 --> 00:00:59,370
이제, 만약 “fct.c”에 똑같이 적용하면
(“| more”를 사용하면 더 잘 볼 수 있습니다)

17
00:00:59,370 --> 00:01:03,180
자, 이게 stdio.h에서 정의된 함수들입니다

18
00:01:03,180 --> 00:01:07,740
수 많은 “include”가 있고, 엄청나게 많은 코드들이 있습니다

19
00:01:07,740 --> 00:01:11,790
보시다시피, 헤더에 정의된 것들이 있습니다,
많은 양의 코드들이 추가되어 있습니다

20
00:01:11,790 --> 00:01:17,130
매우 기네요…

21
00:01:17,130 --> 00:01:18,869
#include <stdio.h>를 할 때는,

22
00:01:18,869 --> 00:01:21,990
#include가 위에 많은 코드를 추가했습니다. #include에 대해 말할 때, 

23
00:01:21,990 --> 00:01:25,380
이 부분에 대해 이야기해 볼 것입니다, 이건 기본적으로 여러분들의 파일이고,

24
00:01:25,380 --> 00:01:29,040
더 이상 “#include <stdio.h>”가 아니라, 긴 문장들의 모임이 되었으며

25
00:01:29,040 --> 00:01:32,939
여러분들이 작성한 ‘void fct(void)’, ‘printf(“COUCOU FCT”)’로 끝납니다

26
00:01:32,939 --> 00:01:37,710
그래서 #include를 사용한다면, 이러한 내용은 알아야 합니다

27
00:01:37,710 --> 00:01:41,850
여기가 첫 번째 단계죠, 전처리기 단계, 일단 모든 전처리 명령어가 끝났다면,

28
00:01:41,850 --> 00:01:45,840
각각의 “.c”파일들은 컴파일 단계로 넘어갑니다

29
00:01:45,840 --> 00:01:49,290
지금까지 했던 것은: 만약 프로그램을 만들기 원했다면,

30
00:01:49,290 --> 00:01:52,829
“gcc main.c fct.c”를 했을 것입니다.

31
00:01:52,829 --> 00:01:56,240
엔터를 누르고… 자, main에서 경고를 얻었네요

32
00:01:56,240 --> 00:02:00,290
정상입니다. 경고를 그대로 놔두겠습니다.

33
00:02:00,290 --> 00:02:04,159
그래서, 여기 “a.out”프로그램이 만들어졌고 실행하면,

34
00:02:04,159 --> 00:02:07,280
“COUCOU FCT”를 출력합니다. 좋아요

35
00:02:07,280 --> 00:02:09,949
여러분들이 몰랐던 것은, 이걸 두 단계로 나눌 수 있었다는 것입니다. 첫 번째 단계는

36
00:02:09,949 --> 00:02:13,220
각각의 “.c”파일이 독립적이라는 것입니다. 함수 프로토타입에 대해 기억하시나요?

37
00:02:13,220 --> 00:02:17,569
사실 여기 나타난 에러/경고는 컴파일 에러이고,

38
00:02:17,569 --> 00:02:21,260
이 에러가 의미하는 것은 gcc가 파일을 읽을 때,

39
00:02:21,260 --> 00:02:24,380
fct(); 줄을 읽고 나서 컴파일러는 말합니다

40
00:02:24,380 --> 00:02:28,010
“‘fct’가 뭔지 모르겠어요"

41
00:02:28,010 --> 00:02:32,269
어떻게 컴파일 에러를 피할 수 있을까요?

42
00:02:32,269 --> 00:02:37,370
간단하게 프로토타입을 추가하거나, 함수를 같은 파일에 정의하면 됩니다

43
00:02:37,370 --> 00:02:42,019
이제 이걸 하면 더 이상 문제가 발생하지 않습니다,
참고로 실제로 이후에 일어난 일은

44
00:02:42,019 --> 00:02:46,280
“cpp”가 먼저 실행되고 난 뒤(전처리기) 뭔가 다른 것도 실행되었습니다

45
00:02:46,280 --> 00:02:51,100
그건 바로 “gcc -c main.c”를 했고, 이 작업은 “.o”파일을 만듭니다

46
00:02:51,100 --> 00:02:56,000
“.o”파일은 “object file”이고,

47
00:02:56,000 --> 00:02:59,420
이 오브젝트 파일은 제 “.c”파일을 의미합니다

48
00:02:59,420 --> 00:03:04,070
“main.c”만으로 컴파일해서 오브젝트 파일을 만들었다는 뜻입니다.
(이건 순수하게 C 문법의 관점으로 보면 유효합니다)

49
00:03:04,070 --> 00:03:07,280
main 함수에는 알 수 없는 ‘fct()’ 함수가 있습니다

50
00:03:07,280 --> 00:03:09,829
그래서 main은 프로그램을 만들 수 없을 겁니다,
그러나 “.o”는 프로그램이 아닙니다

51
00:03:09,829 --> 00:03:13,549
“.o”는 바이너리 파일입니다, 그래서 이미 컴파일되었고

52
00:03:13,549 --> 00:03:17,090
그리고 이 “.o” 안에는 몇몇 부분들이 표시되어 있습니다

53
00:03:17,090 --> 00:03:19,489
“이건 링킹(다음 단계)할 때 필요할 거야

54
00:03:19,489 --> 00:03:23,959
그리고 main()에 함수 fct()를 주는 것이 필요할 거야,
그래서 나는 그것을 부를 수 있어”

55
00:03:23,959 --> 00:03:26,569
연결 단계에서, 프로그램은 “.o”파일들 안에서 호출되지만

56
00:03:26,569 --> 00:03:30,769
정의되지 않은 모든 함수들을 전달받을 것입니다

57
00:03:30,769 --> 00:03:34,250
그래서 “gcc -c main.c”는“.o”를 만들어냅니다

58
00:03:34,250 --> 00:03:39,889
만약 지금 “fct.c”에 “gcc -c”를 한다면, 다른 “.o”를 만들어낼 것입니다

59
00:03:39,889 --> 00:03:48,410
그다음에 “ld fct.o main.o”를 해서
오브젝트 파일들을 연결 할 수 있을 것입니다

60
00:03:48,410 --> 00:03:53,540
기본 라이브러리를 넘겨주기 위해 “ld”도 필요합니다

61
00:03:53,540 --> 00:03:58,250
참고로 “ld”는 링커이고, “gcc”를 할 때,
알맞는 옵션들을 넣어 “ld”를 실행할 것입니다

62
00:03:58,250 --> 00:04:00,650
그런데 지금은 기억이 나지 않네요, 그러나 기본적으로
gcc는 알맞은 인자를 넣어 “ld”를 실행합니다

63
00:04:00,650 --> 00:04:04,310
"id"는 여기서 이렇게 이야기하네요

64
00:04:04,310 --> 00:04:08,030
“나는 ‘printf’ 심볼들을 가지고 있지 않고,
(심볼이란 함수의 이름이나 변수의 이름을 의미합니다)

65
00:04:08,030 --> 00:04:10,880
내 프로그램의 시작 위치인 ‘start’를 가지고 있지 않아

66
00:04:10,880 --> 00:04:15,620
“gcc”를 사용해서, 만약 “gcc main.o fct.o”를 했다면, 오브젝트 파일들을 컴파일 할 수 있을 것입니다

67
00:04:15,620 --> 00:04:18,560
흥미로운 점은 여러분들도 봤지만

68
00:04:18,560 --> 00:04:22,070
“gcc main.c fct.c”를 해서 다시 컴파일할 때

69
00:04:22,070 --> 00:04:27,050
이 명령은 두 파일을 다시 컴파일합니다

70
00:04:27,050 --> 00:04:34,550
그러나 “main.c”만 변경하고 “main.c”만 다시 컴파일하면

71
00:04:34,550 --> 00:04:38,020
그저 “main.o”만 바꾸었고 프로그램을 다시 컴파일하게 되는 거죠

72
00:04:38,020 --> 00:04:42,500
저는 컴파일 시간을 줄였고 이것은 나중에 매우 유용할 것입니다

73
00:04:42,500 --> 00:04:46,700
수정된 파일들만 “.c”에서 “.o”로 다시 컴파일하고

74
00:04:46,700 --> 00:04:48,890
모든 “.o”파일들을 가져와서 연결하는 것이 유용할 것입니다

75
00:04:48,890 --> 00:04:52,490
만약 우리가 딱 하나만 수정했을 때

76
00:04:52,490 --> 00:04:57,650
수백 개의 파일들을 다시 컴파일하는 것을 피할 수 있습니다, 신기하죠?

77
00:04:57,650 --> 00:05:00,800
다시 돌아와 에러를 보면 “ld”가 있습니다, 실제로 호출된 게 “ld”라는 것을

78
00:05:00,800 --> 00:05:04,580
여러분들에게 보여드리기 위해 지금 “gcc main.o”를 해볼 겁니다

79
00:05:04,580 --> 00:05:09,169
지금 “main.o”로만 프로그램을 컴파일하려고 시도하고 있습니다

80
00:05:09,169 --> 00:05:12,020
연결 단계에서 gcc는 정확히 같은 오류를 말합니다, "ld symbol (s) not found"

81
00:05:12,020 --> 00:05:15,460
gcc는 “fct”를 찾을 수 없습니다…

82
00:05:15,460 --> 00:05:19,250
전에 gcc가 ‘printf’와 ‘start’를 찾을 수 없었던 것처럼 간단합니다

83
00:05:19,250 --> 00:05:21,830
이제 gcc는 ‘fct’를 찾을 수 없습니다, 
왜냐하면… 저는 “fct”를 전달하지 않았기 때문입니다

84
00:05:21,830 --> 00:05:25,490
그래서 gcc는 지금 이러한 문제가 있습니다

85
00:05:25,490 --> 00:05:29,330
“gcc main.c”를 하면 같은 에러를 얻을 것입니다. 전에는 두 단계를 거쳤습니다

86
00:05:29,330 --> 00:05:31,760
우선 ‘.c’를 ‘.o’로 컴파일하고

87
00:05:31,760 --> 00:05:35,210
‘.o’를 최종 프로그램에 연결했습니다

88
00:05:35,210 --> 00:05:38,870
그리고서 컴파일러는 “fct”가 없다는 것을 찾았습니다, 
컴파일하는 동안에 또 다른 중요한 부분은

89
00:05:38,870 --> 00:05:43,200
컴파일을 할 때 요청받은 그대로 한다는 것입니다

90
00:05:43,200 --> 00:05:48,330
그래서 여기에 ‘fct’는 int를 인자로 받고 ‘int’를 돌려준다고 쓸 수 있습니다

91
00:05:48,330 --> 00:05:55,430
그리고 여기에 19를 넣을 수 있습니다

92
00:05:55,430 --> 00:06:01,440
이렇게 하면 제 프로그램은 여전히 컴파일될 수 있을까요?

93
00:06:01,440 --> 00:06:04,800
(잠깐만요… ‘.o’ 파일을 다시 만들어야 하고

94
00:06:04,800 --> 00:06:07,980
전에 했던 작업을 되돌려 “gcc main.c fct.c”를 합시다)

95
00:06:07,980 --> 00:06:11,610
이젠 프로그램이 잘 동작합니다

96
00:06:11,610 --> 00:06:15,930
그러나 개발자들은 반드시 조심해야 합니다

97
00:06:15,930 --> 00:06:19,650
왜냐하면, 만약 여기에 여러분의 프로토타입이 실제 프로토타입과 일치하지 않는다면
심각한 문제를 야기할 수 있습니다

98
00:06:19,650 --> 00:06:23,730
걱정되는 점은 문법인데 이건 사실 컴파일 단계에서 확인됩니다

99
00:06:23,730 --> 00:06:27,900
그리고 연결 단계에서는

100
00:06:27,900 --> 00:06:31,650
어딘가에 함수가 존재하는지만 확인합니다

101
00:06:31,650 --> 00:06:35,190
연결단계에서는 인자를 다르게 받아도 확인할 방법이 없습니다민
적어도 C에서는 할 수 없습니다

102
00:06:35,190 --> 00:06:38,790
그래서 프로토타입을 쓸 때는 조심해야 합니다

103
00:06:38,790 --> 00:06:42,930
그래서 여러분들의 프로토타입은 함수와 같아야 합니다

104
00:06:42,930 --> 00:06:46,050
여러분들은 이걸 다른 영상에서 볼 것입니다

105
00:06:46,050 --> 00:06:49,920
나중에 프로토타입에서 발생하는 문제들을 예방하는 데 도움을 주는
“.h”라고 불리는 무언가에 대해 이야기할 것입니다

106
00:06:49,920 --> 00:06:56,550
마지막으로 중요한 점은 이전에 말했던 것처럼 컴파일단계에서 보셨다시피

107
00:06:56,550 --> 00:07:00,690
두 단계 안에서 끝났습니다, 이제 상상해보세요

108
00:07:00,690 --> 00:07:10,230
예를 들어 함수 ‘fct’를 정의했고

109
00:07:10,230 --> 00:07:17,819
'return (a * a)'를 합니다, 어떻게 될까요?
“main.c”를 컴파일할 수 있을까요?

110
00:07:17,819 --> 00:07:20,990
네 물론이죠! 모든 것을 main.c 혼자 컴파일할 수 있습니다

111
00:07:20,990 --> 00:07:24,750
그리고 이제 “gcc main.o fct.o”를 하면 어떻게 될까요?

112
00:07:24,750 --> 00:07:28,580
이건 좋지 않습니다, 컴파일러는 이렇게 이야기하죠

113
00:07:28,580 --> 00:07:34,409
‘main.o’그리고 ‘fct.o’안에서 ‘fct’를 총 두 번 정의했고

114
00:07:34,409 --> 00:07:37,470
둘 중 뭐를 부를 것인지 모르기 때문에 문제가 있습니다

115
00:07:37,470 --> 00:07:40,169
제가 보여드린 것과 같이… 같은 함수를 두 번 정의하지 마세요

116
00:07:40,169 --> 00:07:45,720
여러분은 모든 컴파일 단계를 봤습니다

117
00:07:45,720 --> 00:07:49,680
단계 1: 전처리기, 이것은 다음 영상에서 볼 것입니다

118
00:07:49,680 --> 00:07:52,319
우리는 전처리가 어떻게 동작하는지 볼 것입니다

119
00:07:52,319 --> 00:07:55,740
단계 2: 컴파일, 각 파일들은 하나씩 컴파일됩니다,
에러는 종종 이 단계에서 발생합니다

120
00:07:55,740 --> 00:07:57,629
가장 고전적인 실수는 컴파일 에러입니다

121
00:07:57,629 --> 00:08:01,139
마지막에 여러분들은 ‘.o’파일들을 얻을 것이고

122
00:08:01,139 --> 00:08:04,379
그 다음 ‘.o’ 파일들은 모두 연결될 것입니다

123
00:08:04,379 --> 00:08:08,219
자주 접하는 연결 에러들은 다음과 같습니다.
"함수가 없습니다.” 또는 “함수가 하나 이상 정의되어 있습니다”

124
00:08:08,219 --> 00:08:10,919
이게 가장 흔한 실수지만,

125
00:08:10,919 --> 00:08:14,599
다른 에러가 있을 수 있습니다
<< translated by inyang, ji-kim, yeslee, mseo and mki :) >>
