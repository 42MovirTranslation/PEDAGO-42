1
00:00:00,000 --> 00:00:02,000
이번 영상에서는 공용체(union)라는 키워드에 대해 설명해드리겠습니다.
 
2
00:00:02,000 --> 00:00:03,120
공용체에 대해 말하기 전,
 
3
00:00:03,120 --> 00:00:06,299
여러분께 상기시켜드릴 것이 있습니다.
 
4
00:00:06,299 --> 00:00:08,360
메모리는 언제나 0과 1로 이루어진다는 것입니다.
 
5
00:00:08,360 --> 00:00:13,049
비트는 0 혹은 1이고, 이 비트들이 8개가 모여 바이트가 됩니다.
 
6
00:00:13,049 --> 00:00:16,890
프로세서는 바이트들을 특정한 방식으로 읽을 것이며,
 
7
00:00:16,890 --> 00:00:22,500
바이트를 읽을 방식을 정의하는 것은 여러분입니다. 이건 아주 중요합니다.
 
8
00:00:22,500 --> 00:00:24,990
결국은 항상 0과 1이라는 거예요.
 
9
00:00:24,990 --> 00:00:30,060
char, char*, int, float, structure… 뭐가 됐든 항상 0과 1이에요.
 
10
00:00:30,060 --> 00:00:38,809
그리고 공용체를 이해하기 위해서, 여러분의 코드가 어떻게 보일지 결정하는 건
코드를 꿰뚫고 있는 여러분이라는 사실을 아는 것이 아주 중요합니다.
 
11
00:00:38,809 --> 00:00:43,140
공용체가 동작하는 예시를 보여드리겠습니다.
 
12
00:00:43,140 --> 00:00:44,399
사실 이건 동작 예시라기보다는,
 
13
00:00:44,399 --> 00:00:46,079
차라리 구조체와 공용체의
 
14
00:00:46,079 --> 00:00:48,480
차이점에 가깝습니다.
 
15
00:00:48,480 --> 00:00:53,489
구조체와 공용체는 거의 동일하게 쓰입니다. 문법적인 면은 같다고 할 수 있습니다.
 
16
00:00:53,489 --> 00:00:54,660
하지만 완전히 동일한 결과를 내지는 않습니다.
 
17
00:00:54,660 --> 00:00:58,469
이건 여러분이 구조체 비디오에서 봤던 예시입니다.
 
18
00:00:58,469 --> 00:01:04,110
실행시켜볼게요. 제 구조체 typedef struct s_point가 만들어졌습니다.
 
19
00:01:04,110 --> 00:01:07,170
요소로는 int x, int y, char *name이 있고
 
20
00:01:07,170 --> 00:01:10,950
마지막에 t_point라고 명명함으로써 세 칸짜리 배열을 정의했습니다.
 
21
00:01:10,950 --> 00:01:14,040
하지만 이 비디오에서는 배열을 쓰지 않을 거예요.
 
22
00:01:14,040 --> 00:01:19,710
바로 객체를 사용할 겁니다. 이게 더 깔끔하죠.
 
23
00:01:19,710 --> 00:01:22,880
이제 여기 그냥 p라고 넣을 거예요.
 
24
00:01:22,880 --> 00:01:31,079
int i는 이미 있으니까, int와 t_point의 크기를 출력해 볼게요.
 
25
00:01:31,079 --> 00:01:33,000
4와 16이 출력됐습니다. 왜 16일까요?
 
26
00:01:33,000 --> 00:01:38,100
int가 2개기 때문이에요. 첫 int에 4바이트, 두 번째 int도 4바이트, char *에 8바이트.
 
27
00:01:38,100 --> 00:01:42,329
총 16바이트입니다. 이제 키워드를 구조체에서
 
28
00:01:42,329 --> 00:01:45,030
공용체로 바꿔볼게요. 정확히 같은 문법을 사용해서요.
 
29
00:01:45,030 --> 00:01:46,110
이렇게 구조체를 공용체로 대체할 수 있고
 
30
00:01:46,110 --> 00:01:47,520
둘의 차이를 볼 수 있을 겁니다.
 
31
00:01:47,520 --> 00:01:56,070
이제 제 t_point는 고작 8바이트예요.
 
32
00:01:56,070 --> 00:01:58,350
이유는, 구조체는 모든 자료형을 조립하기 때문입니다.
 
33
00:01:58,350 --> 00:02:01,500
그러니까 구조체 int x – int y – char *name가 있다면
 
34
00:02:01,500 --> 00:02:03,450
여러분은 메모리에
 
35
00:02:03,450 --> 00:02:07,920
x를 위한 공간, y를 위한 공간, char *name을 위한 공간을 마련해주는 겁니다.
 
36
00:02:07,920 --> 00:02:12,680
공용체의 경우에는 각각을 위한 공간을 예비해두는 대신에
 
37
00:02:12,680 --> 00:02:14,569
가장 큰 자료형을 위한 공간을 마련해둘 겁니다.
 
38
00:02:14,569 --> 00:02:16,519
이 공간을
 
39
00:02:16,519 --> 00:02:21,290
int형으로 읽을 거라고 하든지, int형이지만 다른 이름으로 읽을 거라고 하든지,
 
40
00:02:21,290 --> 00:02:22,840
그건 여러분의 몫입니다.
 
41
00:02:22,840 --> 00:02:24,829
여러분에게 모든 걸 털어놓는 건 그다지 재밌지 않지만,
 
42
00:02:24,829 --> 00:02:27,140
왜 char *로는 읽지 않을까요?
 
43
00:02:27,140 --> 00:02:30,139
char *로 읽을 경우를 바로 보여드리겠습니다.
 
44
00:02:30,139 --> 00:02:31,909
이 공용체 만들어뒀던 걸 수정해가지고
 
45
00:02:31,909 --> 00:02:36,379
pouet이라고 이름을 붙일게요.
 
46
00:02:36,379 --> 00:02:38,959
아니, u_pouet이라고 선언하고 보다 명확한 예시를 보여드리겠습니다.
 
47
00:02:38,959 --> 00:02:40,549
t_pouet이라고 이름붙이고
 
48
00:02:40,549 --> 00:02:56,569
int i, 배열인 char c[4] (유용하게 써볼 겁니다), float를 넣어줍니다.
 
49
00:02:56,569 --> 00:02:59,719
이걸로 해볼게요.
 
50
00:02:59,719 --> 00:03:10,519
여기도 t_pouet이죠. 구조체와 정확히 같은 방식으로 사용됐구요.
 
51
00:03:10,519 --> 00:03:12,950
예를 들어보자면,

52
00:03:12,950 --> 00:03:21,949
p.i = 12라고 쓰고 printf(“%d\n”, p.i)를 하면
 
53
00:03:21,949 --> 00:03:26,000
화면에 무엇을 띄우는지 볼 수 있습니다.
 
54
00:03:26,000 --> 00:03:32,180
12군요. 아직까지는 좋습니다.
 
55
00:03:28,129 --> 00:03:38,919
이제 아래쪽에 p.f = 0.0이라고 적고
 
56
00:03:39,109 --> 00:03:40,010
화면에 뭐가 출력될지 봅시다.
 
57
00:03:40,010 --> 00:03:49,419
0이네요. 0. 제가 보려던 p.i의 값이 p.f의 값으로 바뀐 것을 보실 수 있습니다.
 
58
00:03:49,419 --> 00:03:58,639
몇 초 전에 공용체는 float와 char [4]가 같은 메모리 공간을 사용한다고 말씀드렸습니다.
 
59
00:03:58,639 --> 00:04:08,329
제가 왜 배열에 4를 넣었는지, 제 int는 항상 4바이트인지에 대해 이해가 되기 시작할 겁니다.
 
60
00:04:08,329 --> 00:04:09,620
이런 경우에, 사실 둘은 동일한 공간을 사용해요.
 
61
00:04:09,620 --> 00:04:11,180
저는 방금 (공용체 내부 요소의 값을) 각각 읽을 거라는 방식을 말해준 거구요.
 
62
00:04:11,180 --> 00:04:12,799
그래서 p.f = 0이라고 썼을 때
 
63
00:04:12,799 --> 00:04:17,298
p.i와 동일한 위치에 0이라는 값을 넣었음을 알고 있습니다.
 
64
00:04:17,298 --> 00:04:21,889
이제 p.i의 값을 읽으라고 하니까 int형으로 메모리 공간을 읽은 거죠
 
65
00:04:21,889 --> 00:04:23,740
그래서 0.0이 아닌 그냥 0이 출력된 거예요.
 
66
00:04:23,740 --> 00:04:30,280
하지만 float가 정확한 값을 가지는 게 아니고,  int와 같은 방식으로 저장되는 건 아니라는 걸 보여드릴게요.
 
67
00:04:30,280 --> 00:04:33,039
만약 1.4를 넣으면, 저도 모르겠네요
 
68
00:04:33,039 --> 00:04:33,880
무슨 값이 출력될까요?
 
69
00:04:33,880 --> 00:04:38,350
다소 이상한 값이 출력됐습니다.
 
70
00:04:38,350 --> 00:04:39,520
비트를 int형으로 읽을 건데,
 
71
00:04:39,520 --> 00:04:41,350
float형으로 한 번 읽고 나서,
 
71
00:04:41,350 --> 00:04:43,750
1.4를 넘겨준거죠.
 
72
00:04:43,750 --> 00:04:45,340
%d %f를 넣어서 보여드리면
 
73
00:04:45,340 --> 00:04:49,120
여기 소수값이 출력되지 않을 겁니다.
 
74
00:04:49,120 --> 00:04:51,490
p.f도 넣을게요.
 
75
00:04:51,490 --> 00:04:56,470
자, 1.4가 나와야합니다.
 
76
00:04:56,470 --> 00:05:00,190
이제 재미있는 점은 제 char[4] 배열 역시 동작한다는 것입니다.
 
77
00:05:00,190 --> 00:05:03,070
왜냐하면 마지막에 메모리에는 4개의 문자들만 있기 때문입니다. 4바이트죠.
 
78
00:05:03,070 --> 00:05:08,500
소수가 정수 혹은 소수의 첫 번째, 두 번째, 세 번째, 네 번째 바이트를 가져간 것처럼,
 
79
00:05:08,500 --> 00:05:09,910
같은 방식이에요.
 
80
00:05:09,910 --> 00:05:14,949
그래서 제가 만약
 
81
00:05:14,949 --> 00:05:16,810
p.c [0] = 0이라고 쓰고
 
82
00:05:16,810 --> 00:05:20,650
방금 int와 float를 수정했어요.
 
83
00:05:20,650 --> 00:05:22,449
그렇게 좋지는 않지만요.
 
84
00:05:22,449 --> 00:05:24,039
왜냐하면 제 생각에는 이미 0이었어야만 하기 때문이에요.

85
00:05:24,039 --> 00:05:26,800
이쪽에 p.c[1]도 넣어보겠습니다.
 
86
00:05:26,800 --> 00:05:30,490
값을 0으로 설정한다면 차이점이 있어야만 합니다.
 
87
00:05:30,490 --> 00:05:33,909
2번째는 바꿨으니까 3번째 바이트를 바꿔볼까요.
 
88
00:05:33,909 --> 00:05:38,820
이번에도 0의 값을 주었습니다.
 
89
00:05:38,820 --> 00:05:41,470
보세요, 여기 뭔가를 바꾸는 중입니다.
 
90
00:05:41,470 --> 00:05:43,419
당연하게도 제가 4번째 바이트에 0의 값을 준다면,
 
91
00:05:43,419 --> 00:05:45,909
무슨 일이 일어날까요?
 
92
00:05:45,909 --> 00:05:52,780
모든 값이 0이 될 겁니다. 이걸로 여러분은 동일한 공간의 메모리를
 
93
00:05:52,780 --> 00:05:55,870
세 종류의 다른 방식으로 읽은 걸 보실 수 있습니다.
 
94
00:05:55,870 --> 00:06:01,570
공용체에 대해 많이 알지 못하지만 중요한 부분 중 하나는 공용체가 여기서 가장 큰 자료형 만큼의 공간을 차지할 거라는 것입니다.
 
95
00:06:01,570 --> 00:06:07,610
예를 들어 여기 char * ptr를 넣으면,
 
96
00:06:07,610 --> 00:06:10,069
갑자기 제 t_pouet 공용체의 크기가
 
97
00:06:10,069 --> 00:06:12,949
4바이트가 더해져서 8바이트가 될 겁니다.
 
98
00:06:12,949 --> 00:06:16,509
이렇게 한 번 해볼까요,
 
99
00:06:16,509 --> 00:06:26,319
sizeof(p)를 써서 출력해보면 p의 크기는 8입니다.
 
100
00:06:26,319 --> 00:06:33,919
제가 char *를 지운다면 바로 4가 될 겁니다.
 
101
00:06:33,919 --> 00:06:35,179
사실 공용체는 가장 큰 자료형만큼의 공간을 마련합니다.
 
102
00:06:35,179 --> 00:06:38,929
제가 공용체에 요청한 char *는 8바이트짜리니까,
 
103
00:06:38,929 --> 00:06:42,889
그러므로 이 8바이트에는 제가 int로 쓸 수 있거나,
 
104
00:06:42,889 --> 00:06:44,050
char형 배열로 사용할 수 있거나,
 
105
00:06:44,050 --> 00:06:48,229
float로 사용할 수 있는 4바이트가 있는 거예요.
 
106
00:06:48,229 --> 00:06:51,459
나머지 4바이트는 제가 정말로 포인터(char *)를 사용할 때만 사용할 수 있습니다.
 
107
00:06:51,459 --> 00:06:55,159
공용체에서 재밌는 점이 이것입니다.
 
108
00:06:55,159 --> 00:06:56,839
공용체는 일부 특정한 상황에서 쓰입니다.
 
109
00:06:56,839 --> 00:07:01,429
제가 생각하기로 일반적인 예시는 여러분이 파일을 읽을 때,
 
110
00:07:01,429 --> 00:07:03,919
비디오게임의 세이브를 예시로 든다면,
 
111
00:07:03,919 --> 00:07:09,349
여러분이 비디오게임 세이브 파일을 읽을 때, 실제로는 구조체와 공용체를 가지고 사용하게 될 겁니다.
 
112
00:07:09,349 --> 00:07:14,479
구조체의 일부는 여러분이 세이브 파일의 자료를 어떻게 읽을지 알려주는 역할을 합니다.
 
113
00:07:14,479 --> 00:07:15,769
여러분이 계속해서 읽으려고 한다면,
 
114
00:07:15,769 --> 00:07:18,289
공용체가 여러분이 읽으려는 내용을 알려줍니다.
 
115
00:07:18,289 --> 00:07:23,029
예를 들면 사용자의 체력을, 몬스터의 체력을.
 
116
00:07:23,029 --> 00:07:26,089
몬스터의 특징 등을요.

117
00:07:26,089 --> 00:07:28,189
말하자면 동일한 공간의 메모리를 읽게 해줌으로써
 
118
00:07:28,189 --> 00:07:31,369
일종의 다형성을 가지는 객체들을 읽을 수 있도록 하고,
 
119
00:07:31,369 --> 00:07:34,579
심지어는 여러분이 불러올 때 사용하는 바이너리 파일의 메모리도 읽을 수 있게 해줍니다.
 
120
00:07:34,579 --> 00:07:35,920
마지막으로 기억해두세요..
 
121
00:07:35,920 --> 00:07:38,440
이건 메모리 공간이고, 여러분이 이 메모리를 읽을 방식이 중요합니다.
 
122
00:07:38,440 --> 00:07:42,970
여러분이 이걸 어떤 방식으로 읽든간에 다 가능하다는 사실도 기억하세요.
 
123
00:07:42,970 --> 00:07:44,350
공용체는 종종 이렇게 쓰입니다.
 
124
00:07:44,350 --> 00:07:50,440
같은 데이터의 같은 파일을 다른 방식으로 읽을 수 있도록 해주죠.
 
125
00:07:50,440 --> 00:07:53,830
왜냐하면 우리는 메모리보다 위에 있고, 다양한 방식으로 읽고자 하기 때문입니다.
 
126
00:07:53,830 --> 00:07:58,210
플래그를, 기술을, 혹은 무언가 이렇게 읽으면 이렇게 된다고 하는 것들을 말이죠.
 
127
00:07:58,210 --> 00:08:02,620
같은 파일에서 이후에는 차라리 여기에 링크할 겁니다.
 
128
00:08:02,620 --> 00:08:08,350
널리 쓰이지는 않지만 극도로 강력한 도구입니다. 아주 가끔씩만 쓰세요.
 
129
00:08:08,350 --> 00:08:12,180
공용체 키워드에 대해 알게 되셨군요.
<< translated by ji-kim, mki, mseo, yeslee and inyang :) >>
