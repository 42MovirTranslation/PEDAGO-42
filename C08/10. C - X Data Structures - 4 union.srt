1
00:00:00,000 --> 00:00:02,000
이번 영상에서는 "union" 키워드에 대해 설명해드리겠습니다

2
00:00:02,000 --> 00:00:03,120
공용체에 대해 말하기 전,

3
00:00:03,120 --> 00:00:06,299
여러분께 상기시켜드릴 것이 있습니다

4
00:00:06,299 --> 00:00:08,360
메모리는 언제나 0과 1로 이루어진다는 것입니다

5
00:00:08,360 --> 00:00:13,049
비트는 0 혹은 1이고, 이 비트들이 8개가 모여 바이트가 됩니다

6
00:00:13,049 --> 00:00:16,890
프로세서는 바이트들을 특정한 방식으로 읽을 것이며,

7
00:00:16,890 --> 00:00:22,500
바이트를 읽을 방식을 정의하는 것은 여러분입니다, 이건 아주 중요합니다

8
00:00:22,500 --> 00:00:24,990
결국은 항상 0과 1이라는 거예요

9
00:00:24,990 --> 00:00:30,060
char, char*, int, float, structure… 뭐가 됐든 항상 0과 1이에요

10
00:00:30,060 --> 00:00:38,809
그리고 공용체를 이해하기 위해서, 여러분의 코드가 어떻게 보일지 결정하는 건
코드를 꿰뚫고 있는 여러분이라는 사실을 아는 것이 아주 중요합니다

11
00:00:38,809 --> 00:00:43,140
공용체가 동작하는 예시를 보여드리겠습니다

12
00:00:43,140 --> 00:00:44,399
사실 이건 동작 예시라기보다는,

13
00:00:44,399 --> 00:00:46,079
구조체와 공용체의

14
00:00:46,079 --> 00:00:48,480
차이점에 가깝습니다

15
00:00:48,480 --> 00:00:53,489
구조체와 공용체는 거의 동일하게 쓰입니다, 문법적인 면은 같다고 할 수 있습니다

16
00:00:53,489 --> 00:00:54,660
하지만 완전히 동일한 결과를 내지는 않습니다

17
00:00:54,660 --> 00:00:58,469
이건 여러분이 구조체 비디오에서 봤던 예시입니다

18
00:00:58,469 --> 00:01:04,110
일단 실행시켜볼게요, 지난 시간에 우리는 구조체 typedef struct s_point를 만들었었습니다

19
00:01:04,110 --> 00:01:07,170
구조체의 멤버로는 int x, int y, char *name이 있고

20
00:01:07,170 --> 00:01:10,950
마지막에 구조체에 t_point라는 이름을 붙이고
길이가 3인 t_point 배열을 선언했습니다

21
00:01:10,950 --> 00:01:14,040
하지만 이 비디오에서는 배열을 쓰지 않을 거예요

22
00:01:14,040 --> 00:01:19,710
바로 객체를 사용할 겁니다, 이게 더 깔끔하죠

23
00:01:19,710 --> 00:01:22,880
이제 여기 그냥 p라고 넣을 거예요

24
00:01:22,880 --> 00:01:31,079
int i는 이미 있으니까, int와 t_point의 크기를 출력해 볼게요

25
00:01:31,079 --> 00:01:33,000
4와 16이 출력됐습니다, 왜 16일까요?

26
00:01:33,000 --> 00:01:38,100
int가 2개기 때문이에요, 첫 int에 4바이트, 두 번째 int도 4바이트, char *에 8바이트

27
00:01:38,100 --> 00:01:42,329
총 16바이트입니다. 이제 선언된 구조체의 struct 키워드를

28
00:01:42,329 --> 00:01:45,030
union으로 바꿔볼게요, 정확히 같은 문법을 사용해서요

29
00:01:45,030 --> 00:01:46,110
이렇게 구조체를 공용체로 대체할 수 있고

30
00:01:46,110 --> 00:01:47,520
둘의 차이를 볼 수 있을 겁니다

31
00:01:47,520 --> 00:01:56,070
이제 제 t_point는 고작 8바이트예요

32
00:01:56,070 --> 00:01:58,350
이유는, 구조체는 모든 자료형을 조립하기 때문입니다

33
00:01:58,350 --> 00:02:01,500
그러니까 구조체 int x – int y – char *name가 있다면

34
00:02:01,500 --> 00:02:03,450
여러분은 메모리에

35
00:02:03,450 --> 00:02:07,920
x를 위한 공간, y를 위한 공간, char *name을 위한 공간을 마련해주는 겁니다

36
00:02:07,920 --> 00:02:12,680
공용체의 경우에는 각각을 위한 공간을 예비해두는 대신에

37
00:02:12,680 --> 00:02:14,569
가장 큰 자료형을 위한 공간을 마련해둘 겁니다

38
00:02:14,569 --> 00:02:16,519
이 공간을

39
00:02:16,519 --> 00:02:21,290
int형으로 읽을 거라고 하든지, int형이지만 다른 이름으로 읽을 거라고 하든지,

40
00:02:21,290 --> 00:02:22,840
그건 여러분의 몫입니다

41
00:02:22,840 --> 00:02:24,829
여러분에게 모든 걸 털어놓는 건 그다지 재밌지 않지만,

42
00:02:24,829 --> 00:02:27,140
왜 char *로는 읽지 않을까요?

43
00:02:27,140 --> 00:02:30,139
char *로 읽을 경우를 바로 보여드리겠습니다

44
00:02:30,139 --> 00:02:31,909
만들어 두었던 공용체를 수정하면서

45
00:02:31,909 --> 00:02:36,379
pouet이라고 이름을 붙일게요

46
00:02:36,379 --> 00:02:38,959
아니, u_pouet라고 선언하고 보다 명확한 예시를 보여드리겠습니다

47
00:02:38,959 --> 00:02:40,549
t_pouet라고 이름 붙이고

48
00:02:40,549 --> 00:02:56,569
int i, 배열인 char *c의 길이를… 4만큼 넣어주고
float를 넣어줍시다, 이걸 유용하게 써보도록 하죠

49
00:02:56,569 --> 00:02:59,719
이걸로 해볼게요

50
00:02:59,719 --> 00:03:10,519
여기도 t_pouet죠. 구조체와 정확히 같은 방식으로 사용되었구요

51
00:03:10,519 --> 00:03:12,950
예를 들어보자면,

52
00:03:12,950 --> 00:03:21,949
p.i = 12라고 할당한 뒤 printf(“%d\n”, p.i)를 하면

53
00:03:21,949 --> 00:03:26,000
화면에 무엇을 띄우는지 볼 수 있습니다

54
00:03:26,000 --> 00:03:32,180
12군요, 아직까지는 좋습니다

55
00:03:28,129 --> 00:03:38,919
이제 아래쪽에 p.f = 0.0이라고 적고

56
00:03:39,109 --> 00:03:40,010
화면에 뭐가 출력될지 봅시다

57
00:03:40,010 --> 00:03:49,419
0이네요, 0, 제가 보려던 p.i의 값이 p.f의 값으로 바뀐 것을 보실 수 있습니다

58
00:03:49,419 --> 00:03:58,639
몇 초 전에 공용체는 float와 char [4]가 같은 메모리 공간을 사용한다고 말씀드렸습니다

59
00:03:58,639 --> 00:04:08,329
제가 왜 배열에 4를 넣었는지, 제 int는 항상 4바이트인지에 대해 이해가 되기 시작할 겁니다

60
00:04:08,329 --> 00:04:09,620
이런 경우에, 사실 둘은 동일한 메모리 공간을 사용해요

61
00:04:09,620 --> 00:04:11,180
방금은 제가 공용체 내부에 있는 멤버의 값을 각각 읽을 거라는 방식을 말해준 거구요

62
00:04:11,180 --> 00:04:12,799
그래서 p.f = 0이라고 썼을 때

63
00:04:12,799 --> 00:04:17,298
p.i와 동일한 위치에 0이라는 값을 넣었음을 알고 있습니다

64
00:04:17,298 --> 00:04:21,889
이제 p.i의 값을 읽으라고 하니까 int형으로 메모리 공간을 읽은 거죠

65
00:04:21,889 --> 00:04:23,740
그래서 0.0이 아닌 그냥 0이 출력된 거예요

66
00:04:23,740 --> 00:04:30,280
하지만 float가 정확한 값을 가지는 게 아니고,  int와 같은 방식으로 저장되는 건 아니라는 걸 보여드릴게요

67
00:04:30,280 --> 00:04:33,039
만약 1.4를 넣으면, 저도 모르겠네요

68
00:04:33,039 --> 00:04:33,880
무슨 값이 출력될까요?

69
00:04:33,880 --> 00:04:38,350
다소 이상한 값이 출력됐습니다

70
00:04:38,350 --> 00:04:39,520
비트를 int형으로 읽을 건데,

71
00:04:39,520 --> 00:04:41,350
float형으로 한 번 읽고 나서,

71
00:04:41,350 --> 00:04:43,750
1.4를 넘겨준거죠

72
00:04:43,750 --> 00:04:45,340
"%d %f\n"를 printf에 넣어서 보여드리면

73
00:04:45,340 --> 00:04:49,120
여기 소수값이 출력되지 않을 겁니다

74
00:04:49,120 --> 00:04:51,490
p.f도 넣을게요

75
00:04:51,490 --> 00:04:56,470
자, 1.4가 나와야합니다

76
00:04:56,470 --> 00:05:00,190
이제 재미있는 점은 제 char[4] 배열 역시 동작한다는 것입니다

77
00:05:00,190 --> 00:05:03,070
왜냐하면 마지막에 메모리에는 4개의 문자들만 있기 때문입니다, 4바이트죠

78
00:05:03,070 --> 00:05:08,500
소수가 정수 혹은 소수의 첫 번째, 두 번째, 세 번째, 네 번째 바이트를 가져간 것처럼,

79
00:05:08,500 --> 00:05:09,910
같은 방식이에요

80
00:05:09,910 --> 00:05:14,949
그래서 제가 만약

81
00:05:14,949 --> 00:05:16,810
p.c[0] = 0이라고 쓰고

82
00:05:16,810 --> 00:05:20,650
방금 int와 float를 수정했어요

83
00:05:20,650 --> 00:05:22,449
그렇게 좋지는 않지만요

84
00:05:22,449 --> 00:05:24,039
제 생각에는 이미 0이었어야 하기 때문인 것 같아요

85
00:05:24,039 --> 00:05:26,800
이쪽에 p.c[1]도 넣어보겠습니다

86
00:05:26,800 --> 00:05:30,490
값을 0으로 설정한다면 차이점이 있어야만 합니다

87
00:05:30,490 --> 00:05:33,909
2번째는 바꿨으니까 3번째 바이트를 바꿔볼까요

88
00:05:33,909 --> 00:05:38,820
이번에도 0의 값을 주었습니다

89
00:05:38,820 --> 00:05:41,470
보세요, 여기 뭔가를 바꾸는 중입니다

90
00:05:41,470 --> 00:05:43,419
당연하게도 제가 4번째 바이트에 0의 값을 준다면,

91
00:05:43,419 --> 00:05:45,909
무슨 일이 일어날까요?

92
00:05:45,909 --> 00:05:52,780
모든 값이 0이 될 겁니다, 이걸로 여러분은 동일한 공간의 메모리를

93
00:05:52,780 --> 00:05:55,870
세 종류의 다른 방식으로 읽은 걸 보실 수 있습니다

94
00:05:55,870 --> 00:06:01,570
잘 알지는 못하지만, 중요한 점은 공용체는 멤버의 자료형 중
가장 큰 사이즈를 자신의 사이즈로 갖는다는 것입니다

95
00:06:01,570 --> 00:06:07,610
예를 들어 여기 char *ptr를 넣으면,

96
00:06:07,610 --> 00:06:10,069
갑자기 제 t_pouet 공용체의 크기가

97
00:06:10,069 --> 00:06:12,949
4바이트가 더해져서 8바이트가 될 겁니다

98
00:06:12,949 --> 00:06:16,509
이렇게 한 번 해볼까요,

99
00:06:16,509 --> 00:06:26,319
sizeof(p)를 써서 출력해보면 p의 크기는 8입니다

100
00:06:26,319 --> 00:06:33,919
제가 char *를 지운다면 바로 4가 될 겁니다

101
00:06:33,919 --> 00:06:35,179
가장 큰 자료형만큼 공간을 마련하는 것이죠

102
00:06:35,179 --> 00:06:38,929
제가 공용체에 요청한 char *는 8바이트짜리니까,

103
00:06:38,929 --> 00:06:42,889
그러므로 이 8바이트에는 제가 int로 쓸 수 있거나,

104
00:06:42,889 --> 00:06:44,050
char형 배열로 사용할 수 있거나,

105
00:06:44,050 --> 00:06:48,229
float로 사용할 수 있는 4바이트가 있는 거예요

106
00:06:48,229 --> 00:06:51,459
나머지 4바이트는 제가 정말로 포인터(char *)를 사용할 때만 사용할 수 있습니다

107
00:06:51,459 --> 00:06:55,159
공용체에서 재밌는 점이 이것입니다

108
00:06:55,159 --> 00:06:56,839
공용체는 일부 특정한 상황에서 쓰입니다

109
00:06:56,839 --> 00:07:01,429
제가 생각하기로 일반적인 예시는 여러분이 파일을 읽을 때,

110
00:07:01,429 --> 00:07:03,919
비디오게임의 세이브를 예시로 든다면,

111
00:07:03,919 --> 00:07:09,349
여러분이 비디오게임 세이브 파일을 읽을 때, 실제로는 구조체와 공용체를 가지고 사용하게 될 겁니다

112
00:07:09,349 --> 00:07:14,479
구조체의 일부는 여러분이 세이브 파일의 자료를 어떻게 읽을지 알려주는 역할을 합니다

113
00:07:14,479 --> 00:07:15,769
여러분이 계속해서 읽으려고 한다면,

114
00:07:15,769 --> 00:07:18,289
공용체가 여러분이 읽으려는 내용을 알려줍니다

115
00:07:18,289 --> 00:07:23,029
예를 들면 사용자의 체력을, 몬스터의 체력을

116
00:07:23,029 --> 00:07:26,089
몬스터의 특징 등을요

117
00:07:26,089 --> 00:07:28,189
말하자면 공용체는 동일한 공간의 메모리에 접근해도

118
00:07:28,189 --> 00:07:31,369
다양한 방법으로 그 값을 사용할 수 있는, 다형성을 가진 객체입니다

119
00:07:31,369 --> 00:07:34,579
심지어는 여러분이 불러올 때 사용하는 바이너리 파일의 메모리도 읽을 수 있게 해줍니다

120
00:07:34,579 --> 00:07:35,920
마지막으로 기억해두세요…

121
00:07:35,920 --> 00:07:38,440
이건 메모리 공간이고, 여러분이 이 메모리를 읽을 방식이 중요합니다

122
00:07:38,440 --> 00:07:42,970
여러분이 이걸 어떤 방식으로 읽든간에 다 가능하다는 사실도 기억하세요

123
00:07:42,970 --> 00:07:44,350
공용체는 종종 이렇게 쓰입니다

124
00:07:44,350 --> 00:07:50,440
같은 데이터의 같은 파일을 다른 방식으로 읽을 수 있도록 해주죠

125
00:07:50,440 --> 00:07:53,830
왜냐하면 우리는 메모리보다 위에 있고, 다양한 방식으로 읽고자 하기 때문입니다

126
00:07:53,830 --> 00:07:58,210
플래그를, 기술을, 혹은 무언가 이렇게 읽으면 이렇게 된다고 하는 것들을 말이죠

127
00:07:58,210 --> 00:08:02,620
같은 파일에서 이후에는 차라리 여기에 링크할 겁니다

128
00:08:02,620 --> 00:08:08,350
널리 쓰이지는 않지만 극도로 강력한 도구입니다, 아주 가끔씩만 쓰세요

129
00:08:08,350 --> 00:08:12,180
지금까지 여러분은 union 키워드에 대해서 배우셨습니다
<< translated by ji-kim, mki, mseo, yeslee and inyang :) >>
