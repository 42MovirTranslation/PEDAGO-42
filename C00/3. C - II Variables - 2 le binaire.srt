1
00:00:01,000 --> 00:00:06,000
이 비디오는 비트와 바이트에 관한 것이고, 더 정확히 말하자면 2진수와 2진법에 관한 것입니다

2
00:00:06,000 --> 00:00:14,000
여러분 중 99%는 10진수로 수로 셀겁니다

3
00:00:14,000 --> 00:00:18,000
즉, 0부터 9까지의 숫자를 가지고 있다는 뜻이죠

4
00:00:18,000 --> 00:00:22,000
그리고 10이 되면 두자리 숫자를 씁니다

5
00:00:22,000 --> 00:00:24,000
더 나아가 수십, 수백 등의 단위를 가지고 사용하죠

6
00:00:24,000 --> 00:00:26,000
이것이 10진수입니다

7
00:00:26,000 --> 00:00:28,000
컴퓨터는 2진수로 세야 합니다

8
00:00:28,000 --> 00:00:33,000
왜냐하면 컴퓨터 메모리는 값이 0 또는 1인 비트로 구성되기 때문이죠

9
00:00:33,000 --> 00:00:40,000
그래서 2가 되면 10을 써야 합니다

10
00:00:40,000 --> 00:00:48,000
아마도 이상해보이겠죠, 오! 수학이 아니에요

11
00:00:48,000 --> 00:00:51,000
포기하지 마세요 10진수랑 비슷한겁니다

12
00:00:51,000 --> 00:00:56,000
먼저 10진수에 대해 설명한 후 2진수를 알아보겠습니다

13
00:00:56,000 --> 00:00:58,000
10진수는 이렇게 생겼습니다

14
00:00:58,000 --> 00:01:03,000
여기 10의 0 제곱이 있고, 여기에는 10의 제곱값이 있습니다

15
00:01:03,000 --> 00:01:08,000
예시를 들면 좋겠죠, 175가 있다고 칩시다

16
00:01:08,000 --> 00:01:11,000
이를 10진수로 쓰면 175입니다

17
00:01:11,000 --> 00:01:17,000
175는 1 * 100과, 7 * 10, 5 * 1로 만들 수 있죠

18
00:01:17,000 --> 00:01:27,000
그리고 92876, 이것도 쉽죠

19
00:01:27,000 --> 00:01:38,000
9 x 10000, 2 x 1000, 8 x 100, 7 x 10, 6 x 1

20
00:01:38,000 --> 00:01:41,000
제가 한 것을 보세요

21
00:01:41,000 --> 00:01:45,000
그 숫자에 10000이 몇 개나 있는지

22
00:01:45,000 --> 00:01:48,000
그럼 나머지 2876에는 1000이 몇 개인가요

23
00:01:48,000 --> 00:01:50,000
2개죠

24
00:01:50,000 --> 00:01:51,000
100은 8개고,

25
00:01:51,000 --> 00:01:53,000
10은 7개,

26
00:01:53,000 --> 00:01:56,000
1은 6개가 있습니다

27
00:01:56,000 --> 00:02:00,000
이게 10진수로 수를 분리하는 방법입니다

28
00:02:00,000 --> 00:02:02,000
여기서 중요한 것은 ‘값’입니다

29
00:02:02,000 --> 00:02:08,000
간단합니다, 어떤 값을 10진수로 쓰면 우리 모두가 10진수로 이해합니다

30
00:02:08,000 --> 00:02:15,000
값 ‘12’를 예로 들어봅시다

31
00:02:15,000 --> 00:02:20,000
12는 1 2 로 쓰여있죠, ok

32
00:02:20,000 --> 00:02:24,000
지금 제 앞에 12개의 사과가 있다고 해봅시다, 그들은 물리적으로 존재하죠

33
00:02:24,000 --> 00:02:27,000
제가 10진수로 사과가 12개 있다고 말합니다, 그러면 여러분은 그걸 알아들을 겁니다

34
00:02:27,000 --> 00:02:30,000
사과가 12개 있구나 생각하겠죠

35
00:02:30,000 --> 00:02:33,000
이제 2진수로 바꿔보겠습니다

36
00:02:33,000 --> 00:02:35,000
2진수는 10진수와 같은 방식입니다

37
00:02:35,000 --> 00:02:38,000
단 10 대신에 2로 계산해야겠죠 2의 0제곱, 등등

38
00:02:38,000 --> 00:02:45,000
그러면 1, 2, 4, 8, 16, 32, 등등이겠죠

39
00:02:45,000 --> 00:02:48,000
그러면 12를 2진수로 써봅시다

40
00:02:48,000 --> 00:02:54,000
10진수에서는 백만, 십만을 맞출때,

41
00:02:54,000 --> 00:02:59,000
이 숫자를 쓰기 위해 ‘0’을 더할 수 있습니다

42
00:02:59,000 --> 00:03:03,000
같은 것입니다, 128은 12에 몇개나 있을까요? 0개죠

43
00:03:03,000 --> 00:03:06,000
12에 64는 0개가 있고,

44
00:03:06,000 --> 00:03:09,000
12에 32는 0개가 있고,

45
00:03:09,000 --> 00:03:10,000
12에 16는 0개가 있고,

46
00:03:10,000 --> 00:03:12,000
12에 8는 하나가 있고,

47
00:03:12,000 --> 00:03:15,000
4가 남았죠, 4에는 4가 하나 있습니다

48
00:03:15,000 --> 00:03:20,000
그러면 0이 남네요

49
00:03:20,000 --> 00:03:24,000
그러면 12 = 1100이죠

50
00:03:24,000 --> 00:03:27,000
2진법으로 말하는 사람에게

51
00:03:27,000 --> 00:03:33,000
1100개의 사과가 있다고 말하면, 그 사람도 납득할 것입니다

52
00:03:33,000 --> 00:03:40,000
만약 10진법을 쓰는 사람에게 2진수로 말했다면, 큰 문제가 생길겁니다

53
00:03:40,000 --> 00:03:43,000
진법은 단지 어떤 값의 표현이라는 것을 기억하세요

54
00:03:43,000 --> 00:03:51,000
12는 10진수로는 10이고 2진수로는 1100입니다

55
00:03:51,000 --> 00:03:54,000
진법은 단지 수를 표현하는 방식에 불과합니다

56
00:03:54,000 --> 00:04:03,000
그러나 값 자체가 변하진 않습니다 이게 매우 중요합니다

57
00:04:03,000 --> 00:04:11,000
여기에 세로줄을 8개 넣었는데, 8비트를 표현하려는 목적입니다

58
00:04:11,000 --> 00:04:19,000
그러면 1 바이트로 표현 가능한 가장 큰 숫자는 무엇일까요?

59
00:04:19,000 --> 00:04:23,000
간단합니다, 모든 비트를 1로 만들면 됩니다

60
00:04:23,000 --> 00:04:31,000
이게 가장 큰 숫자입니다, 왜냐하면 단순하게도 1만 있으니까요

61
00:04:31,000 --> 00:04:33,000
그래서 그 값이 뭘까요?

62
00:04:33,000 --> 00:04:38,000
1+2+4+8+16+32+64+128 입니다

63
00:04:38,000 --> 00:04:40,000
이 숫자를 아주 간단하게 계산할 수 있습니다

64
00:04:40,000 --> 00:04:44,000
만약 제가 1을 이 숫자에 더한다면, 어떻게 될까요?

65
00:04:44,000 --> 00:04:52,000
1 + 1은 2이니까 0을 써야겠죠, 왼쪽에 1을 추가해야 합니다

66
00:04:52,000 --> 00:04:56,000
마찬가지로 1 + 1은 2니까 0을 쓰고 왼쪽으로 넘어갑니다

67
00:04:56,000 --> 00:05:06,000
여기까지 계속해서 반복하겠죠

68
00:05:06,000 --> 00:05:15,000
그러면 이 값은 2^8  - 1이 됩니다

69
00:05:15,000 --> 00:05:19,000
2의 8제곱은 256이고, 당연히 2 * 128이죠

70
00:05:19,000 --> 00:05:29,000
그리고 1을 빼면, 255죠

71
00:05:29,000 --> 00:05:34,000
지금 당장은 양수만 다루기로 하죠

72
00:05:34,000 --> 00:05:40,000
255는 양수이지만, 딱 8비트만 사용한 수입니다

73
00:05:40,000 --> 00:05:46,000
우리는 더 많은 숫자와 값을 표현할 필요가 있어요

74
00:05:46,000 --> 00:05:53,000
바로 여기 이 비트가 양수나 음수를 표현한다고 생각해보세요

75
00:05:53,000 --> 00:05:55,000
이 비트가 1이면, 음수가 됩니다

76
00:05:55,000 --> 00:06:00,000
이 비트가 0일때, 양수가 됩니다

77
00:06:00,000 --> 00:06:05,000
이제 이 수는 무슨 값이 될까요?

78
00:06:05,000 --> 00:06:10,000
여기 비트가 1이니까 확실히 음수인건 알 수 있겠네요

79
00:06:10,000 --> 00:06:16,000
그래서 어떤 수일까요? 간단합니다

80
00:06:16,000 --> 00:06:21,000
이전과 같은 방식으로 1을 더한다면

81
00:06:21,000 --> 00:06:29,000
이 모든 비트가 0이 됩니다

82
00:06:29,000 --> 00:06:33,000
제 메모리에는 8비트 공간만 있기 때문에

83
00:06:33,000 --> 00:06:38,000
1을 여기에 써야 하지만 8비트가 한계라서 그럴수가 없죠

84
00:06:38,000 --> 00:06:42,000
그러면 모든 비트가 0이므로 이 수는 0이겠군요

85
00:06:42,000 --> 00:06:46,000
즉, 이 숫자는 1을 더하면 0과 같습니다

86
00:06:46,000 --> 00:06:49,000
뭐가 1을 더하면 0이 될까요?

87
00:06:49,000 --> 00:06:54,000
간단하죠, -1입니다

88
00:06:54,000 --> 00:06:56,000
이는 음수를 표현하기 위한 부호가 있는 값입니다

89
00:06:56,000 --> 00:07:00,000
변수 자료형을 알아볼 때 부호가 있는 값이 뭔지 살펴봤습니다

90
00:07:00,000 --> 00:07:06,000
메모리에 1만 있는 이 값은 음수와 양수를 모두 고려한다면 -1과 같습니다

91
00:07:06,000 --> 00:07:13,000
그리고 만약 양수만 고려한다면 255와 같습니다

92
00:07:13,000 --> 00:07:17,000
이는 컴퓨터를 제대로 조작하기 위해 중요합니다

93
00:07:17,000 --> 00:07:19,000
메모리에 모든 비트가 1일때

94
00:07:19,000 --> 00:07:22,000
컴퓨터에게 이 값을 부호가 있다고 해석하게 할지,

95
00:07:22,000 --> 00:07:24,000
혹은 부호가 없는 정수로 해석하게 할지 선택할 수 있습니다

96
00:07:24,000 --> 00:07:30,000
이는 계산에 영향을 미칩니다

97
00:07:30,000 --> 00:07:40,000
부호가 없는 정수일 때, 최솟값은 0이고 최대값은 255입니다

98
00:07:40,000 --> 00:07:46,000
부호가 있는 정수일 때, 최솟값은 0이 아닙니다

99
00:07:46,000 --> 00:07:50,000
메모리에서 최솟값은 0일 수는 있습니다 비트가 모두 0일 때요

100
00:07:50,000 --> 00:07:55,000
최댓값은 비트가 모두 1일 때인데, 이는 -1입니다

101
00:07:55,000 --> 00:08:01,000
하지만 사람에게 이것들은 최대값과 최솟값이 아닙니다

102
00:08:01,000 --> 00:08:06,000
가장 높은 양수는 이것이겠죠

103
00:08:06,000 --> 00:08:12,000
같은 트릭을 사용합니다, 1을 더합니다

104
00:08:12,000 --> 00:08:16,000
이 수는 128 - 1을 의미하므로, 127입니다

105
00:08:16,000 --> 00:08:20,000
부호가 있는 정수에서 진짜 최대값은 127입니다

106
00:08:20,000 --> 00:08:31,000
그리고 진짜 최솟값은 간단하게 쓸 수 있습니다, 이렇게요

107
00:08:31,000 --> 00:08:38,000
이게 음수로 무슨 값일까요?

108
00:08:38,000 --> 00:08:42,000
이 값에서부터 0까지 가봅시다

109
00:08:42,000 --> 00:08:50,000
여기에 1을 더하고, 더하기를 반복합니다

110
00:08:50,000 --> 00:08:53,000
1이 계속 있으니 반복해서 1을 더해야겠죠

111
00:08:53,000 --> 00:09:04,000
그래서 이 숫자가 뭘까요? 이게 전부 1이라면?

112
00:09:04,000 --> 00:09:23,000
이 수를 X라고 부르고, 이 수에 127을 더하면 -1입니다

113
00:09:23,000 --> 00:09:27,000
그러면 X는 -128이겠군요

114
00:09:27,000 --> 00:09:32,000
따라서 1바이트에서는, 부호가 있는 정수의

115
00:09:32,000 --> 00:09:40,000
최솟값은 -128이고, 최대값은 127입니다

116
00:09:40,000 --> 00:09:44,000
1바이트일때는 이렇죠, 숫자를 표현하기 위해 4바이트를 사용한다고 해봅시다

117
00:09:44,000 --> 00:09:46,000
훨씬 더 큰 양수와

118
00:09:46,000 --> 00:09:50,000
훨씬 더 작은 음수를 표현할 수 있겠죠

119
00:09:50,000 --> 00:09:59,000
만약 부호가 없는 정수라면, 최대값은 훨씬 더 커지겠죠

120
00:09:59,000 --> 00:10:01,000
결론은 다르게 읽힐 수 있다는 것입니다

121
00:10:01,000 --> 00:10:03,000
컴퓨터 메모리는 두 가지 방법으로 모두 읽힐 수 있습니다

122
00:10:03,000 --> 00:10:07,000
부호가 없는 정수와 부호가 있는 정수

123
00:10:07,000 --> 00:10:10,000
결과는 달라질겁니다

124
00:10:10,000 --> 00:10:14,000
하지만 메모리에서는 같죠

125
00:10:14,000 --> 00:10:17,000
이것, -1은 부호가 없는 정수에서 255이고

126
00:10:17,000 --> 00:10:22,000
부호가 있는 정수에서 -1입니다

127
00:10:22,000 --> 00:10:30,000
이 라인은 두 경우 모두에서 127입니다, 왜냐하면 부호 비트가 0이니까요

128
00:10:30,000 --> 00:10:33,000
이 라인은 부호가 없는 정수에서 128입니다

129
00:10:33,000 --> 00:10:39,000
그리고 부호가 있는 정수에서 -128입니다

130
00:10:39,000 --> 00:10:45,000
여기 부호 비트는 사용할 바이트 수에 따라 결정됩니다

131
00:10:45,000 --> 00:10:50,000
부호 비트는 1 비트만 차지하고, 다른 비트가 얼마나 사용되는지에 따라 결정됩니다

132
00:10:50,000 --> 00:10:54,000
부호 비트가 최댓값과 최솟값을 표현하기 위해 사용될 수도 있겠죠

133
00:10:54,000 --> 00:11:00,000
이제 2진법과 메모리 바이트가 무엇인지 이해했습니다

134
00:11:00,000 --> 00:11:04,000
아마 이 지식을 이해하려면 시간이 좀 필요할 것입니다

135
00:11:04,000 --> 00:11:07,000
이제 여러분은 컴퓨터 메모리 기본 동작에 대해 배웠습니다

136
00:11:07,000 --> 00:11:10,000
남은 것은 입력받은 값이 해석되는 방식입니다

137
00:11:10,000 --> 00:59:59,000
다음 영상에서는 변수형에 대해 알아봅시다, 그 방식을 잘 알려드릴게요 :D
<< translated by inyang, chelee, mki, yeslee and mseo :) >>
