1
00:00:05,430 --> 00:00:07,420
이번 영상에서는 “const”라는

2
00:00:07,420 --> 00:00:10,030
키워드에 대해 이야기해보겠습니다

3
00:00:10,030 --> 00:00:12,640
자, “const”는 뭘 위한 걸까요?

4
00:00:12,640 --> 00:00:14,850
주로 개발자들 사이에서 약속 같은 것을 만들기 위함입니다

5
00:00:14,850 --> 00:00:19,570
특히 여러분이나 다른 개발자가 변수를 수정하는 것을

6
00:00:19,570 --> 00:00:21,279
막고 싶을 때 사용됩니다

7
00:00:21,279 --> 00:00:24,279
자, 그럼 바로 예제를 볼까요?

8
00:00:24,279 --> 00:00:26,949
그러면 좀 더 이해하기 수월할 겁니다

9
00:00:26,949 --> 00:00:28,589
아주 쉬운 예제입니다

10
00:00:28,589 --> 00:00:34,450
우선, “int”를 선언하고

11
00:00:34,450 --> 00:00:37,770
“int” 왼쪽에 “const”를 추가해줍시다

12
00:00:37,770 --> 00:00:41,200
printf로 const 변수를 인자로 주고

13
00:00:41,200 --> 00:00:43,870
컴파일하면, 변수를

14
00:00:43,870 --> 00:00:45,960
이렇게 출력할 겁니다

15
00:00:49,210 --> 00:00:53,230
짠! 컴파일하고 실행하니

16
00:00:53,230 --> 00:00:55,780
평소처럼 잘 동작합니다

17
00:00:55,780 --> 00:00:57,820
14를 여기에 출력하네요

18
00:00:57,820 --> 00:01:00,370
모두 좋습니다

19
00:01:00,370 --> 00:01:04,599
그런데 우리는 “const” 키워드를 사용했습니다

20
00:01:04,599 --> 00:01:07,630
“const”는 뭘 하나요?

21
00:01:07,630 --> 00:01:12,250
구체적으로, 만약 변수 a의 값을

22
00:01:12,250 --> 00:01:14,259
13으로 변경해

23
00:01:14,259 --> 00:01:17,890
새로운 값이 변수 a에 입력되면

24
00:01:17,890 --> 00:01:21,640
컴파일러는 오류를 출력합니다, "어….안돼. 돌아가. 이건 불가능해"

25
00:01:21,640 --> 00:01:24,070
왜냐하면, 변수 a는 “const”, 즉 “int const” 이기 때문입니다

26
00:01:24,070 --> 00:01:25,960
그래서, 절대로

27
00:01:25,960 --> 00:01:28,830
제가 했던 것처럼, 새로운 값을 줄 수 없습니다

28
00:01:28,830 --> 00:01:33,670
“const”는 주로 무엇을 위해 사용될까요?

29
00:01:33,670 --> 00:01:36,479
“const”는 이런 경우에 유용합니다

30
00:01:36,479 --> 00:01:38,979
예를 들어, 전역변수가 있지만

31
00:01:38,979 --> 00:01:40,420
구조체처럼 매우 한정적인 곳에서만

32
00:01:40,420 --> 00:01:42,640
사용될 때 유용합니다

33
00:01:42,640 --> 00:01:47,470
아니면, 데이터 타입을 확실히 하고 싶을 때도 유용합니다

34
00:01:47,470 --> 00:01:49,600
일반적으로 “int a = 14”는 강한 선언이 아닙니다

35
00:01:49,600 --> 00:01:51,970
"char", "int", "long int"라는 것을 확실히 하고 싶을 때

36
00:01:51,970 --> 00:01:54,520
"const"를 사용합니다

37
00:01:54,520 --> 00:01:58,810
그러나 “const”는 포인터와 함께 주로 사용됩니다

38
00:01:58,810 --> 00:02:01,630
왜 포인터일까요?

39
00:02:01,630 --> 00:02:05,530
왜냐하면 포인터는 포인터가 가리키는 값을

40
00:02:05,530 --> 00:02:08,199
변경하는 것을 허용합니다

41
00:02:08,199 --> 00:02:09,850
그런데 가끔은 포인터의 값이 변경되는 것을

42
00:02:09,850 --> 00:02:11,470
피하고 싶기도 합니다

43
00:02:11,470 --> 00:02:16,480
그래서 포인터의 값을 바꾸려고 할 때

44
00:02:16,480 --> 00:02:19,989
이 변수는 상수라서 변경할 수 없다고

45
00:02:19,989 --> 00:02:23,680
알려줄 수 있습니다

46
00:02:23,680 --> 00:02:29,829
그럼, 인자를 받는 함수를 예로 들어보겠습니다

47
00:02:29,829 --> 00:02:31,660
이 함수는 int 배열의 포인터를 인자로 받습니다

48
00:02:31,660 --> 00:02:36,070
이 함수가 하는 것은 뭘까요?

49
00:02:36,070 --> 00:02:39,130
꽤 간단합니다

50
00:02:39,130 --> 00:02:41,410
int 배열을 탐색하고

51
00:02:41,410 --> 00:02:44,620
0이 int 배열 안에 얼마나 있는지 세는 함수입니다

52
00:02:44,620 --> 00:02:48,610
그리고 0의 개수를 반환합니다

53
00:02:48,610 --> 00:02:51,670
여기서 중요한 점은

54
00:02:51,670 --> 00:02:55,390
이 함수는 int 배열을 읽지만

55
00:02:55,390 --> 00:02:59,950
절대 int 배열의 값을 변경하지는 않습니다

56
00:02:59,950 --> 00:03:04,209
그래서 이렇게 할 수 있습니다

57
00:03:04,209 --> 00:03:07,660
여기에 “const” 키워드를 넣어서

58
00:03:07,660 --> 00:03:15,190
수정할 수 없게 만들어줍니다

59
00:03:15,190 --> 00:03:29,130
그래서 여기에 int 배열을 선언해주고 아무 값이나 넣어줍시다

60
00:03:31,140 --> 00:03:36,730
(넣는 중)

61
00:03:36,730 --> 00:03:37,120
이건 이제 필요 없군요

62
00:03:37,120 --> 00:03:44,129
여기에 함수의 프로토타입을 넣어주고

63
00:03:48,550 --> 00:03:51,550
(작업 중)

64
00:03:57,460 --> 00:03:58,690
짜란~

65
00:03:58,690 --> 00:04:01,270
fct.c 파일을 추가해서

66
00:04:01,270 --> 00:04:07,600
컴파일하면

67
00:04:07,600 --> 00:04:08,760
어라?

68
00:04:08,760 --> 00:04:13,210
일단, printf를 그대로 두고

69
00:04:13,210 --> 00:04:15,850
fct의 반환 값을 출력하고 싶으면,

70
00:04:15,850 --> 00:04:20,310
fct 함수에 int 배열의 주소를 넣어주고,

71
00:04:20,310 --> 00:04:28,630
크기를 6으로 해서, 짜란~

72
00:04:28,630 --> 00:04:30,520
컴파일되고 2를 출력합니다

73
00:04:30,520 --> 00:04:32,920
0이 2개가 있네요

74
00:04:32,920 --> 00:04:34,150
모두…

75
00:04:34,150 --> 00:04:37,810
모두 다 잘 동작합니다

76
00:04:37,810 --> 00:04:41,620
그러나, 함수 안에서

77
00:04:41,620 --> 00:04:44,080
int 배열을 수정한다면

78
00:04:44,080 --> 00:04:46,030
여기에 이렇게 해볼까요?

79
00:04:46,030 --> 00:04:54,700
tab[i]에 15를 입력하고 다시 컴파일하면

80
00:04:54,700 --> 00:04:56,560
컴파일러는 다시 오류를 출력합니다

81
00:04:56,560 --> 00:04:59,430
“안돼! 이건 불가능해!”

82
00:04:59,430 --> 00:05:02,230
왜냐하면 tab[i]는 “const”잖아!

83
00:05:02,230 --> 00:05:05,970
그리고 함수에 선언한 매개변수 또한 “const”입니다

84
00:05:05,970 --> 00:05:08,380
“const”는 선언문의 왼쪽에 있든

85
00:05:08,380 --> 00:05:11,680
오른쪽에 있든 잘 적용됩니다

86
00:05:11,680 --> 00:05:13,480
그러나 일반적으로

87
00:05:13,480 --> 00:05:14,740
이걸 이렇게 쓰는 것은 언어의 남용입니다

88
00:05:14,740 --> 00:05:17,850
“const”는 왼쪽에 있는 무엇이든지 적용됩니다

89
00:05:17,850 --> 00:05:20,740
그래서 const를 int의 오른쪽에 적어도

90
00:05:20,740 --> 00:05:22,810
결과는 같고, “const”가

91
00:05:22,810 --> 00:05:25,210
int에 잘 적용이 된 것을 볼 수 있습니다

92
00:05:25,210 --> 00:05:26,160
이게 무엇을 의미하는 걸까요?

93
00:05:26,160 --> 00:05:30,900
컴파일해보면 정확히

94
00:05:30,900 --> 00:05:32,530
같은 결과를 얻을 수 있습니다

95
00:05:32,530 --> 00:05:35,140
여기에서 보시다시피

96
00:05:35,140 --> 00:05:38,850
프로토타입은 수정하지 않았습니다

97
00:05:38,850 --> 00:05:40,890
왜냐하면 사실 “const”는 컴파일용이기 때문에,

98
00:05:40,890 --> 00:05:42,840
“const”는 컴파일할 때 고려될 겁니다

99
00:05:42,840 --> 00:05:44,250
그래서 문제가 없습니다

100
00:05:44,250 --> 00:05:46,350
(그런데 이건 깔끔하지 않으니 하지 마세요)

101
00:05:46,350 --> 00:05:49,670
그러나 여기를 수정할 필요는 없습니다

102
00:05:49,670 --> 00:05:53,270
왜냐하면 컴파일할 때 알아서 잘 처리해주기 때문이에요

103
00:05:53,270 --> 00:05:58,280
그리고 만약 여러분이 어떤 것에 “const”를 붙이면,

104
00:05:58,280 --> 00:05:59,870
컴파일러는 가끔 특정 상황에서, 특정한 무언가를

105
00:05:59,870 --> 00:06:02,240
조금이라도 더 최적화할 수 있습니다

106
00:06:02,240 --> 00:06:04,510
(어셈블리 단계에서 코드가 줄어듭니다)

107
00:06:04,510 --> 00:06:06,800
이번에 볼 것은,

108
00:06:06,800 --> 00:06:10,010
만약 “const”를 사용한다면,

109
00:06:10,010 --> 00:06:14,570
"int"에 “const”를 적용할 수 있을 뿐만 아니라

110
00:06:14,570 --> 00:06:17,030
여기에도 “const”를 추가할 수 있으며

111
00:06:17,030 --> 00:06:19,760
포인터 또한 “const”라는 뜻입니다

112
00:06:19,760 --> 00:06:27,500
자, 예를 들어 여기에 “tab++”를 하면

113
00:06:27,500 --> 00:06:34,100
기존 오류가 발생할 뿐만 아니라,

114
00:06:34,100 --> 00:06:36,230
새로운 에러 메시지가 나타납니다:

115
00:06:36,230 --> 00:06:40,610
“안돼! Tab도 "const"야!”

116
00:06:40,610 --> 00:06:42,920
사실, “tab” 포인터는 여기에 const로 선언한 이상

117
00:06:42,920 --> 00:06:45,160
포인터 위치를 바꿀 수 없습니다

118
00:06:45,160 --> 00:06:47,300
그래서, “const”는

119
00:06:47,300 --> 00:06:49,640
일종의 약속을 만드는 데 큰 도움이 됩니다

120
00:06:49,640 --> 00:06:52,550
여기 “size”는 “const”를 추가할 필요는 없습니다

121
00:06:52,550 --> 00:06:53,690
왜냐하면 이건 값의 복사본이기 때문이에요, 좋아요

122
00:06:53,690 --> 00:06:56,480
만약, 함수 안에서 바뀌지 않을 것이라면

123
00:06:56,480 --> 00:07:00,560
“const”를 여기에 적어줄 수 있습니다

124
00:07:04,310 --> 00:07:06,750
“const”를 지원하는 언어들이 있습니다

125
00:07:06,750 --> 00:07:09,330
“const”는 매우 효과적이거든요

126
00:07:09,330 --> 00:07:11,970
예를 들어 C++에서 “const”를 참조자라고

127
00:07:11,970 --> 00:07:13,590
부르는 것과 함께 사용합니다, 꽤 놀랍습니다

128
00:07:15,030 --> 00:07:20,910
그러나 지금 “const”는 포인터와 함께 사용됩니다

129
00:07:20,910 --> 00:07:23,250
“const”는 정말 정말 유용합니다

130
00:07:23,250 --> 00:07:25,740
“const”는 말하죠

131
00:07:25,740 --> 00:07:28,800
“음…

132
00:07:28,800 --> 00:07:31,650
만약 fct 함수를 사용한다면

133
00:07:31,650 --> 00:07:34,980
알아둬야 할 것이 있는데,

134
00:07:34,980 --> 00:07:37,530
int 배열 안의 int 값을 변경하지 않을 것이고,

135
00:07:37,530 --> 00:07:39,900
size도 변경하지 않을 거야"

136
00:07:39,900 --> 00:07:42,270
그래서 “const”는 코드에

137
00:07:42,270 --> 00:07:43,860
일종의 명료성을 갖게 해주고,

138
00:07:43,860 --> 00:07:46,919
변경되지 않을 것이라는 약속을 해줍니다

139
00:07:46,919 --> 00:07:51,690
다른 예로, 만약

140
00:07:51,690 --> 00:07:53,750
“strlen”의 프로토타입을 보면

141
00:07:53,750 --> 00:08:05,820
“const char *”가 선언된 것을 볼 수 있으며,

142
00:08:05,820 --> 00:08:11,070
이 함수는 인자로 주어진 string의 값을

143
00:08:11,070 --> 00:08:13,140
절대로 수정하지 않으며

144
00:08:13,140 --> 00:08:15,000
이 string은 보호될 것이고

145
00:08:15,000 --> 00:08:16,530
원본 그대로 있을 것이라는 뜻입니다

146
00:08:16,530 --> 00:08:20,570
그래서 이 약속은 깨지지 않습니다

147
00:08:20,570 --> 00:08:24,750
“const”는 아주 강력한 약속이며,

148
00:08:24,750 --> 00:08:28,500
변수를 수정하지 않겠다는 아주 쉬운 코드입니다
<< translated by inyang, chelee, yeslee, ji-kim, mseo, and mki :) >>
