1
00:00:01,000 --> 00:00:03,000
이 비디오는 다양한 변수 유형을 설명하는 영상입니다.

2
00:00:03,000 --> 00:00:10,000
앞선 비디오에서는 정수형의 한 가지 유형, int 변수에 대해서만 이야기 했습니다.

3
00:00:10,000 --> 00:00:13,000
오늘은 3개의 또 다른 변수들을 알아볼 것 입니다.

4
00:00:13,000 --> 00:00:20,000
우리는 이전에 바이너리, 비트와 바이트에 대해서 이야기 했습니다.

5
00:00:20,000 --> 00:00:22,000
바이너리 관련 영상을 보지 않았다면, 보는 것을 추천해드립니다.

6
00:00:22,000 --> 00:00:25,000
그렇지 않으면 이 영상이 매우 어려울 수 있습니다.

7
00:00:25,000 --> 00:00:28,000
이제 명확한 이해를 위해 코드를 보여드리겠습니다.

8
00:00:28,000 --> 00:00:32,000
메인 함수가 있고, 이 함수는 현재 비어있습니다.

9
00:00:32,000 --> 00:00:38,000
그리고 이제 변수의 가장 작은 타입, char에 대해서 이야기해봅시다.

10
00:00:38,000 --> 00:00:42,000
char는 1바이트에 해당합니다.

11
00:00:42,000 --> 00:00:45,000
일부 원칙론자들은 1바이트가 아닌 char가 있다고 하지만

12
00:00:45,000 --> 00:00:50,000
우리는 char가 1 바이트의 값을 가진다고 합시다.

13
00:00:50,000 --> 00:00:58,000
일부 프로세서에서 char가 1 바이트를 넘을 수 있다는 것은 사실입니다.

14
00:00:58,000 --> 00:01:00,000
이 변수의 크기를 어떻게 알 수 있을까요?

15
00:01:00,000 --> 00:01:04,000
C에서는 알 수 있는 방법이 있습니다.

16
00:01:04,000 --> 00:01:09,000
이걸 사용해볼게요. 하지만 %lu를 설명하지는 않겠습니다. printf가 어떻게 작동하는지 살펴보면 더 쉬울 것입니다.

17
00:01:09,000 --> 00:01:15,000
그리고 “sizeof” 라는 키워드를 사용하겠습니다.

18
00:01:15,000 --> 00:01:18,000
“sizeof”를 사용하면 변수의 크기를 얻을 수 있습니다.

19
00:01:18,000 --> 00:01:23,000
이 곳에 sizeof(char)를 쓸 수도 있었지만, 똑같습니다.

20
00:01:23,000 --> 00:01:29,000
컴파일 후, 실행해보겠습니다.

21
00:01:29,000 --> 00:01:32,000
결과는 1, char의 사이즈는 1입니다.

22
00:01:32,000 --> 00:01:40,000
1바이트.

23
00:01:40,000 --> 00:01:43,000
바이너리 비디오를 기억해보세요. 이 값은 signed형 입니다. (음수, 양수 모두 사용 가능)

24
00:01:43,000 --> 00:01:46,000
char의 최대값은 127입니다.

25
00:01:46,000 --> 00:01:49,000
char의 최솟값은 -128입니다.

26
00:01:49,000 --> 00:01:54,000
8비트로 표현 할 수 있는 범위입니다.

27
00:01:54,000 --> 00:01:56,000
오직 1 바이트로요.

28
00:01:56,000 --> 00:02:00,000
char형에서 또 다른 중요한 것은 아스키 표입니다.

29
00:02:00,000 --> 00:02:07,000
이 유형은 문자를 저장하기 때문에 char라고 불립니다.

30
00:02:07,000 --> 00:02:09,000
모든 문자는, 메모리에 넣을 수 있습니다.

31
00:02:09,000 --> 00:02:11,000
메모리 안은 비트로 이루어져있고, 비트 8개가 모이면 1 바이트입니다.

32
00:02:11,000 --> 00:02:15,000
그리고 컴퓨터에 char형을 출력하거나 처리하는 방법을 입력하면

33
00:02:15,000 --> 00:02:17,000
컴퓨터는 그대로 동작할 겁니다.

34
00:02:17,000 --> 00:02:21,000
이 모든 경우, 이건 그저 1과 0입니다. 이것은 중요합니다.

35
00:02:21,000 --> 00:02:26,000
여기 아스키 표가 있습니다.

36
00:02:26,000 --> 00:02:30,000
여기 있습니다. (짜잔)

37
00:02:30,000 --> 00:02:39,000
문자를 출력해야 할 때, 우리가 가진 것은 오직 1과 0뿐입니다.

38
00:02:39,000 --> 00:02:44,000
어떻게? 간단합니다. 사람들은 이 값이 이 문자와 대입하는 표를 만들었습니다.

39
00:02:44,000 --> 00:02:52,000
봅시다. 이건 8진수입니다. 스크롤을 내리겠습니다.

40
00:02:52,000 --> 00:02:55,000
10진수에서 74는 J입니다. 대문자 J

41
00:02:55,000 --> 00:03:06,000
82는 R, 98은 b, 107은 k 등등.

42
00:03:06,000 --> 00:03:10,000
C에서, 이것들을 어떻게 간단히 작성할까요?

43
00:03:10,000 --> 00:03:17,000
저는 k라는 문자를 원합니다. 그 값은 k입니다.

44
00:03:17,000 --> 00:03:23,000
작은 따옴표 사이에 한 글자만 쓰겠습니다. 문자 단 한 개. 여기 k가 있습니다.

45
00:03:23,000 --> 00:03:32,000
%d는 값을 숫자 형태로 직접 표시합니다.

47
00:03:32,000 --> 00:03:36,000
%c는 문자로 값을 표시합니다.

48
00:03:36,000 --> 00:03:40,000
c값을 두 번 사용하겠습니다.

49
00:03:40,000 --> 00:03:45,000
k가 107이란 것을 기억하세요.

50
00:03:45,000 --> 00:03:48,000
이제 컴파일 후 실행합니다

51
00:03:48,000 --> 00:03:50,000
1은 문자의 크기입니다.

52
00:03:50,000 --> 00:03:53,000
107은 그 값 (아스키 표에서의 값)

53
00:03:53,000 --> 00:03:59,000
k를 아스키 표에 설명 된대로 문자로 출력 할 때 입니다.

54
00:03:59,000 --> 00:04:02,000
그러나 메모리 안에서, c의 값은 107입니다.

55
00:04:02,000 --> 00:04:12,000
%c는 숫자를 출력하지 않고 c에 대응하는 아스키 값을 출력합니다.

57
00:04:12,000 --> 00:04:16,000
여기서 k 대신 줄 바꿈 문자 \n을 쓸 수 있습니다.

58
00:04:16,000 --> 00:04:20,000
\n이 무슨 값인지 기억나지 않지만,

59
00:04:20,000 --> 00:04:24,000
출력해보니 잘 나왔고, 그 값은 10입니다.

60
00:04:24,000 --> 00:04:26,000
좋습니다. char 였습니다.

61
00:04:26,000 --> 00:04:30,000
char는 signed. 이는 양수와 음수 모두 가질 수 있음을 의미합니다.

62
00:04:30,000 --> 00:04:33,000
-128부터 127까지요.

63
00:04:33,000 --> 00:04:37,000
이제 int를 봅시다.

64
00:04:37,000 --> 00:04:41,000
이제 int가 더 큰 것을 볼 수 있습니다.

65
00:04:41,000 --> 00:04:50,000
몇 가지를 제거하고 i를 넣겠습니다.

66
00:04:50,000 --> 00:04:57,000
컴파일, 그리고 실행. int는 4 바이트입니다.

67
00:04:57,000 --> 00:05:01,000
int는 정수형이자 signed형으로 양수와 음수 값을 가집니다.

68
00:05:01,000 --> 00:05:05,000
4 바이트 (= 32비트)입니다.

69
00:05:05,000 --> 00:05:12,000
숫자값 자체에 대해 31 비트, 부호에 대해 1비트를 가진다고 볼 수 있습니다.

70
00:05:12,000 --> 00:05:16,000
이 부분은 char와 같습니다.

71
00:05:16,000 --> 00:05:22,000
모든 비트가 1이라면 -1을 의미합니다. 이것은 매우 중요합니다.

72
00:05:22,000 --> 00:05:26,000
int의 최솟값은 1 뒤에 0만 따라오는 것으로,

73
00:05:26,000 --> 00:05:30,000
1 뒤에 31개의 0가 있습니다.

74
00:05:30,000 --> 00:05:32,000
int의 최대값은 0 다음에 1만 따라오는 것으로,

75
00:05:32,000 --> 00:05:38,000
0 뒤에 31개의 1이 있습니다.

76
00:05:38,000 --> 00:05:40,000
지금까지는 signed형을 사용했을 때의 예시입니다.

77
00:05:40,000 --> 00:05:46,000
비트에서의 부호(signed / unsigned형)은 나중에 이야기 하겠습니다.

78
00:05:46,000 --> 00:05:51,000
정수는 소수점이 없는 값입니다.

79
00:05:51,000 --> 00:05:54,000
하지만 가끔은 소수로 무언가를 계산해야합니다.

80
00:05:54,000 --> 00:05:57,000
모든 변수 유형을 다 볼 수 있게 써보겠습니다.

81
00:05:57,000 --> 00:06:06,000
char, int. 그리고 바로 다음에 볼 float.

82
00:06:06,000 --> 00:06:12,000
그 이후에 볼 double까지.

83
00:06:12,000 --> 00:06:17,000
float는 부동 소수점 때문에 float라고 불립니다.

84
00:06:17,000 --> 00:06:23,000
그리고 이 사이즈는 4 바이트입니다.

85
00:06:23,000 --> 00:06:26,000
int와 같은 크기이지만 매우 크거나 작은 수를 만들 때 씁니다.

86
00:06:26,000 --> 00:06:31,000
여기서 정밀도라는 말이 나옵니다.

87
00:06:31,000 --> 00:06:36,000
우주의 원자 수와 같이 매우 많은 수에 대해 이야기 할 때

88
00:06:36,000 --> 00:06:40,000
10의 거듭 제곱을 표현하는 부분이 있습니다.

89
00:06:40,000 --> 00:06:45,000
그래서 32비트에는 지수부과 가수부을 나눠서 표현합니다.

90
00:06:45,000 --> 00:06:53,000
지수부는 10의 거듭 제곱을 정의합니다. 가수부는 소수점을 정의합니다. (구글링!)

91
00:06:53,000 --> 00:06:56,000
10의 150 제곱 또는 10의 100 제곱을 상상해봅시다.

92
00:06:56,000 --> 00:07:03,000
100자리 수를 쓰는 것은 분명 문제가 있습니다.

93
00:07:03,000 --> 00:07:08,000
그래서, 메모리 안에 10의 몇 제곱인지 쓸 겁니다.

94
00:07:08,000 --> 00:07:23,000
float에 대한 기본 설명, 구글링 참조.

97
00:07:23,000 --> 00:07:26,000
예시를 들어 설명하겠습니다.

98
00:07:26,000 --> 00:07:29,000
f=12.37을 쓰겠습니다.

99
00:07:29,000 --> 00:07:36,000
여기 쉼표 아닌 점을 사용했습니다.

100
00:07:36,000 --> 00:07:42,000
미국인들은 소수에 점을 사용하기 때문입니다.

101
00:07:42,000 --> 00:07:52,000
쉼표를 사용하여 천, 백만, 십억을 구분합니다.

102
00:07:52,000 --> 00:08:02,000
영어가 기본으로 사용되기에 소수를 표기할 때 점을 사용합니다.

103
00:08:02,000 --> 00:08:06,000
그래서 이것을 표시하면, 12.37을 볼 수 있습니다.

104
00:08:06,000 --> 00:08:08,000
0이 뒤에 더 붙은 채로요.

105
00:08:08,000 --> 00:08:12,000
여기서 정밀도에 대해서 이야기를 해봅시다.

106
00:08:12,000 --> 00:08:16,000
만약 제가 아주 큰 숫자를 입력한다면

107
00:08:16,000 --> 00:08:24,000
대개 int의 범위를 벗어납니다.

108
00:08:24,000 --> 00:08:28,000
이것은 int 가 가질 수 있는 값보다 큽니다.

109
00:08:28,000 --> 00:08:32,000
봅시다. 제가 틀린 것 같군요.

110
00:08:32,000 --> 00:08:36,000
하지만 좀 더 자세히 살펴보면

111
00:08:36,000 --> 00:08:42,000
여기에 출력된 값이 입력한 값이 아님을 볼 수 있습니다.

112
00:08:42,000 --> 00:08:46,000
좀 더 추가 해보면

113
00:08:46,000 --> 00:08:55,000
여기, float의 범위를 초과했네요.

114
00:08:55,000 --> 00:08:59,000
지금까지 float를 봤습니다. 이제 double을 보도록 하죠.

115
00:08:59,000 --> 00:09:05,000
최대값을 보시면 이해할 수 있을겁니다.

116
00:09:05,000 --> 00:09:08,000
기본적으로 double은 float이지만 메모리 크기는 2배입니다.

117
00:09:08,000 --> 00:09:13,000
그래서 1 double은 8바이트입니다.

118
00:09:13,000 --> 00:09:16,000
이제 여러분이 알아야 할 다른 키워드가 있습니다.

119
00:09:16,000 --> 00:09:20,000
signed, unsigned형입니다.

120
00:09:20,000 --> 00:09:25,000
char가 signed 형이거나

121
00:09:25,000 --> 00:09:30,000
혹은 unsigned형일 때를 예로 들어봅시다.

122
00:09:30,000 --> 00:09:33,000
unsigned형 일 때 0부터 255까지의 범위를 가집니다.

123
00:09:33,000 --> 00:09:37,000
signed 형일 때 -128에서 127까지의 범위를 가집니다.

124
00:09:37,000 --> 00:09:40,000
기본적으로 C는, signed형을 씁니다.

125
00:09:40,000 --> 00:09:42,000
int도 같습니다.

126
00:09:42,000 --> 00:09:49,000
기본형인 signed int와 unsigned int로 나눌 수 있습니다.

127
00:09:49,000 --> 00:09:52,000
불행히도, float 와 double에서는 적용되지 않습니다.

128
00:09:52,000 --> 00:09:59,000
그렇게 작동 되는 방식이 아니기 때문입니다.

129
00:09:59,000 --> 00:10:03,000
이제 long 키워드를 볼 겁니다.

130
00:10:03,000 --> 00:10:08,000
long은 범위를 늘리는 데 도움이 됩니다.

131
00:10:08,000 --> 00:10:10,000
예를 들어, long int

132
00:10:10,000 --> 00:10:14,000
int는 원래 4바이트였으나, long int는 8바이트입니다.

133
00:10:14,000 --> 00:10:20,000
이제 long long int 를 써봅시다.

134
00:10:20,000 --> 00:10:22,000
이건 항상 8바이트란 값을 가지고 있습니다.

135
00:10:22,000 --> 00:10:27,000
확인을 해보면, 이 시스템에서 작동하지 않는다는 메시지가 표시 됩니다.

136
00:10:27,000 --> 00:10:32,000
현재 아키텍처에서는 작동하지 않습니다.

137
00:10:32,000 --> 00:10:37,000
int는 4바이트, long int는 8바이트입니다.

138
00:10:37,000 --> 00:10:43,000
long의 반대, short입니다.

139
00:10:43,000 --> 00:10:48,000
예상되시나요? short int 는 2바이트입니다.

140
00:10:48,000 --> 00:11:01,000
그럼 short short int는? 안 됩니다.

141
00:11:01,000 --> 00:11:03,000
이건 지울게요. 이건 당신의 아키텍처에 따라 달라집니다.

142
00:11:03,000 --> 00:11:07,000
가끔은 작동해요.

143
00:11:07,000 --> 00:11:11,000
나는 이 위키피디아 페이지를 보여주고 싶습니다.

144
00:11:11,000 --> 00:11:17,000
C의 모든 기본 유형을 보여줍니다.

145
00:11:17,000 --> 00:11:21,000
기본적으로 char가 signed인 경우, -128에서 127까지 범위를 갖습니다.

146
00:11:21,000 --> 00:11:25,000
unsigned char의 경우는 0에서 255까지 범위를 가지고

147
00:11:25,000 --> 00:11:28,000
C의 모든 shorts의 범위는 같습니다.

148
00:11:28,000 --> 00:11:34,000
그들은 대략 -32,000 ~ 32,000의 값을 가집니다.

149
00:11:34,000 --> 00:11:37,000
16비트 또는 2 바이트

150
00:11:37,000 --> 00:11:41,000
unsigned short 범위는 0부터 65,000까지 가집니다.

151
00:11:41,000 --> 00:11:50,000
long을 같이 쓰면, 더 큰 값까지 도달 할 수 있습니다.

152
00:11:50,000 --> 00:11:54,000
여기에 주목할 부분이 있습니다.

153
00:11:54,000 --> 00:12:07,000
때때로, 이 값은 여러분의 아키텍처에 따라 다릅니다.

154
00:12:07,000 --> 00:12:12,000
여기서 int는 기본적으로 4바이트 입니다.

155
00:12:12,000 --> 00:12:20,000
long long int는 8바이트 입니다.

156
00:12:20,000 --> 00:12:24,000
그리고 기본적으로 128 비트인 long double이 있습니다.

157
00:12:24,000 --> 00:12:28,000
혹은 16 바이트.

158
00:12:28,000 --> 00:12:31,000
float 등은 구글링 하시길 바랍니다.

159
00:12:31,000 --> 00:12:34,000
기억하세요. 메모리는 그저 0들과 1들로 이루어져있음을요.

160
00:12:34,000 --> 00:12:40,000
그리고 컴퓨터가 어떻게 이를 읽고 사용해야하는지 입력하는 것도요.

161
00:12:40,000 --> 00:59:59,000
간단하죠 :)
<< translated by inyang, chelee, mki, yeslee and mseo :) >>
