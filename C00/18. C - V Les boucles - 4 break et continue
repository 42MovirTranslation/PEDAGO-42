1
00:00:00,159 --> 00:00:05,039
이번 비디오에서는 반복문 제어 키워드인
"break"와 "continue"를 알아보도록 하겠습니다

2
00:00:05,470 --> 00:00:10,349
이미 예전에 "switch"를 배울 때에 "break"를 본 적이 있습니다
"switch"에 내부에서 만나면 구문을 빠져나오는 데에 사용되었죠

3
00:00:10,349 --> 00:00:10,900
이것도 같은 방식으로 동작합니다

4
00:00:10,900 --> 00:00:12,580
"while" 문 도중에 "break"를 만나게 되면 반복문에서 빠져나오죠

5
00:00:12,580 --> 00:00:17,250
다른 키워드인 "continue"는 조건문으로 다시 돌아가서

6
00:00:17,830 --> 00:00:20,250
반복문을 새로 시작할 때에 사용됩니다

7
00:00:20,949 --> 00:00:22,949
백 번 듣는 것보다 한 번 보는 게 낫겠네요

8
00:00:23,470 --> 00:00:25,210
한 번 해봅시다!

9
00:00:25,210 --> 00:00:27,210
여기에

10
00:00:27,279 --> 00:00:29,549
변수 "i"를 선언하고 0을 할당했습니다
만약에 i가 10보다 작다면

11
00:00:29,650 --> 00:00:34,709
"i"의 값을 출력할 거예요, 반복문이 끝나면
"I am out"을 출력하도록 하겠습니다

12
00:00:35,290 --> 00:00:38,129
예상한 대로 결과가 잘 나왔죠! 이제 여기에다가

13
00:00:39,010 --> 00:00:41,820
"break"를 넣겠습니다, 어떤 일이 일어날까요?

14
00:00:43,090 --> 00:00:45,090
"break"

15
00:00:45,550 --> 00:00:47,550
어떻게 될까요…

16
00:00:48,309 --> 00:00:51,059
"i"가 0일 때 어떤 일이 일어날까요?

17
00:00:51,940 --> 00:00:53,940
0은 10보다 더 작으니 반복문에 들어가게 됩니다

18
00:00:54,250 --> 00:00:58,079
"i"의 값을 출력하고 나서 "break"를 만나므로
곧바로 반복문을 빠져나오게 됩니다

19
00:00:58,210 --> 00:01:01,230
반복문은 한 번 돌았을 뿐인데, 여기로 곧장 오게 되는 것이죠

20
00:01:02,350 --> 00:01:07,739
이게 바로 "break"가 동작하는 방식입니다
제가 말한 '반복문을 빠져나온다'는 게 이런 거죠, 만약 반복문이 중첩되는 경우에는…

21
00:01:09,040 --> 00:01:11,040
아직 언급은 안 했지만…

22
00:01:11,140 --> 00:01:16,769
뭐, 물론 반복문을 중첩할 수 있습니다
"if"를 겹겹이 짤 수 있었던 것처럼 말이죠

23
00:01:17,140 --> 00:01:19,090
이미 해보셨으리라 생각합니다

24
00:01:19,090 --> 00:01:21,090
만약 반복문이 중첩되어 있고

25
00:01:22,330 --> 00:01:25,739
이 반복문에서 "break"를 넣어주면…

26
00:01:29,710 --> 00:01:33,809
아, 일단은 "break" 없이 한 번 실행해보는 것이 좋겠군요
그리고 여기에

27
00:01:36,250 --> 00:01:38,250
변수 "j"의 값을 출력하도록 하겠습니다

28
00:01:39,510 --> 00:01:41,510
따단!

29
00:01:42,370 --> 00:01:44,579
"j"의 값이 다 증가하고 나서

30
00:01:45,280 --> 00:01:47,260
"i"가 증가하는 반복문을 만들었습니다

31
00:01:47,260 --> 00:01:48,640
완벽하죠!

32
00:01:48,640 --> 00:01:52,320
반복문을 완성했으니 여기 중간에 "break"를 넣으면

33
00:01:53,650 --> 00:01:58,980
어떤 일이 일어날까요? 세미콜론을 빼먹었군요…

34
00:01:59,770 --> 00:02:02,339
짠! 좋아요, 무슨 일이 일어날까요?

35
00:02:03,040 --> 00:02:07,889
"i"의 값이 0인가요? 맞아요! "j"의 값은 0인가요? 그렇죠!
0은 10보다 작나요? 그렇네요!

36
00:02:08,320 --> 00:02:13,049
따라서 "0 0"이 출력되고 "break"를 만났으므로
여기서 반복문에서 나가게 됩니다

37
00:02:14,020 --> 00:02:19,469
이 반복문에서 빠져나온 뒤 "i"가 증가하게 됩니다 
따라서 "i"는 1이 되고, "i"는 10보다 작고 "j"도 10보다 작죠

38
00:02:19,660 --> 00:02:21,520
별다른 문제 없네요, 따라서 "1 0"이 출력됩니다

39
00:02:21,520 --> 00:02:24,990
그리고 이것이 반복됩니다, 우리가 모든 숫자를 출력하는 이유죠

40
00:02:25,600 --> 00:02:30,779
여기에 도달하면 출력값의 왼쪽에는 증가하고 있는 "i"의 값이 표시되고

41
00:02:30,780 --> 00:02:31,959
오른쪽에는 항상 0인 "j" 값이 표시되죠

42
00:02:31,959 --> 00:02:36,449
이것이 "break"가 동작하는 방식입니다!
이번에는 "continue"가 동작하는 방식을 설명해 드리고자 해요

43
00:02:37,840 --> 00:02:45,899
"break"와 다르게, "continue"를 만나면 루프의 맨 위로 되돌아옵니다

44
00:02:43,390 --> 00:02:45,899
다음 루프를 시작하기 위해서 말이죠

45
00:02:46,840 --> 00:02:48,160
욥!

46
00:02:48,160 --> 00:02:50,160
한번 볼까요!

47
00:02:52,750 --> 00:02:59,100
printf를 조금 수정하고 여기에 "continue"를 추가해볼게요…
그리고 컴파일하면 이렇게 됩니다

48
00:03:02,140 --> 00:03:05,309
아, "j"를 선언해 놓고 사용하지를 않았군요

49
00:03:06,910 --> 00:03:11,219
다시 컴파일하고 실행하면 0이 반복되어 출력됩니다
꽤 많이 출력되네요

50
00:03:12,100 --> 00:03:17,429
왜일까요? "i"는 0이고, "i"는 10보다 작은가요? 그렇죠!
그럼 우선 반복문에 진입합니다

51
00:03:18,100 --> 00:03:23,189
여기서 i의 값인 "0"을 출력하고 "continue"를 만납니다
말씀드렸듯 "continue"를 만나면 반복문의 처음으로 되돌아갑니다

52
00:03:23,190 --> 00:03:27,690
그렇기 때문에 "i++"가 실행되지 않습니다
다시 "i"가 10보다 작은지 체크하고, 0을 출력하고, "continue"를 만나죠

53
00:03:28,209 --> 00:03:30,719
0은 10보다 작으니 두 번째 0이 출력되고, "continue"를 만나고, 등등

54
00:03:32,080 --> 00:03:34,080
이것이 "continue"가 동작하는 방식입니다!

55
00:03:34,420 --> 00:03:39,839
"continue"의 작은 특성은 '반복문의 처음으로 되돌아가게 해주는 것' 이라 했죠

56
00:03:40,900 --> 00:03:42,900
그럼 만약에 "for" 반복문 내부에서 사용하면 어떨까요…

57
00:03:44,380 --> 00:03:51,209
나머지는 똑같이 적어주되 이 부분만 "for" 구문으로 수정하고…
무슨 일이 일어나나 봅시다

58
00:03:55,840 --> 00:03:57,550
좋아요!

59
00:03:57,550 --> 00:04:00,899
사실 "for" 반복문 내부에서 "continue"를 사용하면 변수의 증감은 이루어집니다

60
00:04:02,079 --> 00:04:08,519
스코프 내에서 "continue"로 인해 무시되는 부분이 어딘지 알아봅시다
만약 printf를 이용해서 여기에 "NEVER EVER"를 출력하면

61
00:04:10,209 --> 00:04:12,209
가독성을 위해 \n을 추가할게요

62
00:04:13,329 --> 00:04:15,329
이 부분은 절대로 출력되지 않네요…

63
00:04:15,789 --> 00:04:20,969
"continue"를 만나면 "for" 루프의 처음으로 돌아가며
여기선 이 i++ 연산을

64
00:04:21,100 --> 00:04:25,829
반드시 해야 한다는 것을 코드가 알고 있어서
"while" 루프와 달리 i의 증감이 이루어지고 있죠

65
00:04:26,650 --> 00:04:31,679
이게 다예요! 지금까지 우리는 반복문을 탈출할 수 있도록 하는
"break" 키워드와

66
00:04:32,410 --> 00:04:38,189
반복문의 조건부로 돌아갈 수 있게 하는 "continue" 키워드를 만나봤어요
<< translated by inyang, chelee, mki, yeslee, mseo and ji-kim:) >>