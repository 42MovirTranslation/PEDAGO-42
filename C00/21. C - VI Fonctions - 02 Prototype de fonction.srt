1
00:00:02,360 --> 00:00:05,089
박수~~~

2
00:00:05,089 --> 00:00:07,620
이번 영상에서는 함수의 프로토타입

3
00:00:07,620 --> 00:00:08,880
개념을 설명합니다.

4
00:00:08,880 --> 00:00:11,309
자, fct라고 부르는 함수를

5
00:00:11,309 --> 00:00:13,980
이전에 미리 만들어놨습니다.

6
00:00:13,980 --> 00:00:15,509
함수의 프로토타입이란 무엇일까요?

7
00:00:15,509 --> 00:00:17,430
프로토타입은 간단히

8
00:00:17,430 --> 00:00:18,900
프로그램에게 함수의 존재를

9
00:00:18,900 --> 00:00:20,939
알려줍니다.

10
00:00:20,939 --> 00:00:23,010
여러분도 알다시피

11
00:00:23,010 --> 00:00:24,990
C언어에서는 모든것이 순서대로 읽혀집니다.

12
00:00:24,990 --> 00:00:26,480
그말은 즉, 이 fct함수를

13
00:00:26,480 --> 00:00:31,679
main 아래로 옮기고,

14
00:00:31,679 --> 00:00:33,329
(흠. 좀 더 깨끗하군요)

15
00:00:33,329 --> 00:00:36,149
이 코드를 컴파일하면

16
00:00:36,149 --> 00:00:38,070
어떻게 될까요?

17
00:00:38,070 --> 00:00:40,170
컴파일러가 오류를 뱉어냅니다.

18
00:00:40,170 --> 00:00:42,059
“implicit declaration of function fct”

19
00:00:42,059 --> 00:00:43,440
사실, 컴파일러는 fct가 뭔지 모릅니다.

20
00:00:43,440 --> 00:00:45,450
C가 절차지향 언어이고,

21
00:00:45,450 --> 00:00:47,070
fct는 위가 아니라 아래에 선언되어서

22
00:00:47,070 --> 00:00:49,320
컴파일러는 fct를 알지 못합니다.

23
00:00:49,320 --> 00:00:50,820
해결책은 바로

24
00:00:50,820 --> 00:00:53,219
함수의 프로토타입을 만드는 것입니다.

25
00:00:53,219 --> 00:00:54,030
그래서 프로토타입은, 대략, 함수를

26
00:00:54,030 --> 00:00:56,910
프로그램 시작 부분에 정의하는 것이며

27
00:00:56,910 --> 00:00:58,170
프로그램에게 말해줍니다:

28
00:00:58,170 --> 00:01:00,059
“이런 함수가 있어"

29
00:01:00,059 --> 00:01:02,670
그러면 그 함수를 호출할 수 있습니다.

30
00:01:02,670 --> 00:01:04,619
자, 프로토타입은 매우 간단합니다.

31
00:01:04,619 --> 00:01:07,110
return값을 적어주고,

32
00:01:07,110 --> 00:01:10,830
그 다음에 정의될 함수의

33
00:01:10,830 --> 00:01:12,420
이름과 인자를 main함수 위에 적어줍니다.

34
00:01:12,420 --> 00:01:14,310
자, 프로토타입과

35
00:01:14,310 --> 00:01:15,869
함수의 정의 첫 번째 줄과의

36
00:01:15,869 --> 00:01:17,460
단 하나의 차이점은,

37
00:01:17,460 --> 00:01:19,380
프로토타입의 마지막에

38
00:01:19,380 --> 00:01:20,009
세미콜론을

39
00:01:20,009 --> 00:01:23,909
붙여주고, 스코프를 선언하지 않는 것입니다.

40
00:01:23,909 --> 00:01:26,850
일단 프로토타입을 선언하면

41
00:01:26,850 --> 00:01:30,119
fct 함수를 사용할 수 있고

42
00:01:30,119 --> 00:01:32,900
잘 동작합니다.

43
00:01:33,119 --> 00:01:34,350
프로토타입은

44
00:01:34,350 --> 00:01:36,799
함수를 선언하는 것이고,

45
00:01:36,799 --> 00:01:38,790
함수가 어디에 있든

46
00:01:38,790 --> 00:01:40,170
컴파일러가 그 함수를 찾을 수 있도록 해줍니다.

47
00:01:40,170 --> 00:01:41,310
심지어 그 함수가

48
00:01:41,310 --> 00:01:43,409
선언되어 있지 않을때도 말이죠.

49
00:01:43,409 --> 00:01:44,880
다른 걸 상상해보죠.

50
00:01:44,880 --> 00:01:46,710
두 번째 파일을

51
00:01:46,710 --> 00:01:51,110
만들어 그걸 fct.c라고 부르고

52
00:01:51,110 --> 00:01:55,770
그 안에 함수를 정의합시다.

53
00:01:55,770 --> 00:01:58,320
우선, printf를 사용할 수 있게 하는

54
00:01:58,320 --> 00:02:01,740
라이브러리를 추가합니다.

55
00:02:01,740 --> 00:02:03,119
stdio라고 불리는 라이브러리입니다.

56
00:02:03,119 --> 00:02:04,469
나중에 include가 어떻게

57
00:02:04,469 --> 00:02:05,820
동작하는지 볼 겁니다.

58
00:02:05,820 --> 00:02:07,200
지금 알아야 할 것은

59
00:02:07,200 --> 00:02:08,788
이 include가

60
00:02:08,788 --> 00:02:09,960
printf의 프로토타입을

61
00:02:09,960 --> 00:02:11,850
선언한다는 것입니다.

62
00:02:11,850 --> 00:02:13,860
그래서 우리는 printf를 사용할 수 있습니다.

63
00:02:13,860 --> 00:02:16,350
왜냐하면, 컴파일러가 printf는 stdio.h에 선언되어있다는 것을 알기 때문이에요.

64
00:02:16,350 --> 00:02:17,760
만약 include를 하지 않으면, 컴파일러는 printf를 알 수 없고,

65
00:02:17,760 --> 00:02:20,610
컴파일 문제가 발생할겁니다.

66
00:02:20,610 --> 00:02:22,680
자 fct를 선언해볼까요?

67
00:02:22,680 --> 00:02:25,680
아무 인자도 없고,

68
00:02:25,680 --> 00:02:30,900
아무것도 return하지 않으며

69
00:02:30,900 --> 00:02:41,100
"Coucou 42"만 출력합니다.

70
00:02:41,100 --> 00:02:43,650
여기 이 함수를 지워용.

71
00:02:43,650 --> 00:02:47,810
main 밑의 함수는 있든말든 상관없습니다.

72
00:02:49,790 --> 00:02:52,590
해당 위치로 이동해

73
00:02:52,590 --> 00:02:54,780
fct.c 없이 컴파일하면, 

74
00:02:54,780 --> 00:02:57,360
컴파일러가 뭐라 말할겁니다.

75
00:02:57,360 --> 00:02:58,680
자, 컴파일러가 에러를 뱉었군요

76
00:02:58,680 --> 00:03:00,870
"undefined symbol for architecture etc etc"

77
00:03:00,870 --> 00:03:03,210
"_fct referenced from main "

78
00:03:03,210 --> 00:03:06,000
즉, fct 함수를 찾을 수 없다는 이야깁니다.

79
00:03:06,000 --> 00:03:06,990
컴파일러가 말하고 싶은 것은 이런 겁니다.

80
00:03:06,990 --> 00:03:08,640
“fct의 프로토타입이 선언되었고,

81
00:03:08,640 --> 00:03:11,100
네가 fct를 여기에 호출했는데,

82
00:03:11,100 --> 00:03:14,130
난 fct를 찾을 수 없었다구(ㅠㅠ).

83
00:03:14,130 --> 00:03:15,300
fct를 어떻게 불러야 하는지 모르겠어"

84
00:03:15,300 --> 00:03:19,200
그럼 여기에

85
00:03:19,200 --> 00:03:20,730
여러 개의 파일들을 컴파일하도록

86
00:03:20,730 --> 00:03:22,830
함수가 들어 있는 fct.c를

87
00:03:22,830 --> 00:03:24,300
추가한 뒤에,

88
00:03:24,300 --> 00:03:26,310
컴파일하면… 짜잔~

89
00:03:26,310 --> 00:03:30,030
잘 동작합니다.

90
00:03:30,030 --> 00:03:31,410
자, 함수의 프로토타입에 대해 이해하는 것이

91
00:03:31,410 --> 00:03:35,250
매우 중요합니다. 만약

92
00:03:35,250 --> 00:03:36,780
프로토타입을 지우면

93
00:03:36,780 --> 00:03:39,360
무슨 일이 일어날까요?

94
00:03:39,360 --> 00:03:42,260
동작하지 않습니다. 왜냐하면 컴파일러는 fct를 모르기 때문입니다.

95
00:03:42,260 --> 00:03:46,170
그래서 프로토타입을 정의하고

96
00:03:46,170 --> 00:03:47,820
파일을 추가해야 합니다. 둘 다

97
00:03:47,820 --> 00:03:49,230
정말 매우 중요합니다.

98
00:03:49,230 --> 00:03:51,570
함수가 컴파일되어야 하고,

99
00:03:51,570 --> 00:03:53,370
main에서 찾을 수 있어야 합니다. 그러므로

100
00:03:53,370 --> 00:03:55,170
프로토타입과 파일이 둘 다 있어야

101
00:03:55,170 --> 00:03:57,290
모든게 잘 돌아갑니다.

102
00:03:57,290 --> 00:04:00,110
코드를 쪼개기 위해서는

103
00:04:00,110 --> 00:04:02,970
함수를 정의한 프로토타입이

104
00:04:02,970 --> 00:04:05,250
필수적입니다.

105
00:04:05,250 --> 00:04:07,140
제말은 즉, 천 몇 줄 안에 모든 것이 들어있는

106
00:04:07,140 --> 00:04:08,940
파일 하나가 아니라

107
00:04:08,940 --> 00:04:10,530
여러 개의 파일로 쪼개라는 것입니다.

108
00:04:10,530 --> 00:04:12,840
함수의 프로토타입에 대한 영상이었습니다.

109
00:04:12,840 --> 00:04:15,170
감사합니다.

translated by ji-kim, inyang, chelee, mki, yeslee and mseo :)