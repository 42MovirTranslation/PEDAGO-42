1
00:00:05,109 --> 00:00:08,300
이번 영상에서는, ‘static’ 키워드에 대해 말씀드리겠습니다.

2
00:00:08,300 --> 00:00:12,019
어떤 용도로 사용할까요? 여러 가지가 있습니다.

3
00:00:12,019 --> 00:00:16,309
먼저, static 키워드는 함수와 변수 모두에 적용할 수 있는 키워드로,

4
00:00:16,309 --> 00:00:22,100
함수와 변수의 전역적인 접근 범위(스코프)를 제한할 수 있습니다.

5
00:00:22,100 --> 00:00:25,369
이게 구체적으로 무슨 의미일까요?

6
00:00:25,369 --> 00:00:29,000
간단한 예시를 통해 바로 알아봅시다.

7
00:00:29,000 --> 00:00:31,329
먼저, 여기

8
00:00:31,329 --> 00:00:34,460
fct 함수와 fct2 함수를 호출하는

9
00:00:34,460 --> 00:00:37,460
간단한 main 함수가 있습니다.

10
00:00:37,460 --> 00:00:40,700
두 함수는 fct.c 파일에 정의되어 있죠.

11
00:00:40,700 --> 00:00:50,030
그래서 컴파일을 해보면, 문제없이 잘 됩니다.

12
00:00:50,030 --> 00:00:54,410
하지만 이제 우리가 살펴볼 것은, 여기에

13
00:00:54,410 --> 00:00:57,590
‘static’ 키워드를 붙여서, fct2 함수가 갑자기

14
00:00:57,590 --> 00:01:00,460
static 함수가 되는 경우입니다.

15
00:01:00,460 --> 00:01:03,739
그럼 제가 컴파일을 했을 때 에러가 발생하죠.

16
00:01:03,739 --> 00:01:06,170 
링크 에러가 발생했습니다.

17
00:01:06,170 --> 00:01:11,899
링킹을 할 때, fct2 함수를 발견하지 못했다는군요. 왜일까요?

18
00:01:11,899 --> 00:01:15,469
단순히 static 키워드를 fct2 함수 앞에 더함으로써

19
00:01:15,469 --> 00:01:27,979
링킹 시에 호출될 수 있고, 외부로부터 접근 가능한 함수 목록에서 그 함수를 지웠기 때문입니다.

20
00:01:27,979 --> 00:01:31,909
이 파일들은 각각 컴파일할 때 문제가 없습니다

21
00:01:31,909 --> 00:01:33,919
만약 이 .c 파일을 .o 파일로 컴파일한다면,

22
00:01:33,919 --> 00:01:35,659
문제없이 컴파일될 겁니다.

23
00:01:35,659 --> 00:01:39,380
여기 fct2는 인식이 잘 되죠, 하지만

24
00:01:39,380 --> 00:01:43,520
다른 파일들과 링킹을 해야 할 때,

25
00:01:43,520 --> 00:01:45,560
바깥에서는 fct2 함수와 연결이 되지 않습니다.

26
00:01:45,560 --> 00:01:50,599
왜냐하면 접근 범위가 오직 이 파일 안으로 한정되었기 때문이죠.

27
00:01:50,599 --> 00:01:53,109
무엇에 쓰일까요?

28
00:01:53,109 --> 00:01:56,780
간단하게 말하면, 여러분이 매우 많은 파일에 여러 코드를 작성하고,

29
00:01:56,780 --> 00:02:00,470
이름이 꽤 비슷한 함수도 많이 생겨서

30
00:02:00,470 --> 00:02:03,020
어느 지점에서 중복이 발생한다면,

31
00:02:03,020 --> 00:02:07,490
함수를 재정의할 위험하게 되고, 그건 문제가 될 수 있죠.

32
00:02:07,490 --> 00:02:10,069
반면에 키워드 ‘static’을 추가함으로써,

33
00:02:10,069 --> 00:02:14,810
이 함수는 오직 이 파일에서만 사용할 거야, 라고 정할 수 있습니다.

34
00:02:14,810 --> 00:02:18,350
그래서 심지어 이름이 같은 함수가 있는 지점에서도

35
00:02:18,350 --> 00:02:22,880
함수를 재정의하는 위험을 감수하지 않아도 됩니다.

36
00:02:19,610 --> 00:02:22,880
꽤 괜찮죠.

37
00:02:22,880 --> 00:02:25,610
지금까지는 함수에 쓰이는 경우를 알아봤습니다.

38
00:02:25,610 --> 00:02:30,410
‘static’이 변수에도 적용될 수 있다는 걸 알아보겠어요.

39
00:02:30,410 --> 00:02:36,800
그래서, 또 다른 예시를 들어보죠.

40
00:02:36,800 --> 00:02:40,580
그래서 ‘static’ 키워드를 변수에 사용할 때의 주요 쓰임새는

41
00:02:40,580 --> 00:02:45,709
다음과 같습니다:

42
00:02:45,709 --> 00:02:50,600
여기 fct2 함수에 static 변수를 선언하겠습니다.

43
00:02:50,600 --> 00:02:53,930 
int형 변수를 ‘static’으로 선언하고

44
00:02:53,930 --> 00:02:58,459
값을 줘보죠: 0으로 초기화하겠습니다.

45
00:02:58,459 --> 00:03:02,900
그리고 함수에서 단순히 그 값을 증가시키고,

46
00:03:02,900 --> 00:03:13,720
값을 출력하겠습니다.

47
00:03:13,720 --> 00:03:19,650
(printf 때문에) include를 하는 게 낫겠군요.

48
00:03:19,650 --> 00:03:32,050
그래서, 이걸 컴파일하면 - fct는 더 필요가 없군요 -

49
00:03:32,050 --> 00:03:37,330
컴파일하고, 실행하면, 1이 출력됩니다.

50
00:03:37,330 --> 00:03:40,420
논리적으로 보이고, 문제없죠.

51
00:03:40,420 --> 00:03:49,180
하지만 fct2를 여러 번 호출하려고 하면,

52
00:03:49,180 --> 00:03:55,540
여러분은 특이하게 동작하는 것을 보게 될 겁니다:

53
00:03:55,540 --> 00:03:58,900
1 2 3 4 5 6 이 출력되었네요. 그래서 무슨 일이 일어난 거죠?

54
00:03:58,900 --> 00:04:03,340
사실은, ‘static’을 여기 int형 변수 앞에 더함으로써,

55
00:04:03,340 --> 00:04:06,239
이 변수가 일종의 전역 변수가 된 것입니다.

56
00:04:06,239 --> 00:04:11,440
전역 변수는 오직 한 번만 정의되고

57
00:04:09,280 --> 00:04:15,730
실행하는 내내 호출할 때마다 항상 같은 상태로 남아있죠.

58
00:04:15,730 --> 00:04:19,810
그러나 이 변수는 오직 선언된 범위에서만 접근할 수 있습니다.

59
00:04:19,810 --> 00:04:23,710
그래서 여기, fct2의 범위겠죠.

60
00:04:23,710 --> 00:04:25,840
예를 들어서 a를 fct 함수에서 호출하려고 해도,

61
00:04:25,840 --> 00:04:27,850
동작하지 않습니다.

62
00:04:27,850 --> 00:04:31,330
fct 함수는 이 변수 a를 모를 겁니다.

63
00:04:31,330 --> 00:04:35,500
테스트를 만들어봅시다. 그냥 여러분한테 보여드리기 위해서요.

64
00:04:35,500 --> 00:04:44,729
인위적으로 fct2 함수 내부에 스코프를 만들어서 변수 a를 고립시키겠습니다.

65
00:04:44,729 --> 00:04:49,470
거기에, 변수 a를 변화시키기로 하고,

66
00:04:49,740 --> 00:04:58,410
(++에서 --로 바꿈) 컴파일해보면,

67
00:04:58,680 --> 00:05:01,900
변수 a를 찾지 못했다고 하죠.

68
00:05:01,900 --> 00:05:05,860
변수 a를 모르고 있습니다.

69
00:05:05,860 --> 00:05:10,169
왜냐하면 이 변수는 오직 여기 이 범위에서만 정의되었기 때문입니다.

70
00:05:10,169 --> 00:05:14,289
그래서 이 범위의 바깥에서는 변수 a에 접근할 수 없을 겁니다.

71
00:05:14,289 --> 00:05:16,780
반면에, 범위 안에서는 보시는 것처럼 문제가 없죠.

72
00:05:16,780 --> 00:05:21,070
아무런 문제 없이 변수 a를 사용할 수 있습니다.

73
00:05:21,070 --> 00:05:26,470
제 파일에도 마찬가지로,

74
00:05:26,470 --> 00:05:35,630
a의 선언을 여기에 둔다면,

75
00:05:35,630 --> 00:05:39,770
a의 범위는 이 파일의 범위가 되겠죠. 간단합니다.

76
00:05:39,770 --> 00:05:44,060
그래서 예를 들어

77
00:05:41,540 --> 00:05:47,300
여기 보이는 것처럼

78
00:05:44,060 --> 00:05:47,300
또 다른 int형 변수 a를 재정의하고,

79
00:05:47,300 --> 00:05:50,220
그 값을 12라고 한다면,

80
00:05:50,220 --> 00:05:54,920
여러 번 정의해도 문제없습니다.

81
00:05:54,920 --> 00:06:01,640
걱정할 필요 없어요.

82
00:06:01,640 --> 00:06:03,210
이렇게 해놓고,

83
00:06:03,210 --> 00:06:12,340
같은 것을 여기서 해봅시다. 그리고 컴파일해볼게요.

84
00:06:12,370 --> 00:06:15,380 
문제없이 컴파일되었죠

85
00:06:15,380 --> 00:06:18,920
반면에 제가 이 변수를 static이 아니라고 하면,

86
00:06:18,920 --> 00:06:22,160
여러번 정의된 기호가 있다는 문제가 생길 겁니다.

87
00:06:22,160 --> 00:06:25,970
중복 정의하는 실수를 했죠.

88
00:06:25,970 --> 00:06:28,910
이런 번 주로 쓰이는 방식은 아닙니다.

89
00:06:28,910 --> 00:06:33,470
이렇게 함수 범위 밖에서 글로벌 static 변수를 사용하는 건 약간 위험해요.

90
00:06:33,470 --> 00:06:36,770
하지만 함수 범위 안에서

91
00:06:36,770 --> 00:06:39,380
static 변수를 어떻게 활용할지는 여러분이 꽤 잘 알 거라고 생각합니다.

92
00:06:39,380 --> 00:06:45,170
오늘의 결론,

93
00:06:45,170 --> 00:06:50,510
‘static’ 키워드는 변수나 함수의 접근 범위를 제한하는 데 정말 도움이 됩니다.

94
00:06:50,510 --> 00:06:52,550
그리고 ‘static’ 키워드는 함수만을 위해 사용될 수도 있고,

95
00:06:52,550 --> 00:06:55,660
Global 한 변수를 위해 사용될 수도 있습니다.
<< translated by inyang, chelee, mki, yeslee, mseo and ji-kim :) >>
