1
00:00:00,000 --> 00:00:02,700
이 비디오에서는 정적 배열에 대해 알아보겠습니다.

2
00:00:03,160 --> 00:00:08,000
지금까지는 변수를 선언할 때  int, char, float 변수들을 각각 선언하고, 두 번째 변수를 원할 때는

3
00:00:08,000 --> 00:00:10,300
두 번째 int, 두 번째 char, 두 번째 float 변수 등등을 또 선언해야만 했습니다.

4
00:00:10,809 --> 00:00:13,289
문제는 50개의 변수를 선언해야할 때입니다.

5
00:00:13,630 --> 00:00:17,200
함수에 int a, int b, int c, int d...를 적고, 각각 이름을 정해준 뒤,

6
00:00:17,200 --> 00:00:20,939
그 이름들을 기억하는 건 불편할 겁니다.

7
00:00:21,220 --> 00:00:26,460
그리고 무엇보다도, 중간에 있는 하나의 값을 찾기 위해 50개의 변수들을 반복해서 확인해야 한다고 상상해보세요.

8
00:00:26,650 --> 00:00:28,650
정말로 복잡해질 겁니다.

9
00:00:28,869 --> 00:00:37,950
이것이 배열이라는 도구를 사용하는 이유입니다. 배열은 변수 유형에 따른 연속된 메모리 공간입니다.

11
00:00:38,410 --> 00:00:42,299
보다 확실히 설명하기 위해 예시를 하나 들어보겠습니다.

12
00:00:43,840 --> 00:00:46,200
저는 여기 int ‘a’를 선언했습니다.

13
00:00:46,400 --> 00:00:49,300
‘a’에는 12라는 값을 주었고 출력했습니다.

14
00:00:49,300 --> 00:00:51,500
어떤 결과일지 확인해볼까요.

15
00:00:51,510 --> 00:00:52,539
짠

16
00:00:52,539 --> 00:00:54,539
이제 더 많은 int를 한 번에 선언하고자 합니다.

17
00:00:54,670 --> 00:01:01,379
그러기 위해서는 특별한 표기법인 ‘[‘를 사용해야만 합니다.

18
00:01:01,960 --> 00:01:03,960
combien vous en voulez
그대들이 원하는 만큼 쓰고

19
00:01:04,750 --> 00:01:07,709
‘]’로 닫아주세요. 이 말은 즉,


20
00:01:08,500 --> 00:01:10,589
‘a’는 int형 배열이라는 뜻입니다.

21
00:01:11,650 --> 00:01:14,010
[ ] 안에는 10이 들어있습니다.

22
00:01:15,100 --> 00:01:17,549
이제 여기, a = 12를 쓰는 건 더 이상 의미가 없습니다.

23
00:01:18,880 --> 00:01:24,839
왜냐하면 ‘a’는 int가 아니라, int의 배열이기 때문입니다. 

24
00:01:25,750 --> 00:01:29,099
보시면 이렇게 문제가 있음을 볼 수 있습니다. 

25
00:01:29,560 --> 00:01:32,250
‘a’가 “배열형” 이라는군요. 배열은 표라는 뜻입니다.

26
00:01:32,409 --> 00:01:45,200
(부연설명 중)

29
00:01:45,300 --> 00:01:47,200
컴파일러가 제 실수를 찾았군요.

30
00:01:47,990 --> 00:01:51,249
이제 어떻게 해야 할까요? 여기 10을 넣어줬습니다.

31
00:01:51,560 --> 00:01:54,400
나란히 정렬된 정수형 변수들에는 아직 할당된 값이 없습니다.

32
00:01:54,400 --> 00:01:59,800
‘a’는 서로 붙어있는 int형 변수 10개의 모임입니다.

33
00:01:59,900 --> 00:02:01,700
이 10개의 int형에 접근하기 위해

34
00:02:01,700 --> 00:02:03,380
인덱스를 사용할 겁니다.

35
00:02:03,380 --> 00:02:08,800
여기, 동일한 표기법을 한 번 더 사용하겠습니다.

36
00:02:09,039 --> 00:02:11,640
[0]을 써볼게요.

37
00:02:12,490 --> 00:02:20,409
a[0]라고 적었을 때, 이건 10개의 정수들 중 첫 번째 정수를 의미합니다. 그러니 0은 a에서 첫 번째 정수입니다.

38
00:02:21,100 --> 00:02:26,500
왜 0일까요? 그건 나중에 보게 될, 포인터를 다룬 비디오에서 알게 될 겁니다. 

39
00:02:26,600 --> 00:02:30,549
첫 번째 인자가 1이 아닌 0인 데에는 논리적인 이유가 있습니다.

40
00:02:31,100 --> 00:02:32,570
주소와 메모리의 문제입니다. 

41
00:02:32,570 --> 00:02:37,329
첫 번째 주소로 갔을 때, 그건 출발점이 됩니다.


42
00:02:37,330 --> 00:02:39,880
그 출발점은 +0이고, 포인터를 배울 때 더 알게 될 거예요.

43
00:02:40,750 --> 00:02:45,550
지금은 배열의 첫 번째 인자가 1이 아닌 0이라는 것만 기억하세요.

44
00:02:45,800 --> 00:02:48,700
이걸 이해한 순간부터 많은 게 바뀔 겁니다.

45
00:02:48,860 --> 00:02:53,050
만약 첫 번째 인자가 0이었다면, 10개 배열의 마지막 인자는...

46
00:02:55,010 --> 00:02:57,900
9죠, 맞습니다. 10이 아니에요.

47
00:02:58,070 --> 00:03:04,200
마지막 인자가 9라는 것은, 만약 a[10] = 15라고 적었을 때

48
00:03:04,480 --> 00:03:06,480
문제가 생긴다는 뜻입니다.

49
00:03:06,820 --> 00:03:10,800
그래서… 이렇게 한다면, 오류가 나죠.

50
00:03:11,780 --> 00:03:16,660
상황이 좀 낫군요. 다행히도 컴파일러는 배열의 크기를 알고 있습니다.

51
00:03:17,150 --> 00:03:22,420
배열에는 10개의 정수들이 있는데, 지금은 11번째 정수를 가리키려고 했군요.

52
00:03:23,849 --> 00:03:30,649
여기가 문제입니다. 여기에 넣을 수 있는 가장 큰 수는 9 입니다

53
00:03:32,600 --> 00:03:39,600
자, 이제 우리는 배열에서 a[1], a[2], a[3]을 사용할 수 있게 되었군요.

54
00:03:40,200 --> 00:03:44,400
할당된 값은 다른 인덱스로 복사해 넣을 수 있습니다.

55
00:03:44,580 --> 00:03:46,820
예를 들어, a[3] = a[0]라고 적으면

56
00:03:47,129 --> 00:03:52,608
출력이 가능해요. 여기서 알아야할 것은 a[어떤 수]입니다.

57
00:03:52,890 --> 00:03:57,979
‘a’는 아주 단순한 int형 배열입니다.

00:03:58,500 --> 00:04:03,500
그건 a[어떤 수]는 int이니, a[0]도 a[3]도 int라는 뜻입니다. 

60
00:04:03,700 --> 00:04:08,200
그래서 int와 같은 방식으로 여기 %d '\n'를 사용하는 것이 가능합니다. 

61
00:04:08,500 --> 00:04:13,669
보시다시피 ‘a’만 넣을 수는 없고, a[3]를 넣을 수 있습니다.

62
00:04:14,040 --> 00:04:16,040
a[0]는 12이고,

63
00:04:16,048 --> 00:04:20,688
a[3]의 값은 a[0]와 같으니, a[0]의 값이 a[3]으로 복사됩니다.

64
00:04:21,600 --> 00:04:26,929
출력하면 12가 나옵니다. 잘 복사되었군요.

65
00:04:27,930 --> 00:04:29,930
재밌는 게 하나 있어요.

66
00:04:30,810 --> 00:04:33,619
배열의 크기를 더 늘릴 수 있습니다.

67
00:04:34,949 --> 00:04:41,720
예를 들어 [10][10]이라면, 이런 식으로 쭉 적고, 

69
00:04:44,600 --> 00:04:59,640
여기는 a[3][6]으로, 여기는 a[0][3]으로 바꿔봅시다.

72
00:05:01,080 --> 00:05:02,759
보세요

73
00:05:02,759 --> 00:05:07,068
이전과 같은 방식으로 출력해도 문제 없습니다. 이중배열이 만들어졌습니다.

74
00:05:07,169 --> 00:05:11,800
10 * 10 개의 정수를 연속된 메모리 안에 넣어줬습니다. 100개의 정수를 할당할 수 있겠군요.

75
00:05:11,840 --> 00:05:14,400
이중배열에 값을 할당하려고 할 때,

76
00:05:14,480 --> 00:05:18,540
a[0] 줄에서 a[0][3]에 할당하기를 원한다면,

77
00:05:19,200 --> 00:05:24,859
첫 번째 줄, 네 번째 칸이라고 생각할 수 있습니다. 이중배열로 작업할 때는 이렇게 할 수 있습니다.

78
00:05:24,860 --> 00:05:28,490
삼중, 사중, n중 배열도 가능합니다.

79
00:05:28,590 --> 00:05:30,859
얼마나 흥미로운 개념인가요.

80
00:05:31,110 --> 00:05:36,800
예를 들어, 다차원 공간에서 점들을 이용해 해결할 문제가 있거나, 데이터를 이용해 그리드를 채워야할 때,

81
00:05:36,800 --> 00:05:40,789
다차원 공간이 주어졌을 때, 다중 배열을 사용할 수 있습니다.

82
00:05:41,520 --> 00:05:46,099
방금 동적 배열에서 ‘int’를 사용했지만, ‘char’나 ‘float’,

83
00:05:46,099 --> 00:05:51,769
어느 데이터 타입이나 사용할 수 있습니다. ‘unsigned short int’ 까지도요.

84
00:05:52,139 --> 00:05:54,679
이 [] 표기법을 기억하는 게 중요합니다.

85
00:05:54,900 --> 00:06:00,109
원하는 만큼, [] 안에 적으세요. 

86
00:06:00,780 --> 00:06:08,299
이건 10개의 ‘int’가 들어있는 10개의 배열이라고 읽어야 합니다. 

87
00:06:08,969 --> 00:06:20,239
메모리 할당 면에서는 a[100]이라고 적어도 전혀 다르지 않지만,

89
00:06:20,700 --> 00:06:26,720
두 개의 변수를 사용할 수 있도록 해줍니다. 

91
00:06:26,720 --> 00:06:32,300
중요한 부분을 말하는 걸 잊어버렸군요.

92
00:06:33,090 --> 00:06:35,869
변수를 이렇게 적는다고 생각해봅시다.

93
00:06:45,060 --> 00:06:47,709
저는 이렇게 적는 걸 좋아합니다 :

94
00:06:47,709 --> 00:06:51,179
계산이 필요하다면 두 [] 사이에 변수, 혹은 연산을 넣을 수도 있어요.

95
00:06:51,249 --> 00:06:56,129
그러니까 우리는 [] 안에서 계산을 할 수 있고, 결론적으로는 이렇게 말할 수 있습니다.

96
00:06:56,129 --> 00:07:03,389
컴파일러가 봤을 때, a[0]에는 12라는 값이 있지만, [b]에는 무슨 값이 있는지 모르기 때문에

97
00:07:03,389 --> 00:07:05,389
‘b’를 찾고 3을 가져옵니다.

98
00:07:05,830 --> 00:07:08,939
컴파일러는 a[0][b]에다가

99
00:07:09,009 --> 00:07:11,009
12라는 값을 집어넣습니다. 간단하죠.

100
00:07:11,919 --> 00:07:15,898
이렇게 [] 사이에 변수들을 넣을 수도 있습니다.

101
00:07:17,129 --> 00:07:22,018
컴파일해도 여전히 같은 값이 나옵니다. 멍청한 짓을 한 번 해볼까요.

102
00:07:22,539 --> 00:07:24,159
잠시만요,

103
00:07:24,159 --> 00:07:30,178
여기 3을 집어넣고, 이걸 밑에 넣었어요.  

104
00:07:36,429 --> 00:07:40,109
이제 그 안에 있는 값을 찾을 겁니다, 정수겠죠.

105
00:07:40,289 --> 00:07:45,328
아무런 문제도 없습니다. 컴파일러는 제가 다른 인덱스를 넣을 수 있다는 걸 정확하게 이해하고 있어요.

106
00:07:45,389 --> 00:07:49,558
컴파일해보니, 잘 되네요.

107
00:07:50,229 --> 00:07:52,229
이건 조금 복잡한 예시였어요.

108
00:07:52,289 --> 00:07:55,018
정적 배열이 어떻게 동작하는지에 대한 설명이었습니다.

109
00:07:55,209 --> 00:07:58,229
먼저 [] 사이에 원하는 크기를 선언하고 

110
00:07:58,289 --> 00:08:01,799
[]에 어떤 인덱스에 접근하길 원하는지 적으세요.

111
00:08:01,860 --> 00:08:04,800
이 인덱스에 접근하기 위해 계산을 할 수도 있습니다.

112
00:08:04,860 --> 00:08:09,749
중요한 부분은, [] 사이에 들어가는 값은 정수이며, 배열의 어떤 부분을 사용할지 안다는 것입니다.

113
00:08:09,749 --> 00:08:11,409
음수를 넣을 수도 있지만,

114
00:08:11,409 --> 00:08:13,919
주의하세요! 이건 굉장히 위험합니다. 

115
00:08:14,339 --> 00:08:18,299
배열의 첫 원소는 반드시 0이기 때문에, 만약 음수를 넣는다면

116
00:08:18,449 --> 00:08:21,838
이미 배열의 범위를 벗어났으므로, 분명히 문제가 발생할 겁니다.

117
00:08:22,479 --> 00:08:24,958
이제 정적 배열을 어떻게 쓰는지 알게 되셨군요~
<< translated by inyang, chelee, mki, yeslee, mseo and ji-kim :) >>
