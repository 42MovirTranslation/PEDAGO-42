1
00:00:00,000 --> 00:00:03,210
이번 비디오에서는, 함수의 포인터에 관해 이야기해봅시다.

2
00:00:03,880 --> 00:00:04,960
음… 이미 여러 번 얘기했지만 컴퓨터 안의 모든 것은 메모리에 있고

3
00:00:04,960 --> 00:00:11,160
또한 주소를 가집니다.

4
00:00:11,290 --> 00:00:15,929
그리고 함수들 역시 그런 방식으로 동작합니다. 지금 바로 보여줄게요.

5
00:00:16,779 --> 00:00:19,199
함수의 포인터를 어떻게 정의할 수 있을까요?

6
00:00:19,779 --> 00:00:24,419
음, 특정한 작성법이 있어요: 함수의 프로토타입을 다시 써야 합니다

7
00:00:25,240 --> 00:00:28,439
여기, 예를 들어, 이걸 써볼게요.

8
00:00:29,769 --> 00:00:32,218
여기 인자를 넣지 않고, 함수의 프로토타입을 다시 썼습니다

9
00:00:32,469 --> 00:00:37,619
그리고 포인터로 만들기 위해.. int형 포인터를 만들기 위해서는 *을 넣어야 합니다, 음, 그럼 똑같이 해봅시다

10
00:00:37,870 --> 00:00:42,930
만약 그렇게 쓴다면, 매개변수로 char형을 받고 

11
00:00:43,510 --> 00:00:47,430
*int를 반환하는 fct라는 함수의 프로토타입을 쓰는 셈이죠.

12
00:00:47,829 --> 00:00:52,558
따라서, 함수의 포인터임을 명시해야 하는 유일한 방법은 괄호를 넣는 것입니다.

13
00:00:52,960 --> 00:00:56,039
그러면 모든 것이 바뀝니다! 이제 int fct, 즉 포인터를 갖고 있다고 말할 수 있습니다...

14
00:00:56,770 --> 00:01:00,419
대신 ptr이라고 부를 거고, 그렇지 않으면 문제가 생길 거에요

15
00:01:00,670 --> 00:01:06,989
ptr은 하나의 int를 반환하고 char형 매개변수를 받는 함수의 포인터입니다.

16
00:01:08,560 --> 00:01:11,610
함수의 주소를 검색하려면 어떻게 해야 할까요?

17
00:01:12,729 --> 00:01:14,710
음, 보통

18
00:01:14,710 --> 00:01:20,840
&fct로 씁니다, 제 함수는 char형 매개변수를 받아서 int를 반환합니다... 

19
00:01:21,060 --> 00:01:23,060
동작하나요? 확인해봅시다.

20
00:01:23,950 --> 00:01:30,299
동작하고, 컴파일해서, fct의 주소를 얻었습니다. 이제 어떻게 사용해볼까요?

21
00:01:30,880 --> 00:01:32,880
그냥 이렇게 할게요

22
00:01:33,670 --> 00:01:38,280
fct의 괄호에 값을 넣어봅시다

23
00:01:39,100 --> 00:01:41,100
탁!

24
00:01:41,440 --> 00:01:43,660
이렇게 한다면

25
00:01:43,860 --> 00:01:47,700
fct를 사용하는 대신에, 간단하게 포인터로 해봅시다: *ptr 

26
00:01:47,979 --> 00:01:54,089
ptr은 함수의 주소입니다, 고로 *ptr은 함수입니다. 그래서 *ptr의 괄호를 통해 인자들을 줍니다

27
00:01:56,140 --> 00:02:03,149
컴파일하면 동작해야 합니다… 여기에 printf를 넣고 동작하는지 봅시다.

28
00:02:08,288 --> 00:02:11,849
해보니까 “o”가 보이네요!!

29
00:02:12,850 --> 00:02:18,419
다시 한번 말하지만, 작성법은 중요합니다, 이제 fct 함수를 바꿔봅시다

30
00:02:18,880 --> 00:02:20,840
두 번째 char를 넣어봅시다

31
00:02:21,040 --> 00:02:22,640
(여기에 두번째 char를 넣어봅시다)

32
00:02:22,780 --> 00:02:25,740
컴파일 에러가 났고 말해주네요: “조심해!!”

33
00:02:25,920 --> 00:02:32,860
int형 반환에 char형 매개변수 1개를 받는 함수 대신,

34
00:02:32,860 --> 00:02:42,570
char형 변수 2개를 받는 함수의 주소를 넣으려고 했습니다 

35
00:02:43,420 --> 00:02:48,360
제대로 동작하지 않을 거예요. 우리가 실수했다고 경고해준 컴파일러가 고맙네요….

36
00:02:48,580 --> 00:02:52,800
실제로 프로그램을 시작하기 때문에, 동작은 합니다.

37
00:02:53,140 --> 00:02:55,380
근거는 ‘o’가 있다는 것이지만

38
00:02:55,810 --> 00:02:59,399
여기에 “char o” 값은 무엇이든 될 수 있습니다

39
00:02:59,640 --> 00:03:03,720
그렇기 때문에 경고가 있을 때 여러분은 정말 조심해야 하고, 그것들을 읽으세요! 종종 실수할 수 있습니다!

40
00:03:04,200 --> 00:03:09,480
모든 경고를 없애야만 합니다. 그렇게 함으로써 적어도 우리는 기본적인 실수를 하지 않았음을 확신할 수 있습니다

41
00:03:09,720 --> 00:03:11,240
분명 다른 실수를 할 수 있지만, 기본적인 실수는 하지 않았습니다.

42
00:03:11,799 --> 00:03:18,029
좋아요! 여러분들은 함수의 포인터를 보았고, 특정한 사용법들이 있습니다

43
00:03:18,730 --> 00:03:22,619
예를 들어, 특정 매개변수에 따라 항상 동일한 인수를 전달하고

44
00:03:23,200 --> 00:03:28,079
매개변수에 따라 이러한 동일한 인수를 한 함수 또는 다른 함수에 사용할 것입니다

45
00:03:28,620 --> 00:03:31,349
예를 들어 함수에 대한 포인터 배열을 만들고 같은 인자에 대해

46
00:03:31,599 --> 00:03:35,099
여러 함수를 차례로 수행할 수 있도록 루프를 만들 것입니다

47
00:03:35,650 --> 00:03:41,159
매우 유용합니다

48
00:03:41,159 --> 00:03:43,469
여러분들이 코딩을 좀 더 하다 보면 보게 될 겁니다,

49
00:03:44,049 --> 00:03:47,219
어떤 응용 프로그램에서는 매우 흔합니다

50
00:03:47,500 --> 00:03:51,479
이제 함수에서 포인터를 선언하고 사용하는 방법을 알았습니다
<< translated by mki, mseo, inyang, ji-kim and yeslee :) >>