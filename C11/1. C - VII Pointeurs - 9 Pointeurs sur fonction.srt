1
00:00:00,000 --> 00:00:03,210
이번 비디오에서는 함수의 포인터에 관해 이야기해봅시다

2
00:00:03,880 --> 00:00:04,960
음… 이미 여러 번 얘기했지만

3
00:00:04,960 --> 00:00:11,160
컴퓨터 안의 모든 것은 메모리 어딘가에 있고 메모리 주소를 가질 수 있습니다

4
00:00:11,290 --> 00:00:15,929
함수들 역시 같은 방식으로 동작합니다, 지금 바로 보여줄게요

5
00:00:16,779 --> 00:00:19,199
함수의 포인터를 어떻게 정의할 수 있을까요?

6
00:00:19,779 --> 00:00:24,419
이를 위한 특정한 작성법이 있어요: 함수의 프로토타입을 다시 써야 합니다

7
00:00:25,240 --> 00:00:28,439
예를 들어 여기에 이걸 써볼게요

8
00:00:29,769 --> 00:00:32,218
여기 인자를 넣지 않고 함수의 프로토타입을 다시 썼습니다

9
00:00:32,469 --> 00:00:37,619
그리고 포인터로 만들기 위해… int형 포인터로 만들기 위해서는 *을 넣어야 합니다
음, 그렇게 해볼게요

10
00:00:37,870 --> 00:00:42,930
다만 이렇게 적는다면 이는 매개변수로 char형을 받고

11
00:00:43,510 --> 00:00:47,430
*int를 반환하는 fct라는 함수의 프로토타입을 쓰는 것과 같습니다

12
00:00:47,829 --> 00:00:52,558
따라서 함수의 포인터임을 명시할 수 있는 유일한 방법은 괄호를 넣는 것입니다

13
00:00:52,960 --> 00:00:56,039
괄호 하나로 모든 것이 바뀌었습니다!
이제 int fct, 즉 포인터를 갖고 있다고 말할 수 있습니다…

14
00:00:56,770 --> 00:01:00,419
앞으로 ptr이라 부를게요, 그렇지 않으면 문제가 생길 거에요

15
00:01:00,670 --> 00:01:06,989
ptr은 char형 매개변수를 받아 하나의 int를 반환하는 함수의 포인터입니다

16
00:01:08,560 --> 00:01:11,610
함수의 주소를 검색하려면 어떻게 해야 할까요?

17
00:01:12,729 --> 00:01:14,710
음, 보통은

18
00:01:14,710 --> 00:01:20,840
&fct로 씁니다, 제 함수는 char형 매개변수를 받아서 int를 반환합니다…

19
00:01:21,060 --> 00:01:23,060
동작하나요? 확인해봅시다

20
00:01:23,950 --> 00:01:30,299
잘 동작하네요, 컴파일도 되었고요
이제 fct의 주소를 얻었습니다, 이걸 어떻게 사용해볼까요?

21
00:01:30,880 --> 00:01:32,880
이렇게 해볼게요

22
00:01:33,670 --> 00:01:38,280
fct의 괄호에 값을 넣어봅시다

23
00:01:39,100 --> 00:01:41,100
탁!

24
00:01:41,440 --> 00:01:43,660
이렇게 할 수 있겠죠

25
00:01:43,860 --> 00:01:47,700
이번엔 fct를 사용하는 대신 간단하게 포인터로 해봅시다: *ptr

26
00:01:47,979 --> 00:01:54,089
ptr은 함수의 주소입니다, 고로 *ptr은 함수입니다
*ptr의 괄호를 통해 인자를 넣을 수 있습니다

27
00:01:56,140 --> 00:02:03,149
컴파일이 되었고 잘 동작해야 합니다…
여기에 printf를 넣고 동작하는지 봅시다

28
00:02:08,288 --> 00:02:11,849
짜잔, "o"가 잘 출력되었습니다!

29
00:02:12,850 --> 00:02:18,419
다시 한번 말씀드리지만 자료형이 중요합니다
만약 제가 갑자기 fct 함수를 수정한다면

30
00:02:18,880 --> 00:02:20,840
예를 들면 매개변수로 두 번째 char을 넣으면 말이죠

31
00:02:21,040 --> 00:02:22,640
(여기에 두 번째 char를 넣어 줄게요)

32
00:02:22,780 --> 00:02:25,740
컴파일 오류가 발생했습니다, 컴파일러는 이렇게 말해주고 있네요:

33
00:02:25,920 --> 00:02:32,860
"조심해요! 당신은 지금 int를 반환하고 char 매개변수 1개를 받는 함수 대신

34
00:02:32,860 --> 00:02:42,570
char 매개변수 2개를 받는 함수의 주소를 넣으려고 했어요

35
00:02:43,420 --> 00:02:48,360
이건 제대로 동작하지 않을 거예요"
고맙게도 우리가 실수했다고 친절하게 경고해 주네요

36
00:02:48,580 --> 00:02:52,800
실제로 프로그램을 실행시킬 수 있고 동작도 합니다

37
00:02:53,140 --> 00:02:55,380
사실 여기에 'o'가 들어가는데

38
00:02:55,810 --> 00:02:59,399
이 'o'에 어떤 값이 들어갈지는 알 수 없습니다

39
00:02:59,640 --> 00:03:03,720
그렇기 때문에 경고가 발생했을 때 주의를 기울여야 합니다
반드시 경고를 읽으세요! 실수는 생각보다 자주 발생합니다!

40
00:03:04,200 --> 00:03:09,480
경고가 하나도 발생하지 않도록 해 주어야 합니다
그렇게 함으로써 적어도 기본적인 실수는 하지 않았음을 확신할 수 있으니까요

41
00:03:09,720 --> 00:03:11,240
다른 실수는 할 수 있더라도 기본적인 실수는 안 하는 게 좋습니다

42
00:03:11,799 --> 00:03:18,029
좋아요! 여러분들은 지금까지 함수의 포인터를 살펴보았습니다
이 함수 포인터들은 여러 방면으로 사용됩니다

43
00:03:18,730 --> 00:03:22,619
예를 들어 특정 매개변수 값을 가질 때

44
00:03:23,200 --> 00:03:28,079
항상 같은 인수를 전달할 수도 있고

45
00:03:28,620 --> 00:03:31,349
매개변수에 따라 특정한 함수나 다른 것을 불러올 수도 있겠지요

46
00:03:31,599 --> 00:03:35,099
함수 포인터 배열을 만들어 여러 함수를 차례대로 호출하는
루프 같은 것도 만들 수 있겠네요

47
00:03:35,650 --> 00:03:41,159
이 외에도 더 많은 사용법이 있겠지요… 매우 유용합니다

48
00:03:41,159 --> 00:03:43,469
여러분들이 코딩을 좀 더 하다 보면 아시겠지만

49
00:03:44,049 --> 00:03:47,219
특정 응용 프로그램에서는 꽤 보편적으로 사용됩니다

50
00:03:47,500 --> 00:03:51,479
이제 함수에서 포인터를 선언하고 사용하는 방법을 알았습니다
<< translated by mki, mseo, inyang, ji-kim and yeslee :) >>
