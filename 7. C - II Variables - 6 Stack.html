1
00:00:01,000 --> 00:00:03,000
이번 영상은 stack에 관한 것입니다.

2
00:00:03,000 --> 00:00:07,000
스택은 메모리의 일부분입니다.

3
00:00:07,000 --> 00:00:12,000
여러분이 변수를 사용하거나 함수를 호출할 때 확장됩니다.

4
00:00:12,000 --> 00:00:14,000
함수는 다른 영상에서 다룰 것입니다.

6
00:00:14,000 --> 00:00:24,000
스택의 주 원칙은 크기가 확장된다는 것입니다.

7
00:00:24,000 --> 00:00:31,000
메모리의 다른 부분은 힙 영역입니다. 이건 malloc()과 함께 다음에 다루겠습니다.

8
00:00:31,000 --> 00:00:34,000
예를 들면, int i를 선언할 때

9
00:00:34,000 --> 00:00:37,000
스택에게 크기를 키우라고 요구하는 셈입니다.

10
00:00:37,000 --> 00:00:42,000
스택에 추가적인 int를 넣기 위해서 말이죠.

11
00:00:42,000 --> 00:00:45,000
스택이 연속적이라는 것을 아는게 중요합니다.

12
00:00:45,000 --> 00:00:50,000
여러분이 스택을 망가뜨린다면, 프로그램이 강제종료될 수도 있습니다.

14
00:00:50,000 --> 00:00:55,000
스택에는 사용할 함수의 이름과 다른 것들이 많이 있습니다.

15
00:00:55,000 --> 00:00:57,000
이건 나중에 다루도록 하죠.

16
00:00:57,000 --> 00:01:00,000
이번 영상에서 모든 걸 이해하지 못하더라도 걱정하지 마세요.

17
00:01:00,000 --> 00:01:04,000
나중에 진짜로 유용해질 것입니다.

18
00:01:04,000 --> 00:01:08,000
명확하게 예시를 들어보죠.

19
00:01:08,000 --> 00:01:10,000
프로그램에서

20
00:01:10,000 --> 00:01:17,000
i에 int 4바이트를 할당했습니다.

22
00:01:17,000 --> 00:01:21,000
좀 재밌는 걸 시도해 볼 수 있겠군요.

23
00:01:21,000 --> 00:01:25,000
길이가 1인 배열을 선언해보죠.

24
00:01:25,000 --> 00:01:27,000
명확하게 예시를 들어볼게요

25
00:01:27,000 --> 00:01:31,000
내부에 요소가 하나뿐인 배열

26
00:01:31,000 --> 00:01:42,000
우리는 tab[1]의 값을 출력하고 싶습니다

27
00:01:42,000 --> 00:01:49,000
하지만 i에만 값을 대입했죠.

28
00:01:49,000 --> 00:01:58,000
이제 무엇이 일어나는지 봅시다

29
00:01:58,000 --> 00:02:00,000
error가 생겼네요

30
00:02:00,000 --> 00:02:03,000
컴파일러가 불만이 많지만 그래도 실행은 가능하네요

31
00:02:03,000 --> 00:02:05,000
실행해보니, 42를 출력합니다

32
00:02:05,000 --> 00:02:08,000
놀랄 일이 아닙니다

33
00:02:08,000 --> 00:02:11,000
만약 제가 값을 67로 변경한다면

34
00:02:11,000 --> 00:02:15,000
컴파일하고 실행했을 때 67이 출력됩니다.

35
00:02:15,000 --> 00:02:18,000
스택은 연속적인 메모리 공간이라는 걸 기억하세요

36
00:02:18,000 --> 00:02:22,000
여러분이 무언가 새로운 것을 추가할 때마다, 스택의 마지막에 이어서 추가됩니다.

37
00:02:22,000 --> 00:02:26,000
그래서 int가 여기 있다면, 배열은 여기 있겠죠. 사실은 여기 일반적인 변수 하나가 있는 셈입니다.

38
00:02:26,000 --> 00:02:40,000
그게 tab[0] 이겠죠. 그리고 tab[1]를 하면 이렇게 다음 int를 찾게 됩니다.

39
00:02:40,000 --> 00:02:44,000
그게 바로 i인거죠 (역주: 이해가 안되면 스택과 메모리에 대해 찾아봅시다 :D)

40
00:02:44,000 --> 00:02:52,000
좀 더 나아가봅시다

41
00:02:52,000 --> 00:02:55,000
여기를 10이라고 해보죠

42
00:02:55,000 --> 00:02:59,000
어디 한번 망쳐봅시다. 아마 제대로 돌아가지 않을 겁니다

43
00:02:59,000 --> 00:03:04,000
엥? 괜찮군요, 아 배열의 값을 수정해주지 않았네요

44
00:03:04,000 --> 00:03:15,000
재밌는 걸 해보죠. 배열의 값을 모두 위와 같이 변경하겠습니다

45
00:03:15,000 --> 00:03:21,000
1로 시작해서, 2, 3...

46
00:03:21,000 --> 00:03:27,000
그걸로 충분할겁니다

47
00:03:27,000 --> 00:03:31,000
두 개만 더 해보죠

48
00:03:31,000 --> 00:03:35,000
이걸 i로 바꾸고

49
00:03:35,000 --> 00:03:39,000
확인하면, 우리는 몇 가지 문제를 만날 겁니다

50
00:03:39,000 --> 00:03:42,000
네 좀 많네요, 명백하게 잘못되었군요

51
00:03:42,000 --> 00:03:47,000
야생의 segfault가 나타났다

52
00:03:47,000 --> 00:03:51,000
주어진 스택 영역을 벗어나려고 할 때 나타나는 것입니다

53
00:03:51,000 --> 00:03:54,000
그곳에는 다른 함수가 자리잡고 있는데, 곧 다루도록 하겠습니다

54
00:03:54,000 --> 00:04:00,000
main 위에 함수가 있고, 우리는 그 함수를 덮어씌웠습니다

55
00:04:00,000 --> 00:04:03,000
이렇게 함으로써 이런 오류가 생겼죠. 우리는 스택의 일부분을 덮어씌웠습니다

56
00:04:03,000 --> 00:04:13,000
스택의 기존 데이터를 읽었으나 우리가 그것을 변경시켰고, 그래서 강제 종료된 것입니다

57
00:04:13,000 --> 00:04:16,000
그러니 배열의 크기를 초과하지 않도록 주의하세요

58
00:04:16,000 --> 00:04:19,000
왜냐하면 segfault의 위험이 있으니까요

59
00:04:19,000 --> 00:04:22,000
스택은 연속적이므로, 여러분이

60
00:04:22,000 --> 00:04:25,000
변수를 변경할 때 리스크를 가지고 있는 셈입니다

61
00:04:25,000 --> 00:04:28,000
여기서 보이듯이, 저는 i를 출력하려 했지만 1이 출력되었습니다

62
00:04:28,000 --> 00:04:31,000
왜냐하면 위에서 변경되었기 때문입니다

63
00:04:31,000 --> 00:04:35,000
그러니 주의하세요. 스택은 하나의 연속적인 메모리라는 사실을요

64
00:04:35,000 --> 00:59:59,000
여러분이 변수에 접근해서 무언가를 하려고 한다면, 주의깊게 생각하세요 !

translated by inyang, chelee, mki, yeslee, mseo and ji-kim :)
