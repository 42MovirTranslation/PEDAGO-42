1
00:00:00,290 --> 00:00:01,670
이번 영상에서는 재귀에 대해 배울 겁니다

2
00:00:01,670 --> 00:00:04,700
지금까지는 함수를 어떻게 쓰고

3
00:00:04,700 --> 00:00:06,589
어떻게 호출하는지 등을 배웠죠

4
00:00:06,589 --> 00:00:08,029
이번에는 재귀 함수라고 하는

5
00:00:08,029 --> 00:00:09,110
새로운 함수 유형에 대해 알아봅시다

6
00:00:09,110 --> 00:00:10,040
재귀 함수는 자기 자신을 다시 호출합니다

7
00:00:10,040 --> 00:00:12,170
어느 경우에 사용할까요?

8
00:00:12,170 --> 00:00:15,530
간단히 생각해서, 함수를 호출하면

9
00:00:15,530 --> 00:00:16,700
결국 새로운 컨텍스트를 하나 연 것이나 마찬가지죠

10
00:00:16,700 --> 00:00:18,200
새로운 컨텍스트를 열 때마다

11
00:00:18,200 --> 00:00:19,580
다른 스코프로 이동하는 것이라고 할 수 있습니다

12
00:00:19,580 --> 00:00:21,050
그리고 이 새 컨텍스트 안에서

13
00:00:21,050 --> 00:00:22,130
계산을 하거나 프로그램 로직을 실행할 수 있기 때문에

14
00:00:22,130 --> 00:00:23,150
여러분이 다음 함수를 호출했을 때

15
00:00:23,150 --> 00:00:26,750
문제가 풀릴 때가 있는 겁니다

16
00:00:26,750 --> 00:00:29,930
보통 재귀 함수는

17
00:00:29,930 --> 00:00:31,910
논리적인 순서로 풀어야 하는 문제들에 사용됩니다

18
00:00:31,910 --> 00:00:37,130
N의 값이 다른 값에 의존하는 경우라던가…

19
00:00:37,130 --> 00:00:40,360
또는 N을 계산하기 위해서 N - 1의 값을 구해야 할 때 말이죠

20
00:00:40,360 --> 00:00:44,420
그러니까 예를 들면 팩토리얼을 계산할 때 사용됩니다

21
00:00:44,420 --> 00:00:48,410
스도쿠나 그와 비슷한 문제를 풀 때도 쓰이죠

22
00:00:48,410 --> 00:00:53,210
재귀는 우리가 N 단계에서의 상태를 유지할 수 있도록 합니다

23
00:00:53,210 --> 00:00:55,010
왜냐하면 그 단계에 도달하기 전에

24
00:00:55,010 --> 00:00:56,570
그리고 결괏값이 알맞다고 알아내기 전에

25
00:00:56,570 --> 00:00:57,920
이전의 절차들을 먼저 끝내야 하니까요

26
00:00:57,920 --> 00:00:59,970
주로… 예…

27
00:00:59,970 --> 00:01:01,020
이것이 재귀 함수가 활용되는 방식입니다

28
00:01:01,020 --> 00:01:03,150
약간 바보 같은 예시를 보여드리죠

29
00:01:03,150 --> 00:01:05,220
어떻게 동작하는지 잘 보세요

30
00:01:05,220 --> 00:01:08,670
여기 제가 곱셈을 하는 함수를 하나 만들었습니다

31
00:01:08,670 --> 00:01:11,670
a와 b를 받아 곱하는

32
00:01:11,670 --> 00:01:13,920
"mul"이란 함수입니다

33
00:01:13,920 --> 00:01:15,120
그다지 흥미롭진 않은 함수죠

34
00:01:15,120 --> 00:01:17,310
이해하기 쉽도록 그냥 만들어본 겁니다

35
00:01:17,310 --> 00:01:19,260
여기에 a와 b를 이렇게 넣어 4 x 10을 연산하니

36
00:01:19,260 --> 00:01:19,830
40이라는 결과가 나왔습니다

37
00:01:19,830 --> 00:01:21,480
이번엔 곱하기( * )를 쓰지 말고

38
00:01:21,480 --> 00:01:25,890
더하기( + )만으로 계산을 해 봅시다

39
00:01:25,890 --> 00:01:26,220
어떻게 하면 될까요?

40
00:01:26,220 --> 00:01:28,500
함수를 이런 식으로 써보죠

41
00:01:28,500 --> 00:01:36,270
그러니까 b가 0보다 클 때, 음…

42
00:01:36,270 --> 00:01:38,700
0이 아닐 때,

43
00:01:38,700 --> 00:01:40,740
흠… 이러면 음수와 양수를 관리해야겠군요

44
00:01:40,740 --> 00:01:41,670
좋아요 좋아요…

45
00:01:41,670 --> 00:01:43,590
둘 다 합시다

46
00:01:43,590 --> 00:01:48,410
그러니까 만약 b가 0이 아닐 때

47
00:01:48,410 --> 00:01:52,880
b가 0보다 작으면 "b++"

48
00:01:52,880 --> 00:01:54,310
아니면 "b--"

49
00:01:54,310 --> 00:02:03,549
좋아요, 그러고 나서…

50
00:02:03,549 --> 00:02:08,470
"int ret"을 만듭시다

51
00:02:08,470 --> 00:02:14,019
"ret"은 0이고요, 그리고 이렇게 해봅시다

52
00:02:14,019 --> 00:02:14,860
잠시만요…

53
00:02:14,860 --> 00:02:19,500
"ret += a"라고 적어 봅시다

54
00:02:19,790 --> 00:02:23,610
아, 잠시만요, 뭔가를 깨달았어요…

55
00:02:23,610 --> 00:02:27,330
"ret += a"가 아니죠, 이건…

56
00:02:27,330 --> 00:02:28,920
두 경우 전부 바꿔줘야겠네요

57
00:02:28,920 --> 00:02:33,510
읏차

58
00:02:33,510 --> 00:02:36,239
음수일 때는 "ret -= a"

59
00:02:38,870 --> 00:02:45,459
양수일 때는 "ret += a"라고 합시다

60
00:02:49,360 --> 00:02:52,020
조금 바보 같아 보이긴 하죠

61
00:02:52,020 --> 00:02:55,690
아무렴 상관없죠? 그럼 ret을 반환합시다

62
00:02:55,690 --> 00:02:57,880
읏차! 저장하고요

63
00:02:57,880 --> 00:02:58,780
같은 값이 나오나 보죠

64
00:02:58,780 --> 00:03:02,140
값이 같나요? 40

65
00:03:02,140 --> 00:03:04,270
완벽해요! 값이 같군요

66
00:03:04,270 --> 00:03:05,770
좋아요, 멋지네요

67
00:03:05,770 --> 00:03:08,110
이번에는 음수로 해보죠

68
00:03:08,110 --> 00:03:09,580
-10을 넣으면 어떨까요, -40이 나올까요?

69
00:03:09,580 --> 00:03:13,330
-40이군요! 마법 같죠?

70
00:03:13,330 --> 00:03:14,740
여기 제가 만든 것은 반복 함수입니다

71
00:03:14,740 --> 00:03:16,420
이 함수는 "상태를 기억"하지 않고

72
00:03:16,420 --> 00:03:17,290
그저 루프(반복문)만 돕니다

73
00:03:17,290 --> 00:03:19,840
간단히 곱셈 계산만 해줍니다

74
00:03:19,840 --> 00:03:20,890
그것이 반복 함수입니다

75
00:03:20,890 --> 00:03:22,410
이번에는 같은 동작을 하고 싶지만

76
00:03:22,410 --> 00:03:24,550
"while" 반복문을 쓰고 싶지 않다면 어떻게 해야 할까요

77
00:03:24,550 --> 00:03:27,040
그러니까 재귀적으로 만들고 싶다면 말이죠

78
00:03:27,040 --> 00:03:29,080
어떻게 만들어야 할까요? 일단 재귀 함수를 만들 때는

79
00:03:29,080 --> 00:03:31,720
어느 지점에서 반복을 그만두고 빠져나올 것인지를 알아야 합니다

80
00:03:31,720 --> 00:03:33,430
그것을 첫 번째로 적어야 합니다

81
00:03:33,430 --> 00:03:34,750
함수를 호출할 때마다

82
00:03:34,750 --> 00:03:38,310
매번 변수 혹은 전달 인자의 값이 바뀝니다

83
00:03:38,310 --> 00:03:40,270
그러므로 언젠가 재귀를 중단하고 탈출할 지점이 생기지요

84
00:03:40,270 --> 00:03:42,100
그것이 이 곱셈 함수를 마지막으로 호출하는

85
00:03:42,100 --> 00:03:44,920
지점이 될 겁니다

86
00:03:44,920 --> 00:03:48,010
만약 "b == 0"이라고 적으면

87
00:03:48,010 --> 00:03:50,770
이 조건에 맞을 때 재귀는 멈출 것입니다

88
00:03:50,770 --> 00:03:55,080
간단히 말해, "return (0)"을 하죠

89
00:03:55,080 --> 00:03:57,690
이제 이렇게 적어봅시다

90
00:03:57,690 --> 00:04:01,020
만약 b가 0보다 작을 때는

91
00:04:01,020 --> 00:04:16,108
"-a + mul(a, b + 1)"을 반환하고

92
00:04:16,108 --> 00:04:17,250
만약 0보다 작지 않다면

93
00:04:17,250 --> 00:04:18,899
(여기에 "else"를 써도 되지만 상관없습니다)

94
00:04:18,899 --> 00:04:22,590
"a + mul(a, b - 1)"을 반환하라

95
00:04:27,350 --> 00:04:33,510
이걸 지우고 지우고 지우고… 실행해 봅시다

96
00:04:33,510 --> 00:04:35,780
동작할까요? 동작합니다!

97
00:04:35,780 --> 00:04:38,610
자, 두 가지에 집중해 주세요

98
00:04:38,610 --> 00:04:40,830
기본적으로

99
00:04:40,830 --> 00:04:42,870
처음으로 "mul"을 호출했을 때

100
00:04:42,870 --> 00:04:46,410
"4"와 "-10"이 함수로 전달됩니다

101
00:04:46,410 --> 00:04:48,720
a는 4고 b는 -10이기 때문이죠

102
00:04:48,720 --> 00:04:51,240
-10은 0과 같습니까? 아니죠, 그래서 0을 반환하지 않습니다

103
00:04:51,240 --> 00:04:53,490
-10은 0보다 작습니까? 그렇죠

104
00:04:53,490 --> 00:04:56,070
그러므로 "-a", 그러니까 (-4) 그리고

105
00:04:56,070 --> 00:04:59,100
"mul"을 거쳐서 얻은 값을 더합니다

106
00:04:59,100 --> 00:05:02,370
"mul"에 "b + 1"이라고 적었죠

107
00:05:02,370 --> 00:05:05,690
그래서 -10은 -9로 바뀝니다

108
00:05:05,690 --> 00:05:08,850
그다음에 다시 한번 함수가 호출되죠, 이번에는

109
00:05:08,850 --> 00:05:11,010
b는 -9고 여기로 돌아오면

110
00:05:11,010 --> 00:05:12,990
-4 더하기 어쩌고저쩌고…

111
00:05:12,990 --> 00:05:14,880
뭐가 어떻게 돌아가는지 이제 대충 감이 오죠?

112
00:05:14,880 --> 00:05:16,949
결국 마지막에는

113
00:05:16,949 --> 00:05:18,360
b가 0과 같다는 이 조건문에 진입합니다

114
00:05:18,360 --> 00:05:20,580
그러면 "return (0)"을 하겠죠

115
00:05:20,580 --> 00:05:21,840
이제 0이 있고 -4가 있으니까

116
00:05:21,840 --> 00:05:24,960
-4를 반환합니다

117
00:05:24,960 --> 00:05:26,100
이전의 함수, 그러니까 이 함수의 반환 값을

118
00:05:26,100 --> 00:05:27,930
기다리고 있던 함수는 -4의 값을 받습니다

119
00:05:27,930 --> 00:05:29,310
-4 더하기 -4는 -8입니다

120
00:05:29,310 --> 00:05:31,860
이제 그 이전에 반환 값을 기다리던 함수는 -8을 받을 거고요

121
00:05:31,860 --> 00:05:33,780
-8 더하기 -4는 -12입니다, 이전 함수는 -16…

122
00:05:33,780 --> 00:05:36,240
이렇게 저렇게… 10번을 하고, 최종적으로

123
00:05:36,240 --> 00:05:38,910
계산된 결과를 얻을 수 있습니다

124
00:05:38,910 --> 00:05:40,500
무슨 일이 어떻게 일어났는지 알겠나요?

125
00:05:40,500 --> 00:05:44,490
매번 계산을 수행하는 새로운 컨텍스트가 생성됩니다

126
00:05:44,490 --> 00:05:51,990
하지만 4 곱하기 -10을 하려면

127
00:05:51,990 --> 00:05:53,310
(이 곱셈 시스템은 좀 우스꽝스럽지만

128
00:05:53,310 --> 00:05:55,560
곱하기를 쓰지 않으려고 하니 이렇게 나왔네요)

129
00:05:55,560 --> 00:05:57,660
먼저 4 곱하기 -9를 계산해야 합니다

130
00:05:57,660 --> 00:06:02,729
그래야 4를 10번째로 더할 수 있으니까요

131
00:06:02,729 --> 00:06:05,550
먼저 9번 더했어야 10번째로 더할 수 있지요

132
00:06:05,550 --> 00:06:07,560
9번 더하려면

133
00:06:07,560 --> 00:06:09,120
그 전에 8번 더했어야 하고요

134
00:06:09,120 --> 00:06:13,889
8번 더하려면 그 전에 7번 더했어야 하죠, 그렇게 계속 반복합니다…

135
00:06:13,889 --> 00:06:15,690
재귀는 매우 강력한 도구입니다

136
00:06:15,690 --> 00:06:19,560
문제를 여러 단계로 나누어서

137
00:06:19,560 --> 00:06:22,860
N 단계의 문제를 풀려면

138
00:06:22,860 --> 00:06:26,039
N - 1단계의 문제를 풀어야 하고요

139
00:06:26,039 --> 00:06:27,180
N - 1단계의 문제를 풀려면

140
00:06:27,180 --> 00:06:28,740
그 밑의 문제를 풀어야 하죠, 그렇게 계속 내려가다가

141
00:06:28,740 --> 00:06:29,820
주로 0레벨이나 1레벨쯤에

142
00:06:29,820 --> 00:06:31,860
특별한 케이스가 나옵니다

143
00:06:31,860 --> 00:06:34,770
이것이 재귀의 사용 방법입니다

144
00:06:34,770 --> 00:06:39,330
정리하자면, 재귀는 전달 인자를 바꾸면서 같은 함수를 반복적으로 호출합니다

145
00:06:39,330 --> 00:06:41,009
그리고 함수가 반환하는 값을 이용하여

146
00:06:41,009 --> 00:06:44,729
현재 문제를 푸는 거죠

147
00:06:44,729 --> 00:06:46,380
N 단계의 문제를 풀기 위해서

148
00:06:46,380 --> 00:06:49,500
N - 1단계의 함수를 호출하는 식이죠… 네, 맞습니다!

149
00:06:49,500 --> 00:06:52,009
이렇게 동작하는 거예요!
<< translated by mseo, inyang, chelee, mki, yeslee and ji-kim :) >>
