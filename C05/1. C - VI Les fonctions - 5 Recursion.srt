1
00:00:00,290 --> 00:00:01,670
이번 영상에서는 재귀에 대해 배울 겁니다.

2
00:00:01,670 --> 00:00:04,700
지금까지는 함수를 어떻게 쓰고

3
00:00:04,700 --> 00:00:06,589
어떻게 호출하는지를 배웠죠.

4
00:00:06,589 --> 00:00:08,029
이번에는 재귀 함수라고 하는

5
00:00:08,029 --> 00:00:09,110
새로운 함수에 대해 알아봅시다.

6
00:00:09,110 --> 00:00:10,040
재귀 함수는 자기 자신을 다시 호출합니다.

7
00:00:10,040 --> 00:00:12,170
어느 경우에 사용할까요?

8
00:00:12,170 --> 00:00:15,530
간단히 말해보죠. 함수를 호출하면,

9
00:00:15,530 --> 00:00:16,700
결국 새로운 컨텍스트(문맥)를 하나 연 것이나 마찬가지죠.

10
00:00:16,700 --> 00:00:18,200
새로운 컨텍스트를 열 때마다

11
00:00:18,200 --> 00:00:19,580
다른 스코프(범위)로 들어가는 겁니다.

12
00:00:19,580 --> 00:00:21,050
그리고 이 새 컨텍스트 안에서

13
00:00:21,050 --> 00:00:22,130
계산을 하거나 프로그램 로직을 실행할 수 있습니다.

14
00:00:22,130 --> 00:00:23,150
그러다가 다음 함수를 호출했을 때

15
00:00:23,150 --> 00:00:26,750
문제가 풀릴 수도 있을 겁니다.

16
00:00:26,750 --> 00:00:29,930
보통 재귀 함수는

17
00:00:29,930 --> 00:00:31,910
논리적 순서로 풀어야 하는 문제들에 사용됩니다.

18
00:00:31,910 --> 00:00:37,130
N의 값이 다른 값에 의존하는 경우...

19
00:00:37,130 --> 00:00:40,360
예를 들어, N을 계산하기 위해선 N - 1의 값을 구해야 할 때 말이죠.

20
00:00:40,360 --> 00:00:44,420
그러니까 팩토리얼을 계산할 때 쓰입니다.

21
00:00:44,420 --> 00:00:48,410
스도쿠나 그와 비슷한 문제를 풀 때도 쓰이죠.

22
00:00:48,410 --> 00:00:53,210
재귀는 우리가 N의 단계에 머물러 있도록 합니다.

23
00:00:53,210 --> 00:00:55,010
왜냐하면 그 단계를 실행하기 전에

24
00:00:55,010 --> 00:00:56,570
그리고 결괏값이 알맞다고 알아내기 전에,

25
00:00:56,570 --> 00:00:57,920
이전의 절차들을 먼저 끝내야 하니까요.

26
00:00:57,920 --> 00:00:59,970
주로… 예…

27
00:00:59,970 --> 00:01:01,020
이것이 재귀 함수가 활용되는 방식입니다.

28
00:01:01,020 --> 00:01:03,150
이상한 예시를 보여드리죠.

29
00:01:03,150 --> 00:01:05,220
어떻게 동작하는지 잘 보세요.

30
00:01:05,220 --> 00:01:08,670
자, 곱셈하는 함수를 하나 만들었습니다.

31
00:01:08,670 --> 00:01:11,670
a와 b를 받아 곱하는

32
00:01:11,670 --> 00:01:13,920
“mul”이란 함수입니다.

33
00:01:13,920 --> 00:01:15,120
그다지 흥미롭진 않은 함수죠.

34
00:01:15,120 --> 00:01:17,310
이해하기 쉽도록 그냥 만든 겁니다.

35
00:01:17,310 --> 00:01:19,260
자, 보시죠. a와 b, 4 x 10

36
00:01:19,260 --> 00:01:19,830
40입니다.

37
00:01:19,830 --> 00:01:21,480
이번엔 곱하기를 쓰지 말죠.

38
00:01:21,480 --> 00:01:25,890
더하기를 합시다.

39
00:01:25,890 --> 00:01:26,220
뭘 할 수 있을까요?

40
00:01:26,220 --> 00:01:28,500
함수를 이런 식으로 써보죠.

41
00:01:28,500 --> 00:01:36,270
그러니까 b가 0보다 클 때, 음...

42
00:01:36,270 --> 00:01:38,700
0이 아닐 때,

43
00:01:38,700 --> 00:01:40,740
흠… 이러면 음수와 양수를 관리해야겠군요.

44
00:01:40,740 --> 00:01:41,670
좋아요 좋아요.

45
00:01:41,670 --> 00:01:43,590
둘 다 합시다.

46
00:01:43,590 --> 00:01:48,410
그러니까 b가 0이 아닐 때,

47
00:01:48,410 --> 00:01:52,880
b가 0보다 작으면 “b++”

48
00:01:52,880 --> 00:01:54,310
아니면 “b--”.

49
00:01:54,310 --> 00:02:03,549
짜잔, 그러고 나서...

50
00:02:03,549 --> 00:02:08,470
“int ret”을 만듭시다.

51
00:02:08,470 --> 00:02:14,019
“ret”은 0이고요. 그러고...

52
00:02:14,019 --> 00:02:14,860
잠시만요…

53
00:02:14,860 --> 00:02:19,500
“ret += a”로 합시다.

54
00:02:19,790 --> 00:02:23,610
아, 잠시만요. 뭔가를 깨달았어요.

55
00:02:23,610 --> 00:02:27,330
“ret += a”가 아니죠.

56
00:02:27,330 --> 00:02:28,920
두 경우 전부 바꿔줘야 해요.

57
00:02:28,920 --> 00:02:33,510
읏차...

58
00:02:33,510 --> 00:02:36,239
음수일 때는 “ret -= a”

59
00:02:38,870 --> 00:02:45,459
양수일 때는 “ret += a”라고 합시다.

60
00:02:49,360 --> 00:02:52,020
보기에는 좀 이상하죠.

61
00:02:52,020 --> 00:02:55,690
근데, 뭐, 어떻나요? 자, 그럼 ret을 반환합시다.

62
00:02:55,690 --> 00:02:57,880
읏챠! 저장하고요.

63
00:02:57,880 --> 00:02:58,780
같은 값이 나오나 보죠.

64
00:02:58,780 --> 00:03:02,140
값이 같나요? 40

65
00:03:02,140 --> 00:03:04,270
펄풱트! 값이 같군요.

66
00:03:04,270 --> 00:03:05,770
좋아요. 멋지군요. 자 이제,

67
00:03:05,770 --> 00:03:08,110
음수로 해보죠.

68
00:03:08,110 --> 00:03:09,580
-10으로 하면 어떨까요. -40이 나올까요?

69
00:03:09,580 --> 00:03:13,330
-40이군요! 마법 같죠?

70
00:03:13,330 --> 00:03:14,740
이것은 반복 함수입니다.

71
00:03:14,740 --> 00:03:16,420
이 함수는 상태를 기억하지 않고(자신을 스스로 부르지 않고)

72
00:03:16,420 --> 00:03:17,290
그저 루프(반복문)만 돕니다.

73
00:03:17,290 --> 00:03:19,840
간단히 곱셈 계산만 하는 거죠.

74
00:03:19,840 --> 00:03:20,890
그것이 반복 함수입니다.

75
00:03:20,890 --> 00:03:22,410
이제 만약, 같은 일을 하고 싶지만

76
00:03:22,410 --> 00:03:24,550
“while”문을 쓰고 싶지 않다면 어떻게 해야 할까요.

77
00:03:24,550 --> 00:03:27,040
그러니까 재귀적으로 만들고 싶다면요.

78
00:03:27,040 --> 00:03:29,080
어떻게 만들어야 할까요? 일단 재귀 함수를 만들 때는

79
00:03:29,080 --> 00:03:31,720
어느 지점에서 반복을 그만두고 빠져나올 것인지를 알아야 합니다.

80
00:03:31,720 --> 00:03:33,430
그것을 첫 번째로 적습니다.

81
00:03:33,430 --> 00:03:34,750
함수를 호출할 때마다

82
00:03:34,750 --> 00:03:38,310
매번 변수 혹은 전달 인자의 값이 바뀝니다.

83
00:03:38,310 --> 00:03:40,270
그러므로 탈출할 지점이 생기지요.

84
00:03:40,270 --> 00:03:42,100
그것이 마지막으로 이 곱셈 함수를 부르는

85
00:03:42,100 --> 00:03:44,920
지점이 되겠죠.

86
00:03:44,920 --> 00:03:48,010
만약 “b == 0”이라고 적으면,

87
00:03:48,010 --> 00:03:50,770
이 조건에 맞을 때 재귀는 멈출 것입니다.

88
00:03:50,770 --> 00:03:55,080
간단히 말해, “return (0)”을 하죠.

89
00:03:55,080 --> 00:03:57,690
자, 이제 이렇게 적읍시다.

90
00:03:57,690 --> 00:04:01,020
만약 b가 0보다 작을 때는

91
00:04:01,020 --> 00:04:16,108
“-a + mul (a, b + 1)”을 반환하라.

92
00:04:16,108 --> 00:04:17,250
만약 작지 않다면

93
00:04:17,250 --> 00:04:18,899
(여기에 “else”를 써도 되지만 상관없습니다.)

94
00:04:18,899 --> 00:04:22,590
“a + mul (a, b - 1)”을 반환하라.

95
00:04:27,350 --> 00:04:33,510
지우고 지우고 지우고.. 이제 해봅시다.

96
00:04:33,510 --> 00:04:35,780
동작할까요? 동작합니다!

97
00:04:35,780 --> 00:04:38,610
자, 두 가지에 집중해 봅시다.

98
00:04:38,610 --> 00:04:40,830
그러니까

99
00:04:40,830 --> 00:04:42,870
처음으로 “mul”을 호출했을 때,

100
00:04:42,870 --> 00:04:46,410
“4”와 “-10”이 전달됩니다.

101
00:04:46,410 --> 00:04:48,720
a는 4고 b는 -10이죠.

102
00:04:48,720 --> 00:04:51,240
-10은 0과 같습니까? 아니죠. 그래서 0을 반환하지 않습니다.

103
00:04:51,240 --> 00:04:53,490
-10은 0보다 작습니까? 그렇죠.

104
00:04:53,490 --> 00:04:56,070
그러므로 “-a”, 그러니까 (-4) 그리고

105
00:04:56,070 --> 00:04:59,100
“mul”을 거쳐서 얻은 값을 더합니다.

106
00:04:59,100 --> 00:05:02,370
“mul”에 “b + 1”이라고 적었죠.

107
00:05:02,370 --> 00:05:05,690
그래서 -10은 -9로 바뀝니다.

108
00:05:05,690 --> 00:05:08,850
그다음에 다시 한번 돌죠.

109
00:05:08,850 --> 00:05:11,010
b는 -9고 여기로 돌아오면

110
00:05:11,010 --> 00:05:12,990
-4 더하기 어쩌구저쩌구…

111
00:05:12,990 --> 00:05:14,880
뭐가 어떻게 돌아가는지 이제 대충 감이 오죠?

112
00:05:14,880 --> 00:05:16,949
그러니까 끝에 가서는

113
00:05:16,949 --> 00:05:18,360
b가 0과 같아지겠죠.

114
00:05:18,360 --> 00:05:20,580
그러면 “return (0)”을 하겠죠.

115
00:05:20,580 --> 00:05:21,840
이제 0이 있고 -4가 있으니까

116
00:05:21,840 --> 00:05:24,960
-4를 반환합니다.

117
00:05:24,960 --> 00:05:26,100
이전의 함수, 그러니까 이 함수의 반환 값을

118
00:05:26,100 --> 00:05:27,930
기다리고 있던 함수는 -4의 값을 받습니다.

119
00:05:27,930 --> 00:05:29,310
-4 더하기 -4는 -8입니다.

120
00:05:29,310 --> 00:05:31,860
이제 그 이전의 함수는 -8을 받고요.

121
00:05:31,860 --> 00:05:33,780
-8 더하기 -4는 -12입니다. 이전 함수는 -16...

122
00:05:33,780 --> 00:05:36,240
이렇게 저렇게.. 10번을 하고, 최종적으로

123
00:05:36,240 --> 00:05:38,910
결과값을 받겠죠.

124
00:05:38,910 --> 00:05:40,500
무슨 일이 어떻게 일어났는지 알겠나요?

125
00:05:40,500 --> 00:05:44,490
매번 계산해야 하는 새로운 컨텍스트가 생겼습니다.

126
00:05:44,490 --> 00:05:51,990
하지만 4 곱하기 -10을 하려면

127
00:05:51,990 --> 00:05:53,310
(이 곱셈 시스템은 좀 우스꽝스럽지만,

128
00:05:53,310 --> 00:05:55,560
곱하기를 쓰지 않으려고 하니 이렇게 나왔네요)

129
00:05:55,560 --> 00:05:57,660
어쨌든, 먼저, 4 곱하기 -9를 계산해야 합니다.

130
00:05:57,660 --> 00:06:02,729
그래야 4를 10번째로 더할 수 있으니까요.

131
00:06:02,729 --> 00:06:05,550
먼저 9번 더했어야 10번째로 더할 수 있지요.

132
00:06:05,550 --> 00:06:07,560
9번 더하려면

133
00:06:07,560 --> 00:06:09,120
그 전에 8번 더했어야 하고요.

134
00:06:09,120 --> 00:06:13,889
8번 더하려면 그 전에 7번 더했어야 하죠. 그렇게 계속 가죠.

135
00:06:13,889 --> 00:06:15,690
그러니 재귀는 매우 파워풀한 도구입니다.

136
00:06:15,690 --> 00:06:19,560
문제를 여러 단계로 나누어서

137
00:06:19,560 --> 00:06:22,860
N 레벨의 문제를 풀려면

138
00:06:22,860 --> 00:06:26,039
N - 1레벨의 문제를 풀어야 하고요.

139
00:06:26,039 --> 00:06:27,180
N - 1레벨의 문제를 풀려면

140
00:06:27,180 --> 00:06:28,740
그 밑의 문제를 풀어야 하죠. 그렇게 계속 내려가다가

141
00:06:28,740 --> 00:06:29,820
주로 0레벨이나 1레벨쯤에

142
00:06:29,820 --> 00:06:31,860
특별한 케이스가 나옵니다.

143
00:06:31,860 --> 00:06:34,770
이것이 재귀의 사용 방법입니다. 다시 정리하면,

144
00:06:34,770 --> 00:06:39,330
전달 인자를 바꾸면서 같은 함수를 반복적으로 호출합니다.

145
00:06:39,330 --> 00:06:41,009
그다음, 함수가 반환하는 값을 가지고

146
00:06:41,009 --> 00:06:44,729
현재 문제를 푸는 거죠.

147
00:06:44,729 --> 00:06:46,380
N 레벨의 문제를 풀기 위해서

148
00:06:46,380 --> 00:06:49,500
N - 1레벨 함수를 호출하는 식이죠. 네, 그렇습니다.

149
00:06:49,500 --> 00:06:52,009
그런 겁니다!!!
<< translated by mseo, inyang, chelee, mki, yeslee and ji-kim :) >>
