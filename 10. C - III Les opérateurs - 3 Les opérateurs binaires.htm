1
00:00:00,069 --> 00:00:02,249
비트 연산자에 대해 배워봅시다. 

2
00:00:02,319 --> 00:00:08,099
변수에 값을 대입하는 기본 연산자 +, -, / 등과는 달리  

3
00:00:08,470 --> 00:00:15,210
비트 연산자는 변수가 가진 비트들을 직접 다룰 수 있습니다.

4
00:00:15,210 --> 00:00:17,699
비트란, 변수를 만드는 0과 1들을 말합니다.

5
00:00:18,480 --> 00:00:23,820
준비한 예제들을 보도록 합시다.

6
00:00:24,489 --> 00:00:26,348
char형 변수 c를 선언하고 12로 값을 주었습니다.

7
00:00:26,349 --> 00:00:34,219
char형 변수의 비트 값을 보여주는 함수를 이용해 c 변수 안의 8자리 비트 값을 봅시다.

9
00:00:34,420 --> 00:00:38,370
짜잔. 12는 0000 1100과 같습니다. 

10
00:00:39,280 --> 00:00:44,000
만약 여기를 3으로 바꾼다면

11
00:00:44,000 --> 00:00:47,000
오른쪽 두 개가 1로 이루어진 비트 값을 볼 수 있습니다.

12
00:00:47,000 --> 00:00:51,000
만약 4로 바꾸면, 결과가 나옵니다. 

13
00:00:51,000 --> 00:00:55,500
3에 1을 더하면, 여기가 0이 되고 그 다음 부분도 0이 되고, 그 다음 부분은 1이 됩니다.

14
00:00:55,659 --> 00:00:58,978
그렇게 결과 값이 나왔습니다.

15
00:01:00,609 --> 00:01:03,809
잠시 상기하자면, -128은

16
00:01:07,450 --> 00:01:13,798
 가장 왼쪽 비트로 1을 가지고 있습니다. 왜냐하면 음수이기 때문입니다. 

17
00:01:16,618 --> 00:01:18,009
만약 -1을 넣는다면 결과값은 전부 1입니다. 

18
00:01:18,009 --> 00:01:22,379
char형은 부호를 가지고 있으므로 이런 식으로 동작합니다. 

19
00:01:23,438 --> 00:01:28,438
이제 존재하는 다른 연산자들을 봅시다. 

20
00:01:29,709 --> 00:01:35,158
이번엔 두 개의 변수를 사용하겠습니다. 

21
00:01:37,180 --> 00:01:44,639
변수 c2를 선언했습니다. c의 값인 12가 별로 흥미롭지 않군요.

22
00:01:46,299 --> 00:01:52,650
좀 더 흥미롭게 11로 바꿔주고 여기에는 6의 값을 줍니다.  

23
00:01:52,930 --> 00:01:54,160
짜잔

24
00:01:54,159 --> 00:01:59,069
공식을 더 잘 이해할 수 있도록 개행을 추가했습니다.

25
00:01:59,978 --> 00:02:03,388
여기에도 공식을 추가합니다.

26
00:02:04,930 --> 00:02:14,739
AND 연산자인 ‘&’부터 시작합시다. 연산자 ‘&’는 단순하기 때문이지요. 

27
00:02:14,740 --> 00:02:22,969
‘&’ 연산자는 비트를 하나하나씩 비교합니다. 결과값은, 만약 두 비트가 모두 1이면 1, 아니면 0이 됩니다.

28
00:02:24,849 --> 00:02:30,718
1과 0은 0이고, 1과 1은 1입니다.

29
00:02:31,120 --> 00:02:36,000
0과 1은 0이고, 1과 0은 0입니다. 

30
00:02:36,099 --> 00:02:38,849
AND 연산자는 이렇게 동작합니다.

31
00:02:39,489 --> 00:02:41,489
심플하죠?

32
00:02:42,219 --> 00:02:45,478
이제 다른 이진 연산자를 봅시다. OR 연산자는 ‘|’라고 씁니다.

33
00:02:46,689 --> 00:02:48,689
‘|’가 하나죠. 

34
00:02:48,699 --> 00:02:50,349
OR 연산자는 

35
00:02:50,349 --> 00:02:55,299
이렇게 동작합니다. 

36
00:02:55,300 --> 00:02:58,739
만약 두 비트 중에 1을 가진 비트가 하나라도 있다면, 

37
00:02:59,019 --> 00:03:01,979
결과값은 1이 됩니다. (1 | 1)은 1입니다.

38
00:03:02,620 --> 00:03:07,679
(0 | 1)은 1이고, (0 | 0)은 0입니다.

39
00:03:08,199 --> 00:03:10,199
이것이 OR 연산자입니다. 

40
00:03:10,239 --> 00:03:12,120
이렇게 연산자 두 개를 알아봤습니다. 

41
00:03:12,120 --> 00:03:15,689
세 번째 연산자는 좀 특별합니다.

42
00:03:16,209 --> 00:03:21,689
XOR이라고 불리우며 기호 ‘^’를 이용합니다. 

43
00:03:28,139 --> 00:03:30,559
XOR 연산자는

44
00:03:31,159 --> 00:03:36,199
두 비트 중 하나만 1이면 1이 되고, 아니면 0이 됩니다.

45
00:03:36,240 --> 00:03:46,700
(1 ^ 0)은 1, (1 ^ 1)은 0, (0 ^ 1)은 1, 그리고 (0 ^ 0)은 0이 됩니다.  

46
00:03:47,340 --> 00:03:53,420
그리하여 3가지 주요 비트 연산자를 봤습니다. 

47
00:03:54,000 --> 00:04:02,389
이제 이진수를 직접 다루는 단항 연산자를 봅시다. 단항 연산자인 부정 연산자는 ‘~’를 씁니다. 

48
00:04:04,680 --> 00:04:07,549
부정 연산자는 모든 비트를 반대로 바꿔줍니다. 

49
00:04:09,629 --> 00:04:11,808
결과를 보면,

50
00:04:12,990 --> 00:04:17,360
0이었던 비트는 1이 되고, 1이었던 비트는 0이 되었습니다.

51
00:04:17,730 --> 00:04:21,619
쉽죠? 단항 연산은 변수에서 바로 이루어집니다.

52
00:04:22,500 --> 00:04:29,689
이렇게 ‘~’를 써서 사용할 수 있습니다.

53
00:04:29,879 --> 00:04:33,980
부정 연산자로 변수의 비트를 뒤집을 수 있습니다. 

54
00:04:34,110 --> 00:04:37,699
부정 연산자를 다른 연산자와 혼동하면 안 됩니다. 바로 ‘!’ 연산자입니다. 

55
00:04:38,699 --> 00:04:42,588
‘!’ 연산자는 좀 특별합니다.  

56
00:04:43,490 --> 00:04:48,590
0이 아닌 다른 값이면, 결과는 0입니다. 

57
00:04:52,110 --> 00:04:54,199
참고로, 이 연산자는 비트 연산자가 아닙니다. 

58
00:04:56,790 --> 00:05:00,679
만약 변수가 0의 값을 가지고 있다면, 이 연산자는 0이 아닌 다른 값을 리턴합니다.

59
00:05:01,529 --> 00:05:08,719
여기에선 1이 나오지만, 그래야만 하도록 C에서 특별히 정의된 것은 아닙니다. 

60
00:05:09,209 --> 00:05:12,228
그저 0이 아닌 수를 리턴할 뿐입니다. 

61
00:05:12,449 --> 00:05:17,269
만약 0이 아닌 수를 넣었다면 0을 리턴할 것입니다. 매우 간단하죠. 

62
00:05:17,360 --> 00:05:22,310
하지만 이 경우 값이 언제나 1인지는 확신할 수 없습니다. 제 컴퓨터에서는 항상 1이지만 말입니다.

63
00:05:22,800 --> 00:05:25,189
컴파일러, OS 등과 같은 다양한 요소에 따라 결과값은 달라질 수 있습니다.

64
00:05:25,350 --> 00:05:28,549
어쨌거나 C에는 결과값이 항상 1이란 규범은 없습니다.  

65
00:05:29,069 --> 00:05:35,149
벌써 많은 연산자들을 보았습니다. 좀 더 복잡한 연산자들에 대해 배워봅시다. 

66
00:05:36,149 --> 00:05:40,698
이 연산자들은 비트의 위치를 움직일 수 있습니다.  

67
00:05:41,779 --> 00:05:43,779
어떻게 동작하는 걸까요?

68
00:05:44,480 --> 00:05:55,600
예시를 0 말고 11로 바꿔봅시다.

69
00:05:56,250 --> 00:05:59,209
자, 모든 비트들을 왼쪽으로 한 칸 이동시켰습니다. 

70
00:05:59,610 --> 00:06:04,340
왼쪽으로 이동시키고 남은 맨 오른쪽 칸에 0을 넣었습니다. 

71
00:06:04,339 --> 00:06:07,128
이제 두 칸을 움직여 봅시다.  

72
00:06:08,310 --> 00:06:10,310
점프 점프 

73
00:06:11,220 --> 00:06:15,200
2칸 움직였습니다. 이제 8칸 움직여 봅시다. 

74
00:06:15,720 --> 00:06:17,839
0이 8개 나왔군요. 

75
00:06:18,750 --> 00:06:20,750
값이 0이 되었습니다. 

76
00:06:21,240 --> 00:06:26,090
이것이 시프트 연산자입니다. 이 연산자는 비트를 왼쪽으로 한 칸씩 옮겨줍니다. 

77
00:06:27,000 --> 00:06:30,528
다음으로 알려드릴 연산자는 주의 깊게 보세요. 

78
00:06:31,290 --> 00:06:34,220
이번에는 비트를 오른쪽으로 한 칸씩 옮겨주는 연산자입니다.

79
00:06:35,699 --> 00:06:41,750
보시다시피 모든 게 오른쪽으로 옮겨졌습니다. 3으로 해볼까요.

80
00:06:43,980 --> 00:06:49,069
좋습니다. 4로 바꾸면 전부 0이 됩니다. 더 큰 숫자로 해도 0이 됩니다. 

81
00:06:49,949 --> 00:06:52,009
여기엔 좀 특별한 점이 있습니다.  

82
00:06:53,430 --> 00:06:55,910
예를 들어, c가 -11이라고 합시다. 

83
00:06:58,170 --> 00:07:01,160
음. 싫군요. -128로 합시다. 

84
00:07:02,370 --> 00:07:04,699
-128은, 잘 기억하고 계신지 모르겠지만, 

85
00:07:05,730 --> 00:07:09,110
1 다음에 0으로 채워져있습니다. 이것을 오른쪽으로 움직이겠습니다. 

86
00:07:10,319 --> 00:07:15,680
맨 왼쪽에 0 대신 1이 들어왔습니다. 이것이야말로 이 연산자의 특별함입니다. 

87
00:07:15,930 --> 00:07:21,019
양수나 음수와 같이 “부호”가 있는 숫자에 연산자를 대입했을 시,

88
00:07:21,120 --> 00:07:25,069
“부호”를 나타내는 맨 왼쪽 비트에 1이면 1, 0이면 0을 넣습니다.

89
00:07:25,620 --> 00:07:32,639
한 칸 이상을 움직여도 마찬가지 입니다. 1이면 1로, 

90
00:07:32,639 --> 00:07:34,329
0이면 0으로 채웁니다.

91
00:07:34,329 --> 00:07:37,979
간단하죠. 예시에서는 한 칸 움직였고 1로 채웠습니다.

92
00:07:38,199 --> 00:07:40,199
4로 하면 어떨지 봅시다. 

93
00:07:41,170 --> 00:07:43,829
4개의 1을 넣었군요. 역시 간단하죠. 

94
00:07:44,860 --> 00:07:50,280
만약 여기를 “unsigned”형으로 바꾸면  

95
00:07:52,540 --> 00:07:55,528
매우 흥미로운 결과를 보실텐데요.

96
00:07:57,279 --> 00:07:58,629
짜잔

97
00:07:58,629 --> 00:08:00,579
“unsigned”로 바꾸었더니 

98
00:08:00,579 --> 00:08:05,608
-128이란 값으로 시작했지만, -128의 unsigned는 128이므로  

99
00:08:05,860 --> 00:08:08,910
결국 128과 같습니다. 

100
00:08:09,370 --> 00:08:14,129
고로 -128과 같이 하나의 1과 나머지 0들로 표현됩니다.  

101
00:08:14,470 --> 00:08:19,350
다시 말하지만, signed와 unsigned는 메모리를 읽는 방식입니다.  

102
00:08:19,569 --> 00:08:22,618
그러므로 -128과 128은 unsigned의 눈엔 같습니다.  

103
00:08:23,050 --> 00:08:25,350
첫 비트는 음수나 양수를 나타내는 것이 아닌 그저 값의 일부분일 뿐입니다. 

104
00:08:25,600 --> 00:08:30,119
이 첫 비트는, 연산이 가능한 다른 비트들과 다를 바 없어졌습니다. 이 경우 128이지요. 

105
00:08:31,089 --> 00:08:35,668
그러므로 한 칸 움직였을 때, 이 비트는 더 이상 부호를 나타내는 비트가 아닙니다.

106
00:08:35,918 --> 00:08:41,727
값을 나타내는 비트입니다. 칸을 또 움직여 봅시다.

107
00:08:42,339 --> 00:08:45,599
여기 기호를 바꾸는 것을 깜빡했군요. 심각한 일은 아닙니다.  

108
00:08:46,480 → 00:08:53,429
칸을 움직이면 0이 추가됩니다. unsigned형이기 때문에 0과 함께 움직입니다.

109
00:08:53,500 --> 00:09:00,830
그러니까, unsigned형이기 때문에 첫 번째 비트가 1이든 0이든 상관 없이 0과 움직입니다. 

110
00:09:00,940 --> 00:09:06,900
자, 이제 C에 존재하는 비트 연산자 전부를 알게 되었습니다.  

111
00:09:07,440 --> 00:09:11,480
매우 유용하게 쓸 수 있을 겁니다. 

112
00:09:12,399 -->  00:09:19,600
플래그 혹은 메모리에 여유 공간을 만들 수 있죠. 직접 1과 0을 조작할 수도 있습니다.

113
00:09:19,600 --> 00:09:26,250
예를 들어, 8비트로 혹은 1 바이트의 char형 중 “boolean”을 사용하고 싶은데 

114
00:09:26,250 --> 00:09:29,940
C에는 boolean이 존재하지 않습니다.  

115
00:09:30,190 --> 00:09:32,190
그러므로 변수의 1과 0을 추출하기 위해선 연산자를 이용해야 합니다.  

116
00:09:33,179 --> 00:09:37,608
비트 연산자를 이용하면 char형이나 int형 같은 변수의 1과 0을 추출할 수 있습니다.  

117
00:09:38,039 --> 00:09:42,799
비트 연산자를 사용할 수 있는 변수들에는 char형, int형, long char형,

118
00:09:43,019 --> 00:09:48,197
long unsigned char형, long unsigned int형, short int형 등이 있습니다. 

119
00:09:48,629 --> 00:09:55,099
float형의 경우, 연산자를 사용할 순 있지만 1과 0이 int형과는 다른 것을 의미합니다. 

120
00:09:55,350 --> 00:10:00,740
그러므로 자신이 무슨 일을 하고 있는지 잘 알고 있지 않는 이상 사용을 권하지 않습니다. 

translated by inyang, chelee, mki, yeslee, mseo, and ji-kim  :)

