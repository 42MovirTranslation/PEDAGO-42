1
00:00:00,069 --> 00:00:04,048
환영합니다, 이 비디오에서는 Makefile로 할 수 있는 것들을
조금 더 자세히 볼 겁니다

2
00:00:04,870 --> 00:00:12,330
우선 아주 간단한 makefile로 시작해보죠
이 makefile은 main.c와 fct.c를 "hello"라는 바이너리로 컴파일합니다

3
00:00:12,849 --> 00:00:17,849
그리고 "hello" 규칙은 바이너리 파일이 이미 있는지를 확인할 겁니다

4
00:00:18,310 --> 00:00:21,750
먼저 NAME 변수에 우리 바이너리 파일의 이름을 줄 거예요

5
00:00:22,630 --> 00:00:27,090
이 NAME을 규칙의 이름과 컴파일할 바이너리 파일의 이름으로 사용할 겁니다

6
00:00:28,120 --> 00:00:30,720
그렇게 함으로써 아주 간단하게

7
00:00:31,980 --> 00:00:34,440
"hello"를 $(NAME)으로 대체할 수 있죠, 여기도 있네요

8
00:00:35,560 --> 00:00:37,480
우리가 만들 바이너리 파일과 그에 상응하는 규칙이 같으므로

9
00:00:37,480 --> 00:00:44,180
규칙의 결과로 만들어질 바이너리 파일 이름과 규칙 이름이 항상 같으리라는 것을

10
00:00:44,940 --> 00:00:47,620
확신할 수 있겠네요

11
00:00:49,380 --> 00:01:00,060
잠시 $(OBJS)로 돌아와 봅시다
의존 관계인 $(OBJS)는 "hello" 규칙을 위해 .o 파일들이 필요하다고 말해주는 겁니다

13
00:01:00,070 --> 00:01:03,100
makefile에는 이처럼 숨겨진 규칙이 있습니다

14
00:01:04,000 --> 00:01:11,060
"make"는 기본적으로 .c를 .o로 바꾸는 규칙을 포함하고 있습니다

15
00:01:12,100 --> 00:01:15,150
그리고 이 규칙은 알아서 실행되기 때문에 별도의 의존규칙이 없습니다

16
00:01:15,820 --> 00:01:17,820
대체로

17
00:01:18,070 --> 00:01:19,630
이 규칙은

18
00:01:19,630 --> 00:01:21,630
이 내용과 일치합니다

19
00:01:24,430 --> 00:01:29,189
즉, 이 규칙은 ${cc}로 지정된 컴파일러에 전달됩니다

20
00:01:29,500 --> 00:01:36,689
따라서, 우리가 ${CC}에 gcc, clang을 입력하는 것으로
컴파일러를 즉시 변경할 수 있습니다, 일단은 cc로 남겨놓겠습니다

21
00:01:38,500 --> 00:01:43,290
여기 $(CFLAGS)도 포함할 수 있죠
CFLAGS에게는 includes나 컴파일 flag들을 줄 수 있습니다

22
00:01:45,670 --> 00:01:47,670
예를 들면 -Wall

23
00:01:48,700 --> 00:01:51,360
-g 등등 말이죠

24
00:01:53,380 --> 00:01:55,380
그러면, Makefile은

25
00:01:55,780 --> 00:02:01,589
우리가 입력한 .c파일을 컴파일할 겁니다
여기서 .c 파일들로 대체되는 특수문자 ‘<’를 사용해 보죠

26
00:02:02,259 --> 00:02:07,379
컴파일러는 이를 이용하여 .o를 생성할 것이고
앞서 src에서 적었던 것과 같은 행동을

27
00:02:07,690 --> 00:02:11,889
다시 수행할 겁니다

28
00:02:12,980 --> 00:02:18,039
이 "<"를 가지고 우리는 .c를 .o로 대체할 겁니다

29
00:02:20,270 --> 00:02:24,939
여기서 우리는 .c를 .o로 바꾸는 숨겨진 규칙을 재정의했습니다

30
00:02:25,970 --> 00:02:29,259
똑같이 cc도 ${CC}로 변경해줍니다, 큰 이유는 없지만요

31
00:02:30,260 --> 00:02:36,700
일반적으로 우리의 바이너리 파일들을 변수로 정의하는 것은 좋은 방법입니다

32
00:02:39,110 --> 00:02:42,069
이제 "all"이라고 부르는 기본 규칙을 추가하겠습니다

33
00:02:42,620 --> 00:02:45,610
관습적으로 "make all"을 기본 규칙으로 사용하곤 합니다

34
00:02:46,190 --> 00:02:49,179
그리고 "all"은 단순히 ${NAME}만을 의존 관계로 가집니다

35
00:02:49,910 --> 00:02:56,169
all은 ${NAME}을 부르는 것 외에 특정한 행동을 하지 않습니다
이것이 all의 기본 동작이기 때문이죠

36
00:02:58,400 --> 00:03:00,400
좋습니다

37
00:03:01,010 --> 00:03:06,670
이제 "make all"을 하면, 아이고 여기 오타가 났군요

38
00:03:08,030 --> 00:03:10,030
"make all"을 하면

39
00:03:10,790 --> 00:03:13,209
make는 우리에게 다시 컴파일할 ${NAME}이 있다고 알려줍니다

40
00:03:14,420 --> 00:03:19,299
"hello" 말이죠
다만 "hello"는 이미 존재하는 파일이라 다시 컴파일할 필요가 없군요

41
00:03:20,180 --> 00:03:24,640
"all" 그 자체만으론 "make"나 "make hello"와 다를 바가 없습니다

42
00:03:25,130 --> 00:03:30,070
같은 규칙이거든요, 첫 번째 규칙을 실행하는 것이 기본값이고
모든 파일은 최신 상태이기 때문이죠

43
00:03:30,920 --> 00:03:35,500
만약 "hello"를 지우고 "make all"을 하면 ${NAME}이 "make all"에 의해 호출되고

44
00:03:36,980 --> 00:03:38,980
"hello" 파일이 컴파일됩니다

45
00:03:39,320 --> 00:03:43,899
그리고 여러분들은 "hello" 파일을 생성하기 위해
디렉토리 안에 .o 파일들이 만들어진 것을 보실 수 있습니다

46
00:03:44,540 --> 00:03:46,719
이번에는 "clean" 규칙을 만들어봅시다

47
00:03:47,720 --> 00:03:51,009
이 "clean" 규칙은 .o 파일들을 지우는 명령어입니다

48
00:03:52,160 --> 00:03:54,519
예를 들면 "rm ${OBJS}" 처럼 말이죠

49
00:03:57,320 --> 00:03:59,320
한 번 해봅시다

50
00:04:01,300 --> 00:04:06,160
좋아요, main.o, fct.o 파일을 지웠습니다
만약에 더 나아가서…

51
00:04:06,280 --> 00:04:09,180
이것보다 더 깔끔하게 파일을 정리할 수 있다면 어떨까요

52
00:04:09,680 --> 00:04:11,680
예를 들면 바이너리 파일까지 지우고 싶다면 말이죠

53
00:04:12,290 --> 00:04:15,519
"fclean" 규칙을 만들면 됩니다
일종의 강제성을 지닌 "clean"입니다

54
00:04:16,130 --> 00:04:20,499
이 규칙은 두 가지 명령을 수행해 주죠
먼저 "clean" 규칙을 다시 부르고

55
00:04:21,440 --> 00:04:23,440
이어 "rm"과 "rm"으로 지울 바이너리 파일

56
00:04:24,190 --> 00:04:26,249
즉 ${NAME}을 추가합니다

57
00:04:28,210 --> 00:04:30,900
좋습니다, "rm"이 추가된 의존 규칙이 만들어졌습니다

58
00:04:32,860 --> 00:04:35,550
한번 실행시켜보죠
먼저 디렉토리에 무슨 파일들이 있는지 보여드릴게요

59
00:04:36,910 --> 00:04:40,859
이제 "make fclean"으로 .o 파일들과 "hello" 파일을 지울 겁니다

60
00:04:42,010 --> 00:04:47,039
작동하지 않네요, 무슨 일이 일어났는지 봅시다

61
00:04:47,740 --> 00:04:52,140
"fclean"이 말합니다: "clean" 규칙을 실행해야 하는데 거기엔 의존 규칙이 없어"

62
00:04:53,200 --> 00:04:55,619
fclean은 .o 파일들을 "rm"하려 시도했는데

63
00:04:56,140 --> 00:04:58,140
우선 .o 파일들을 "rm"하는 명령은

64
00:04:58,240 --> 00:05:01,920
rm "*.o" 명령과는 다릅니다, 지워야 할 .o 의 목록이 정의되어 있기 때문이죠

65
00:05:02,100 --> 00:05:05,360
다른 파일을 지워버릴 걱정은 없어서 좋네요

66
00:05:06,070 --> 00:05:10,469
다만 main.o, fct.o은 이전 단계에서 지워버렸기 때문에
더는 파일이 존재하지 않는다는 문제가 발생했습니다

67
00:05:10,960 --> 00:05:16,769
여러분은 보지 못하셨겠지만 사실 직전에 저는 .o 파일들을 지웠습니다
그래서 오류가 발생하였고 "make"가 멈춘 거예요

68
00:05:17,080 --> 00:05:25,649
"make"가 멈췄기 때문에 여기서부터 더 진행되지 않았죠
그래서 rm $(NAME)은 실행되지 않을 겁니다

70
00:05:26,230 --> 00:05:31,830
이 문제는 변수 "RM"을 선언하고 "rm" 명령어를 간단하게 수정해 넣는 것으로
해결할 수 있습니다

71
00:05:32,440 --> 00:05:37,499
"rm" 명령과 -f 옵션을 사용하여 "RM" 변수를 이렇게 정의합니다

72
00:05:38,050 --> 00:05:40,050
그리고 clean 규칙으로 돌아와서

73
00:05:41,110 --> 00:05:43,110
rm을 $(RM)으로 바꿔줍니다

74
00:05:47,569 --> 00:05:52,729
이제 매번 "rm -f"를 실행할 거예요
만약 제가 여기서 다시 시작한다면 "make fclean"은 .o 파일들을 "rm -f" 할 겁니다

75
00:05:52,860 --> 00:05:56,899
.o 파일들은 존재하지 않지만 이젠 상관없습니다
그리고 "hello"도 "rm -f"합니다

76
00:05:59,159 --> 00:06:01,159
짜잔, 더 간단해졌습니다

77
00:06:01,949 --> 00:06:07,968
이번에는 강제로 다시 컴파일하는 규칙까지 만들 수 있습니다
말하자면 제가 여기서 make를 실행하여 다시 컴파일을 원할 때가 있겠지요

78
00:06:08,249 --> 00:06:13,278
파일이 실행되지 않거나 오래되었기 때문이거나 등등 같은 경우에 말이에요

79
00:06:13,919 --> 00:06:19,308
"fclean"과 "all" 규칙을 호출하는 "re" 규칙을 만들면 됩니다

80
00:06:21,419 --> 00:06:28,398
"make re"를 하면 강제로 모든 것을 지우고 처음부터 다시 컴파일해 줍니다

81
00:06:29,940 --> 00:06:33,120
여기까지 잘 따라오셨다면 지금부터 주목하세요

82
00:06:34,560 --> 00:06:38,660
마지막으로 규칙 이름과 파일 이름이 같을 때 생기는 문제를 알아봅시다

83
00:06:39,560 --> 00:06:41,560
"make hello"를 실행하면

84
00:06:42,400 --> 00:06:45,760
"hello" 규칙은 실행되지 않습니다, "hello"가 이미 존재하기 때문이죠

85
00:06:46,640 --> 00:06:51,980
만약 all 파일이 디렉토리 안에 있다면 어떤 일이 일어날까요

87
00:06:53,249 --> 00:06:56,989
당연히 all은 실행되지 않습니다

88
00:07:00,149 --> 00:07:04,819
"clean" 또한 최신 파일이니 "make clean" 명령을 실행할 필요가 없어집니다

89
00:07:05,759 --> 00:07:10,308
이미 디렉토리에 "clean" 파일이 있으니 이 규칙에 대해 신경 쓸 필요가 없는 거죠

90
00:07:11,039 --> 00:07:13,039
이것 때문에 우리는 반드시 Makefile에게

91
00:07:13,589 --> 00:07:16,458
특정 파일들을 알려주어야 합니다

92
00:07:17,669 --> 00:07:19,669
그게 뭐냐면…

93
00:07:20,399 --> 00:07:21,629
거기 없는…

94
00:07:21,629 --> 00:07:29,299
미안합니다, 파일로서 해석하면 안되는
"all" "clean" "fclean" 규칙들을 알려줘야 합니다

95
00:07:31,949 --> 00:07:33,949
"re"도 마찬가지겠죠

96
00:07:35,680 --> 00:07:43,669
이제 여기서 "make clean"을 하면 "clean" 규칙은
"clean" 파일의 존재 여부를 더는 신경 쓰지 않고 실행될 겁니다

98
00:07:43,669 --> 00:07:46,839
지금까지 Makefile의 심화 내용을 함께 알아보았습니다
<< translated by inyang, chelee, mki and yeslee :) >>
