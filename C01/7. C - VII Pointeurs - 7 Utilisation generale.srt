1
00:00:00,000 --> 00:00:03,659
이 비디오에서는 포인터의 두 가지 용도에 대해 알아볼 겁니다.

2
00:00:03,659 --> 00:00:06,029
포인터를 이해하는 데에 중요한 두 가지 요소는 다음과 같습니다.

3
00:00:06,029 --> 00:00:09,150
그것을 어떻게 사용할 것인지, 그리고 널포인터가 무엇인지.
이게 바로 중요한 두 가지 요소입니다.

4
00:00:09,150 --> 00:00:12,450
지금부터 보여드릴 겁니다.
첫 번째, 이걸 어떻게 사용하는가?

5
00:00:12,450 --> 00:00:16,049
가장 고전적으로 사용되는 예시를 통해 보여드릴게요.

6
00:00:16,049 --> 00:00:20,490
int a가 있습니다.

7
00:00:20,490 --> 00:00:24,269
42의 값을 가지고 있죠. (a = 42)

8
00:00:24,269 --> 00:00:28,410
그리고 fct함수에 인자 a를 호출해줄게요.

9
00:00:28,410 --> 00:00:32,668
a = a + 42라고 해두었습니다.
그리고 이걸 화면에 출력해볼게요.

10
00:00:32,668 --> 00:00:35,219
a의 값을 출력해봅시다. (printf ~)
제 main은 오류를 출력하진 않을 거예요.

11
00:00:35,219 --> 00:00:38,670
컴파일했을 때, 무슨 일이 일어날까요?

12
00:00:38,670 --> 00:00:42,570
42가 나오고 84가 출력될까요?
아니면 42가 나오고 또 42가 출력될까요?

13
00:00:42,570 --> 00:00:46,760
여러분이 생각할 시간을 2~3초 드리겠습니다.

14
00:00:46,760 --> 00:00:53,760
함수는 복사본을 쓴다는 사실을 기억하십니까?
짠, 42가 더블~ 쨘쨘쨘, 더블!

15
00:00:53,760 --> 00:00:58,129
왜 이럴까요. 단순합니다.
제가 ‘a’를 main에서 정의했기 때문입니다.

16
00:00:58,129 --> 00:01:03,510
여기에 정의했죠. 그리고 42라는 값을 줬습니다.

17
00:01:03,510 --> 00:01:06,960
42의 값을 처음 표시하고서,
fct에 ‘a’라는 값을 보냈습니다.

18
00:01:06,960 --> 00:01:12,330
하지만 정확하게는 ‘a’를 보낸 것이 아닙니다.
우리는 ‘a’의 값을 가진 것을 복사해서 보냈습니다.

19
00:01:12,330 --> 00:01:17,130
그래서 이곳에 있는 ‘a’ (fct (int a)의 a)는
메인의 ‘a’와는 다른 새로운 ‘a’입니다.

20
00:01:17,130 --> 00:01:22,740
새로운 ‘a’도 42의 값을 가지고 있죠.
이 ‘a’의 값을 확인해보죠.

21
00:01:22,740 --> 00:01:26,729
‘a’는 42였으니 42 + 42
그리고 그 값을 여기 ‘a’에 넣었습니다.

22
00:01:26,729 --> 00:01:32,430
실제로 여기서의 ‘a’ (fct 안에서 계산된 a)는 84의 값을 가질 겁니다.
하지만 함수가 종료했을 때, 더 이상 수정된 ‘a’가 아닙니다.

23
00:01:32,430 --> 00:01:36,000
이곳에 왔을 때 (main), 그리고 다시 ‘a’를 확인하면

24
00:01:36,000 --> 00:01:39,299
이 ‘a’는 수정되지 않았습니다.
이건 여전히 42입니다.

25
00:01:39,299 --> 00:01:43,049
그래서 이건 여전히 42라고 출력됩니다.
main 함수에서 fct함수를 이용하여

26
00:01:43,049 --> 00:01:48,630
‘a’의 값을 수정하고 싶어졌습니다.

27
00:01:48,630 --> 00:01:52,770
함수에 전달할 때는 복사본이 전달되어야 하고
그 값을 또 복사해서 보낼 수 없기 때문에,

28
00:01:52,770 --> 00:01:55,140
그 값을 복사하지 않으면 효과가 없습니다.

29
00:01:55,140 --> 00:01:57,450
‘a’를 찾을 수 있게 하는 것을 복사해야 합니다.
그리고 우린 막 ‘a’를 찾을 수 있는 방법을 배웠습니다.

30
00:01:57,450 --> 00:02:00,719
예시를 들어볼게요.

31
00:02:00,719 --> 00:02:04,860
주소를 복사해주고, 이렇게…
그래서, 여기에 ‘a’의 포인터 (*a)를 넣어줬습니다.

32
00:02:04,860 --> 00:02:09,919
일반적으로… 이건 작동하지 않을 거예요!

33
00:02:09,919 --> 00:02:12,120
우리는 몇 가지 부분을 까먹었습니다.

34
00:02:12,120 --> 00:02:16,349
좋은 아이디어가 있습니다.
우리는 ‘a’의 주솟값을 복사할 겁니다.

35
00:02:16,349 --> 00:02:21,690
a 포인터를 전달했는데, 여기는…
제가 뭘 수정했나요? 여기 ‘a’는 int형 포인터입니다.

36
00:02:21,690 --> 00:02:26,879
그래서 a + 42를 하면, 주솟값에 42를 더한 것과 같아집니다.

37
00:02:26,879 --> 00:02:30,420
(int 사이즈만큼 42번… 포인터의 산술과 관련된 이야기입니다)

38
00:02:30,420 --> 00:02:34,829
그리고 그걸 ‘a’에 넣었습니다.
실제로, a를 수정하기는 하였지만

39
00:02:34,829 --> 00:02:39,390
main의 a는 수정하지 않았습니다.
역참조를 사용해야 합니다.

40
00:02:39,390 --> 00:02:45,390
여기에 *를 넣었습니다.
이 줄에서, ‘a’가 가리키는 값을 보고 싶다고 이야기합니다.

41
00:02:45,390 --> 00:02:48,739
지금 말하는 ‘a’는 main의 ‘a’입니다.

42
00:02:48,739 --> 00:02:53,280
그래서, fct에서 42 + 42 해서

43
00:02:53,280 --> 00:02:58,019
그 값을 ‘* a’에 넣어줍니다.
다시 한번 말하지만, main의 ‘a’에 넣는 겁니다.

44
00:02:58,019 --> 00:03:03,359
이제 42와 84를 출력할 겁니다.

45
00:03:03,359 --> 00:03:07,349
이것이 아주 고전적인 포인터 사용법입니다.

46
00:03:07,349 --> 00:03:10,230
예시에서 보았듯, 스택에 있는

47
00:03:10,230 --> 00:03:13,349
다른 함수에 있는 값을 바꿀 수 있도록 해줍니다.

48
00:03:13,349 --> 00:03:15,959
언젠가 여러분이 malloc이나 heap과 같은 내용이 있는 비디오를 볼 때

49
00:03:15,959 --> 00:03:19,049
여러분은 스택에 무언가를 할당할 수 없을 겁니다.

50
00:03:19,049 --> 00:03:21,810
두세 개의 매개 변수를 수정하고 싶을 때

51
00:03:21,810 --> 00:03:24,540
리턴을 하지 않고도 다른 함수에서
무언가를 수정할 수 있는 유일한 방법은

52
00:03:24,540 --> 00:03:28,980
포인터를 사용하는 방법뿐입니다.

53
00:03:28,980 --> 00:03:30,299
실제 사례들을 조금 더 보여줄게요.

54
00:03:30,299 --> 00:03:33,510
진짜 실제 사례는 아니지만,
고전적인 포인터의 사용법입니다.

55
00:03:33,510 --> 00:03:41,359
우리는 포인터에 대해 알아야 합니다.
예를 들어, 만약 ptr = 42를 쓴다면...

56
00:03:41,359 --> 00:03:47,250
어떤 일이 벌어질까요.

57
00:03:47,250 --> 00:03:56,849
조금 지워볼게요…
경고를 주네요. 이렇게 말하고 있어요.

58
00:03:56,849 --> 00:04:00,569
야, 마! 너 int 값 넣을라고 하네.
그리고 int 포인터에는 임의의 값이 있어.

59
00:04:00,569 --> 00:04:03,750
그거 int로 바꿀 수 있어! 하지만 실제로 int 포인터는 주소입니다.

60
00:04:03,750 --> 00:04:06,299
42번의 주소 안에 있는 것을 보고 싶어!

61
00:04:06,299 --> 00:04:10,379
하지만 실제로 어디에 값을 넣고 있는지 모릅니다.

62
00:04:10,379 --> 00:04:13,709
그렇기 때문에 주소가 위험하다고 나타냅니다.

63
00:04:13,709 --> 00:04:16,649
그래서 컴파일러는 경고합니다.

64
00:04:16,649 --> 00:04:19,948
지금 하는 게 별로 좋은 짓이 아니라고요.
하지만 아주 특별한 케이스가 있죠.

65
00:04:19,949 --> 00:04:29,610
0을 넣는다면, 어떤 에러도 등장하지 않죠.

66
00:04:29,610 --> 00:04:33,060
왜냐면 우리는 0에 아무것도 넣을 수 없기 때문입니다.

67
00:04:33,060 --> 00:04:35,190
당신의 프로그램은 항상 0에 아무것도 가지고 있지 않을 겁니다.

68
00:04:35,190 --> 00:04:40,560
다음과 같은 규칙이 있습니다.
포인터의 값이 0이면,

69
00:04:40,560 --> 00:04:43,530
이걸 null 포인터라고 부르고

70
00:04:43,530 --> 00:04:46,440
이 포인터는 아무것도 가리키고 있지 않습니다.
많은 경우에 유용한 것을 볼 수 있을 겁니다.

71
00:04:46,440 --> 00:04:50,009
지금 이야기하진 않을 거예요.
하지만 예를 들어드릴게요.

72
00:04:50,009 --> 00:04:54,720
만약 포인터가 아주 많은 상황에서

73
00:04:54,720 --> 00:04:57,960
어떤 포인터가 어떤 요소를 가리키고,
어떤 것은 가리키고 있지 않은지 알 수 있습니다.

74
00:04:57,960 --> 00:05:01,259
0을 가리키고 있는 것들은
아직 제대로 된 주소를 가리키지 않고 있습니다

75
00:05:01,259 --> 00:05:04,169
제대로 된 주소는 우리가 가서 볼 수 있는 주소입니다.

76
00:05:04,169 --> 00:05:07,800
이건 할당되지 않은 포인터와 

77
00:05:07,800 --> 00:05:11,190
할당된 포인터를 구별하는 좋은 방법입니다.

78
00:05:11,190 --> 00:05:14,340
이 포인터에 주소가 할당되었느냐 아니냐로 구별합니다.

79
00:05:14,340 --> 00:05:17,669
그래서, 우리는 포인터를 사용하는 아주 고전적인 예시들을 보았습니다.

80
00:05:17,669 --> 00:05:21,599
다른 함수에 있는 값을 수정하기 위해
주소를 받아오는 방법.

81
00:05:21,599 --> 00:05:25,289
그리고 또 다른 중요한 방법인
값이 0인 포인터.

82
00:05:25,289 --> 00:05:27,990
그 어떤 것도 주소 0에는 없을 것이기 때문에

83
00:05:27,990 --> 00:05:30,780
우리는 주소가 0인 포인터를 사용할 수 있을 겁니다.

84
00:05:30,780 --> 00:05:33,719
아직 아무것도 가리키고 있는 것이 없는 포인터지요.

85
00:05:33,719 --> 00:05:36,719
널포인터가 아무것도 가리키지 않는다고 종종 이야기할 겁니다.

86
00:05:36,719 --> 00:05:42,259
실제로는 0을 가리키지만,
하지만 거기엔 아무것도 없습니다.
<< translated by inyang, ji-kim, yeslee, mki and mseo :) >>
