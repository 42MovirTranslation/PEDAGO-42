1
00:00:00,000 --> 00:00:03,480
이번 영상은 배열에 대한 내용입니다

2
00:00:03,480 --> 00:00:06,839
배열과 포인터는 아주 밀접한 관계가 있습니다
여러분도 곧 확인하실 수 있을 겁니다

3
00:00:06,839 --> 00:00:09,620
말로 설명하는 것보다 예제를 보시는 게 이해하기 더 좋을 테니까요

4
00:00:09,620 --> 00:00:14,219
예시로 3개의 요소를 가진 배열을 가지고 시작합시다

5
00:00:14,219 --> 00:00:16,949
그리고 배열의 이름을 tab이라 부릅시다

6
00:00:16,949 --> 00:00:20,100
지금까지는 tab[0], tab[1], tab[2]와 같이 사용했습니다

7
00:00:20,100 --> 00:00:22,859
가끔 [ ]을 넣는 것을 잊어버릴 때마다 오류가 발생했겠지만

8
00:00:22,859 --> 00:00:25,710
에러가 왜 발생했는지 완벽히 이해할 수 없었을 겁니다

9
00:00:25,710 --> 00:00:29,490
왜냐하면 아직 포인터를 보시지 않았기 때문입니다

10
00:00:29,490 --> 00:00:35,250
tab[3]이라고 코드를 작성한다는 것은 프로그램에게

11
00:00:35,250 --> 00:00:38,879
스택 메모리 상에 int 공간을 3개 할당하라고 말하는 것과 같습니다

12
00:00:38,879 --> 00:00:41,600
그래서 첫 번째, 두 번째, 세 번째 int를 가지게 됩니다

13
00:00:41,600 --> 00:00:47,670
tab은 (개념적으로 말하면) 첫 번째 int의 주소를 가지고 있는
int형 포인터입니다

14
00:00:47,670 --> 00:00:52,230
printf의 %p를 사용해서 보여드리겠습니다

15
00:00:52,230 --> 00:00:58,440
이제 tab의 주소를 볼 수 있습니다, 단지…

16
00:00:58,440 --> 00:01:01,920
아닙니다, 바로 "int *ptr"이 어떻게 동작하는지 보여 드리죠

17
00:01:01,920 --> 00:01:07,140
예를 들어, tab을 ptr에 넣으면

18
00:01:07,140 --> 00:01:11,549
잘 동작할까요? 짠~ 동작합니다!

19
00:01:11,549 --> 00:01:15,509
아무런 컴파일 오류도 없었습니다

20
00:01:15,509 --> 00:01:19,229
왜냐하면 tab은 가상의 int형 포인터로 스택 메모리상에는 존재하지 않습니다

21
00:01:19,229 --> 00:01:22,470
int형 요소 3개를 선언했을 뿐 int형 포인터로 선언하지 않았습니다

22
00:01:22,470 --> 00:01:26,180
그러나 컴파일러는 "tab"이 스택 메모리에 있는 세 개의 요소 중

23
00:01:26,180 --> 00:01:30,990
첫 번째 요소의 주소 명이라는 것을 압니다, 이게 다에요!

24
00:01:30,990 --> 00:01:34,049
프로그램 관점에서 컴파일이 끝나고 난 뒤에는

25
00:01:34,049 --> 00:01:37,549
tab이 존재하지 않습니다, 그 증거로

26
00:01:37,549 --> 00:01:44,430
int로 선언된 "a"의 주소를 "tab"에 넣을 수 없다는 것을 보실 수 있습니다

27
00:01:44,430 --> 00:01:47,939
이렇게 코드를 작성하면 에러를 확인할 수 있습니다, 짜잔!

28
00:01:47,939 --> 00:01:52,770
컴파일러는 "tab"에 값을 바로 할당할 수 없다고 말해줍니다

29
00:01:52,770 --> 00:01:55,049
왜냐하면 가상의 tab은 존재하지 않기 때문이죠

30
00:01:55,049 --> 00:01:59,640
tab은 단지 배열의 첫 번째 요소가 어디인지 알고 있는 기준점일 뿐입니다

31
00:01:59,640 --> 00:02:03,360
이것이 정적 배열을 만들 때 이해해야 하는 첫 번째 핵심입니다

32
00:02:03,360 --> 00:02:07,229
결국 스택 메모리에 원하는 만큼 많은 요소를 넣을 수 있고

33
00:02:07,229 --> 00:02:12,239
배열의 이름은 배열 요소와 같은 포인터 역할을 합니다, 이게 전부에요!

34
00:02:12,239 --> 00:02:16,140
이것이 첫 번째 중요한 점입니다, 두 번째로 중요한 점은

35
00:02:16,140 --> 00:02:19,140
방금 보았듯이 tab은 int형 포인터입니다

36
00:02:19,140 --> 00:02:23,640
tab도 포인터처럼 연산해서 사용할 수 있을까요?

37
00:02:23,640 --> 00:02:26,970
지금은 주소 안에 무엇이 있는지 보기 위해 ptr[0]을 사용했습니다

38
00:02:26,970 --> 00:02:29,730
좀 더 정확히 배열의 첫 번째 요소에

39
00:02:29,730 --> 00:02:33,330
무엇이 있는지 보기 위해

40
00:02:33,330 --> 00:02:36,680
printf에 %d\n과 *tab을 넣어줍시다

41
00:02:36,680 --> 00:02:41,190
첫 번째 원소를 확인할 거니까 tab[0]에 478을 넣어주고

42
00:02:41,190 --> 00:02:50,760
컴파일하면 478이 출력됩니다

43
00:02:50,760 --> 00:02:54,989
이전에 포인터의 연산을 공부했었죠, 만약 tab[1]에 145를 넣고

44
00:02:54,989 --> 00:03:03,870
[]를 사용하지 않고 tab[1]에 접근해 볼게요

45
00:03:03,870 --> 00:03:10,260
*tab은 첫 번째 요소를 가리킵니다

46
00:03:10,260 --> 00:03:13,440
*tab은 tab이 가리키는 곳에 무엇이 있는지 보겠죠

47
00:03:13,440 --> 00:03:20,390
그러므로 tab + 1은 두 번째 int형 요소가 되겠네요

48
00:03:21,200 --> 00:03:24,870
tab은 첫 번째 요소의 주소이고

49
00:03:24,870 --> 00:03:28,049
+1을 하면 int 크기만큼 이동해서

50
00:03:28,049 --> 00:03:30,390
배열의 두 번째 요소에 위치할 것이므로 *을 붙여주면…

51
00:03:30,390 --> 00:03:37,100
뭐가 들어 있는지 봅시다, 동작하나요? 동작합니다!

52
00:03:37,100 --> 00:03:45,450
tab[1]과 *(tab + 1)이 같은 것이라는 걸 알았습니다

53
00:03:45,450 --> 00:03:55,609
같은 방법으로 tab[n]을 *(tab + n)으로 바꿀 수 있습니다

54
00:03:55,609 --> 00:03:58,709
둘은 같은 값을 가리킵니다! 완벽히 동일합니다

55
00:03:58,709 --> 00:04:01,620
사실 [ ]는 자동으로 일련의 연산을 수행합니다

56
00:04:01,620 --> 00:04:06,270
어려워 하실까봐 이전에 알려드리지 않았던 것입니다

57
00:04:06,270 --> 00:04:08,150
이제는 2차원 배열에 대해 알아보겠습니다

58
00:04:08,150 --> 00:04:11,910
기존의 배열과 함께

59
00:04:11,910 --> 00:04:18,510
두 개의 요소를 가지고 있는 포인터 배열을 상상해봅시다

60
00:04:18,510 --> 00:04:21,930
새로 선언한 배열은 포인터 배열임을 확실히 해 둘게요

61
00:04:21,930 --> 00:04:26,280
tab[1]을 tab2[1]로 바꾸고

62
00:04:26,280 --> 00:04:31,020
tab2[1] = tab이라고 하면 동작할까요?

63
00:04:31,020 --> 00:04:35,040
아주 좋은 질문입니다! tab의 데이터 타입은 뭐죠?

64
00:04:35,040 --> 00:04:39,090
int형 포인터입니다, 그리고 tab2는 int형 포인터의 포인터입니다

65
00:04:39,090 --> 00:04:41,250
그러므로 tab2[1]은 int형 포인터가 되겠네요

66
00:04:41,250 --> 00:04:45,090
양쪽에 알맞은 type을 넣어 주었으므로

67
00:04:45,090 --> 00:04:50,610
잘 동작할 겁니다… 잘 동작하는지 어디 봅시다!

68
00:04:50,610 --> 00:04:57,139
이렇게 tab + 2를 넣어서… 실행하면…  문제가 생겼네요

69
00:04:57,139 --> 00:05:01,910
컴파일러가 말하는 오류는…

70
00:05:01,910 --> 00:05:04,100
아! 2를 넣는 것을 잊었네요

71
00:05:04,100 --> 00:05:09,890
미안합니다, 2를 잊어버렸어요… 완벽합니다!

72
00:05:09,890 --> 00:05:14,300
컴파일도 동작도 잘 되는군요!

73
00:05:14,300 --> 00:05:18,560
tab2[1] = tab은 올바른 문장입니다

74
00:05:18,560 --> 00:05:22,520
이번에는 tab[2]을 수정하고 싶습니다

75
00:05:22,520 --> 00:05:26,600
예를 들어 tab2[1][2] = 18이라고 하면

76
00:05:26,600 --> 00:05:30,740
전에 했던 것처럼 145 대신 18이 출력됩니다

77
00:05:30,740 --> 00:05:33,580
조금 전에 [ ] 괄호를 쓰는 것은

78
00:05:33,580 --> 00:05:39,920
tab + n과 같다고 했습니다

79
00:05:39,920 --> 00:05:44,120
bla[n]는 *(bla + n)과 같겠지요

80
00:05:44,120 --> 00:05:48,050
그러므로 tab2[1][2]에서 오른쪽 [ ]을 지울 수 있습니다

81
00:05:48,050 --> 00:05:52,040
[ ]은 *와 같습니다, 이번 예시에서는 tab2[1] + 2를 의미하죠

82
00:05:52,040 --> 00:05:58,850
이 두 값이 같을까요?

83
00:05:58,850 --> 00:06:05,420
과연 같은 결과를 출력할까요? 네, 그렇습니다!

84
00:06:05,420 --> 00:06:08,080
계속해서 더 흥미로운 걸 해봅시다

85
00:06:08,080 --> 00:06:12,580
두 번째 [ ]를 제거해 볼게요… 예를 들면

86
00:06:12,580 --> 00:06:16,430
* (* (를 추가해서

87
00:06:16,430 --> 00:06:24,760
* (* (tab2 + 1) + 2) = 18 으로 수정하면

88
00:06:24,760 --> 00:06:31,790
아까 전과 완벽히 같은 결과값을 가집니다!
다만 완벽하게 이해하는 것은 살짝 어렵습니다

89
00:06:31,790 --> 00:06:32,780
그러나 이제 여러분은

90
00:06:32,780 --> 00:06:37,490
배열은 가상의 포인터라는 것을 이해하셔야 합니다

91
00:06:37,490 --> 00:06:41,300
포인터란 배열을 이동할 수 있는

92
00:06:41,300 --> 00:06:43,940
아주 유용한 타입이라는 것을 확인했고

93
00:06:43,940 --> 00:06:47,480
이제는 [ ]가 어떻게 동작하는지 완벽히 이해할 수 있습니다

94
00:06:47,480 --> 00:06:51,560
[ ]은 값을 가리키기 위한 산술 연산이며 역참조입니다

95
00:06:51,560 --> 00:06:55,090
짜잔! 이제 배열에 대한 모든 것을 알게 되었습니다!
<< translated by mseo, ji-kim, inyang, chelee, mki and yeslee :) >>
