1
00:00:00,000 --> 00:00:04,049
이번 비디오에서는 string에 관해 얘기해봅시다

2
00:00:04,049 --> 00:00:06,210
비디오를 시작하기에 앞서 설명해 드리자면

3
00:00:06,210 --> 00:00:12,120
문자열은 개발자들이 효율성을 위해 관습적으로 사용하는 것일 뿐
컴퓨터, 적어도 c언어에서는 존재하지 않습니다

4
00:00:12,120 --> 00:00:16,289
문자열은 값이 0인 바이트로 끝나는

5
00:00:16,289 --> 00:00:20,430
매우 간단한 바이트들의 집합입니다

6
00:00:20,430 --> 00:00:29,429
문자 A와 아스키 값 a 그리고 실제 값의 차이를 완전히 이해하지 못한 분들을 위해
0이라는 값이 갖는 의미가 무엇인지 곧 설명하겠습니다

7
00:00:29,429 --> 00:00:38,160
ASCII 값 0도 마찬가지로 문자 '\0'과 같은 의미입니다, 지금 보여드리죠!

8
00:00:38,160 --> 00:00:42,809
그 전에 다시 짚고 넘어갈 중요한 사실이 하나 있습니다

9
00:00:42,809 --> 00:00:49,739
char c를 입력합니다, c는 '0'과 같고
이것이 0의 ASCII 값과 일치하는 것을 보실 수 있습니다

10
00:00:49,739 --> 00:00:56,340
이것이 0의 ASCII 값과 일치하는 것을 보실 수 있습니다

11
00:00:56,340 --> 00:01:01,710
만약 숫자로 출력해 보면

12
00:01:01,710 --> 00:01:12,630
이는 48임을 알 수 있습니다, 이제 c = 0으로 바꿔 보겠습니다
이것은 c의 값이 48이 아니라 0이라는 뜻이죠

13
00:01:12,630 --> 00:01:16,890
이건 결국… 잠시만요 미안합니다

14
00:01:16,890 --> 00:01:22,049
이건 (0) 결국 이것 (\0) 과 같습니다
즉, 값 0을 갖는 문자는 '\0' 입니다, 좋아요!

15
00:01:22,049 --> 00:01:27,810
문자열은 이처럼 단순한 바이트의 집합이며

16
00:01:27,810 --> 00:01:32,820
각 바이트가 서로의 옆에 위치하며 마지막 바이트가 0으로 끝납니다

17
00:01:32,820 --> 00:01:35,430
그 말인즉슨, 한 번 더 생각해보시면 눈치채실 겁니다…

18
00:01:35,430 --> 00:01:39,150
0으로 끝나는 문자열 집합은 다음과 같은 모습을 하고 있습니다

19
00:01:39,150 --> 00:01:44,970
tab이 포함된 배열을 제외하면,

20
00:01:44,970 --> 00:01:50,070
char형 배열에서 마지막 문자는 0이어야만 합니다

21
00:01:50,070 --> 00:01:53,399
10개의 요소를 할당하고

22
00:01:53,399 --> 00:01:57,090
't' 'o' 't' 'o' 't' 'o'를 넣었다고 가정해 봅시다

23
00:01:57,090 --> 00:02:00,329
만약 배열의 끝에 '\0'이 없다면 문자열로 취급되지 않는 문제가 생깁니다

24
00:02:00,329 --> 00:02:03,899
이제 string이 제대로 정의되어 있지 않다는 것을 이해하실 수 있을 겁니다…

25
00:02:03,899 --> 00:02:07,829
알아둬야 할 유일한 사항은 이것들이 마지막에 '\0'으로 끝나는

26
00:02:07,829 --> 00:02:10,169
읽을 수 있는 문자들의 집합이라는 사실입니다

27
00:02:10,169 --> 00:02:12,260
'문자열'에 대해서는 이것만 알고 계시면 됩니다

28
00:02:12,260 --> 00:02:14,390
이제 문자열을 가지고 놀아 봅시다

29
00:02:14,390 --> 00:02:18,560
일반적으로 포인터를 사용하여 '문자열'에 접근하여 수정할 것입니다

30
00:02:18,560 --> 00:02:22,010
왜냐하면 조금 전에 말씀드렸다시피
문자열은 그냥 바이트의 집합이니까요

31
00:02:22,010 --> 00:02:26,299
바이트가 서로 연결되어 있고 마지막 바이트는 0…

32
00:02:26,299 --> 00:02:31,099
'str'은 단순히 문자에 대한 포인터가 될 겁니다
그럼 문자열은 어떻게 사용할까요?

33
00:02:31,099 --> 00:02:34,670
예를 들어 str은 "lol"과 같다고 적은 뒤 str을 표시해 보겠습니다

34
00:02:34,670 --> 00:02:41,780
여기서 흥미로운 점은 printf의 매개변수에

35
00:02:41,780 --> 00:02:44,599
*str이 아니라 str을 적용했다는 겁니다

36
00:02:44,599 --> 00:02:47,870
왜냐하면 *str은…

37
00:02:47,870 --> 00:02:51,440
직접 보여 드리죠

38
00:02:51,440 --> 00:02:55,639
*str은 문자이므로 "%c"를 사용했죠…
그러나 str은 주소이므로 "%s"를 사용합니다

39
00:02:55,639 --> 00:03:01,010
이런… 미안합니다, 두 번째 값을 넣는 걸 잊었네요

40
00:03:01,010 --> 00:03:06,950
이렇게 하면 동작이… 앗! 여긴 *str이 들어가야 하네요

41
00:03:06,950 --> 00:03:12,049
그리고 이제… str은 "lol"이지만
*str은 첫 번째 문자이므로 'l'을 가리키겠죠

42
00:03:12,049 --> 00:03:16,459
str은 첫 번째 문자의 주소니까요, 그리고

43
00:03:16,459 --> 00:03:21,799
실제로 따옴표로 감싸서 "lol"을 쓸 때

44
00:03:21,799 --> 00:03:25,099
'I' ASCII 문자, 'o' ASCII 문자, 'I' ASCII 문자,
그리고 0을 메모리에 저장합니다

45
00:03:25,099 --> 00:03:30,739
실제로는 메모리에 4개의 문자를 저장한 셈이죠

46
00:03:30,739 --> 00:03:34,040
여기서 중요한 사실이 하나 있는데

47
00:03:34,040 --> 00:03:37,250
문자열을 " " 로 감싸면 상수라고 불리는 곳에
문자열이 작성되는 것을 알아두셔야 합니다

48
00:03:37,250 --> 00:03:40,519
이 부분은 프로그램상의 특정한 위치이므로

49
00:03:40,519 --> 00:03:43,760
이 주소에서 따옴표로 묶인 값은 변경할 수 없습니다

50
00:03:43,760 --> 00:03:48,290
이 문자열의 메모리는 쓰기 불가능한 영역이기 때문이죠

51
00:03:48,290 --> 00:03:52,720
이 부분이 여러분이 기억해두셔야 할 사실입니다

52
00:03:52,720 --> 00:03:56,329
첫 번째 요소인 str[0]을 'p'로 바꿔 쓰려 하면

53
00:03:56,329 --> 00:03:59,799
어떻게 될까요?

54
00:03:59,799 --> 00:04:05,120
bus error가 발생했네요! 이곳에 값을 쓰는 건 금지되어 있습니다

55
00:04:05,120 --> 00:04:10,099
이 작업을 할 수 있는 유일한 방법은, 지금 보여드릴게요

56
00:04:10,099 --> 00:04:12,919
함수를 거치거나 메모리 할당을 하는 등
C에서의 복잡한 작업을 수행하지 않는 방법은

57
00:04:12,919 --> 00:04:17,029
"str[]"으로 작성하는 것입니다
이 방식은 크기를 지정하지 않는다는 점과

58
00:04:17,029 --> 00:04:20,499
직접 할당한다는 점을 빼면, 정적 배열을 선언하는 것과 같죠

59
00:04:20,500 --> 00:04:23,060
같은 줄이 아닌 다른 줄에 할당을 시도하면 동작하지 않습니다…

60
00:04:23,060 --> 00:04:28,930
이제 아까 하려던 작업을 진행할 수 있습니다

61
00:04:28,930 --> 00:04:33,680
이제 첫 번째 글자가 'p'로 교체되었으므로 'pol' 이 표시됩니다

62
00:04:33,680 --> 00:04:38,870
요약하자면: 일반적으로 문자열은 첫 번째 글자의 주소이기 때문에

63
00:04:38,870 --> 00:04:42,560
char *를 통해 접근하여

64
00:04:42,560 --> 00:04:46,010
값이 0인 문자를 만날 때까지 읽어 들입니다

65
00:04:46,010 --> 00:04:50,770
이것이 문자열을 정의하는 방법입니다!
<< translated by mseo, ji-kim, inyang, chelee, mki and yeslee :) >>
