1
00:00:00,000 --> 00:00:04,200
이번 비디오에서는 포인터의 선언과 할당에 관해 설명하겠습니다

2
00:00:04,200 --> 00:00:06,210
포인터는 주소를 가지므로

3
00:00:06,210 --> 00:00:10,139
먼저 변수를 선언해야 합니다

4
00:00:10,139 --> 00:00:11,820
그렇게 해보도록 하겠습니다

5
00:00:11,820 --> 00:00:14,460
"int a" 변수를 선언하겠습니다

6
00:00:14,460 --> 00:00:15,690
이 변수는 스택 메모리에 선언되고 주소를 가집니다

7
00:00:15,690 --> 00:00:20,730
이제 이 주소를 저장할 수 있는 포인터를 선언하겠습니다

8
00:00:20,730 --> 00:00:28,260
포인터는, 사실 컴파일러는 접근하려는 주소의 타입을 알고 있어야 합니다

9
00:00:28,260 --> 00:00:29,609
제가 방금 "주소의 타입"이라고 했죠

10
00:00:29,609 --> 00:00:30,510
별로 좋은 용어는 아니네요…

11
00:00:30,510 --> 00:00:33,660
기본적으로 주소는 항상 숫자로 된 값입니다

12
00:00:33,660 --> 00:00:34,710
주소라는 것은 말 그대로 주소입니다

13
00:00:34,710 --> 00:00:36,210
하지만 컴파일러가 이 주소를 사용하려면

14
00:00:36,210 --> 00:00:40,079
이 주소에서 찾게 될 변수의 타입을 알아야 합니다

15
00:00:40,079 --> 00:00:41,489
이게 바로 제가 하려던 말이에요

16
00:00:41,489 --> 00:00:44,129
어떻게 하면 될까요?

17
00:00:44,129 --> 00:00:46,350
우리는 int형 포인터를 선언할 거예요

18
00:00:46,350 --> 00:00:47,520
이번 경우에는 int형 변수의 주소를 사용하고자 하니까요

19
00:00:47,520 --> 00:00:51,120
그러므로 제가 가리키고 싶은 타입을 적는 것으로 시작합니다: "int"

20
00:00:51,120 --> 00:00:53,879
그 뒤에는 *을 붙여야 해요

21
00:00:53,879 --> 00:00:55,469
포인터의 상징(signifié)이죠

22
00:00:55,469 --> 00:00:57,750
그리고 포인터의 이름을 써주면

23
00:00:57,750 --> 00:01:02,129
짜잔! 방금 int형 포인터 ptr을 선언했어요

24
00:01:02,129 --> 00:01:03,359
"int *"은 int형을 가리키는 포인터예요

25
00:01:03,359 --> 00:01:07,740
이제 어떻게 a의 주소를 받아올 수 있을까요?

26
00:01:07,740 --> 00:01:10,350
"ptr"도 다른 변수들과 마찬가지로 값을 가집니다

27
00:01:10,350 --> 00:01:11,670
언제나처럼 "ptr ="을 적고,

28
00:01:11,670 --> 00:01:16,110
다른 연산자를 사용할 거예요 : &a

29
00:01:16,110 --> 00:01:18,509
앰퍼샌드 a (&a)의 뜻은

30
00:01:18,509 --> 00:01:22,619
오른쪽에 적힌 변수의 주소를 가져옵니다, 여기서는 "a"죠

31
00:01:22,619 --> 00:01:24,330
그리고 이 주소를 "ptr"에 넣어줍니다
a의 주솟값을 복사해와 "ptr"에 넣는 거예요

32
00:01:24,330 --> 00:01:28,380
여기 "a"의 주소를 찾아가 져와서

33
00:01:28,380 --> 00:01:29,549
"ptr"에 넣어줬어요

34
00:01:29,549 --> 00:01:33,689
Printf를 이용해서 주소가 어떻게 생겼는지 보여드릴게요, 정말 편리하죠!

35
00:01:33,689 --> 00:01:42,740
이걸 저장하고 gcc main.c && ./a.out을 해보면

36
00:01:42,740 --> 00:01:46,200
주소를 볼 수 있습니다

37
00:01:46,200 --> 00:01:47,340
출력된 주솟값은 이전에 제가 말했듯

38
00:01:47,340 --> 00:01:48,780
스택 영역 중 높은 주솟값입니다

39
00:01:48,780 --> 00:01:51,860
거의 최고점에 있다고 할 수 있죠

40
00:01:51,860 --> 00:01:54,890
가장 높은 주솟값은

41
00:01:54,890 --> 00:01:57,950
약 8,000,000(16) 근처의 값을 가집니다

42
00:01:57,950 --> 00:02:00,170
이 값은 제 메모리의 절반 정도의 크기입니다

43
00:02:00,170 --> 00:02:01,160
주솟값은 unsigned형입니다

44
00:02:01,160 --> 00:02:02,330
unsigned형이 signed형보다

45
00:02:02,330 --> 00:02:03,770
더 큰 수를 표현할 수 있기 때문입니다

46
00:02:03,770 --> 00:02:04,820
꽤 단순하죠

47
00:02:04,820 --> 00:02:06,350
출력값을 다시 봅시다, 스택 메모리가

48
00:02:06,350 --> 00:02:08,210
시스템 주소의 최상단에 있고

49
00:02:08,210 --> 00:02:11,000
그 주소의 값이

50
00:02:11,000 --> 00:02:12,160
7fff 어쩌고 라는 것을 알 수 있습니다

51
00:02:12,160 --> 00:02:13,580
이제 여러분께

52
00:02:13,580 --> 00:02:15,980
스택 메모리는 아래 방향으로 주소를 할당한다는 걸 보여드리겠습니다

53
00:02:15,980 --> 00:02:17,120
제가 두 번째 변수 int b를 선언하고

54
00:02:17,120 --> 00:02:21,740
같은 포인터를 사용하겠습니다

55
00:02:21,740 --> 00:02:23,390
"Ptr = &b"라고 입력함으로써

56
00:02:23,390 --> 00:02:27,800
먼저 "a"의 주소를 출력하고 "b"의 주소도 출력할 거예요

57
00:02:27,800 --> 00:02:29,570
그래서 여기 "a"의 주소를 볼 수 있고…

58
00:02:29,570 --> 00:02:31,400
아 맞아요! 제가 전에 "가상 메모리"에 대해 말했었죠

59
00:02:31,400 --> 00:02:32,840
여기서 확인할 수 있습니다!

60
00:02:32,840 --> 00:02:34,459
"가상 메모리"인 이유는, 이 값이 바뀌거나

61
00:02:34,459 --> 00:02:37,340
매번 프로그램을 실행시킬 때마다

62
00:02:37,340 --> 00:02:38,030
점점 낮은 메모리로 옮겨가기 때문입니다

63
00:02:38,030 --> 00:02:41,000
여기 38이 a의 주소이고

64
00:02:41,000 --> 00:02:43,790
b의 주소는 34입니다

65
00:02:43,790 --> 00:02:45,260
제 아키텍처에서 int형이 4바이트라는 것을

66
00:02:45,260 --> 00:02:47,720
여기서 명확하게 볼 수 있습니다

67
00:02:47,720 --> 00:02:51,830
다른 예시를 들어 보여드릴게요

68
00:02:51,830 --> 00:02:53,060
이번엔 자료형을 바꿀 거예요

69
00:02:53,060 --> 00:02:54,140
char c를 넣어봅시다

70
00:02:54,140 --> 00:02:58,220
정리를 좀 해주고

71
00:02:58,220 --> 00:03:04,580
char c를 넣어주고 "ptr = &c"라고 쓸게요

72
00:03:04,580 --> 00:03:08,500
printf로 ptr의 주소를 출력하면…

73
00:03:08,500 --> 00:03:11,900
제가 경고했듯이

74
00:03:11,900 --> 00:03:13,970
에러가 났네요!

75
00:03:13,970 --> 00:03:16,400
왜 에러가 날까요?

76
00:03:16,400 --> 00:03:19,790
왜냐하면, 우리가 포인터를

77
00:03:19,790 --> 00:03:21,200
선언할 때에는

78
00:03:21,200 --> 00:03:23,299
포인터가 가리킬 변수의 타입이 무엇인지를 말해줘야 합니다

79
00:03:23,299 --> 00:03:25,160
여기서는 "int *"라고 했는데, "char"형의 주소를 가져오려고 했죠

80
00:03:25,160 --> 00:03:27,760
사실 이건 경고일 뿐입니다

81
00:03:27,760 --> 00:03:29,840
왜 그냥 경고일까요?

82
00:03:29,840 --> 00:03:31,250
주소는 주소일 뿐이고

83
00:03:31,250 --> 00:03:34,430
주소는 결국 숫자일 뿐입니다

84
00:03:34,430 --> 00:03:35,090
이런 짓을 하려는 건 저고

85
00:03:35,090 --> 00:03:36,140
아마도 저는 제가 뭘 하는지 알고 있으니까

86
00:03:36,140 --> 00:03:38,780
만약 여기서 char형으로 주소를 받아왔더라도

87
00:03:38,780 --> 00:03:39,739
int인 것처럼 사용할 거예요

88
00:03:39,739 --> 00:03:42,830
이건 제 문제니까 컴파일러는 말해주려고 하는 겁니다

89
00:03:42,830 --> 00:03:44,720
"조심해, 네가 잘못하고 있는 것인지도 몰라"라고 말이죠

90
00:03:44,720 --> 00:03:46,940
실제로는

91
00:03:46,940 --> 00:03:49,459
여전히 프로그램을 실행 시켜 주는 것을 볼 수 있습니다

92
00:03:49,459 --> 00:03:51,500
세 번째로 출력된 주소가 보이시죠, "c"의 주소요

93
00:03:51,500 --> 00:03:53,660
1바이트의 오프셋만을 가지는 것을 보실 수 있습니다

94
00:03:53,660 --> 00:03:57,739
33의 주소는 34로부터 1바이트만 떨어져 있습니다

95
00:03:57,739 --> 00:03:59,590
쉽게 알 수 있지요

96
00:03:59,590 --> 00:04:02,170
마지막으로 하나만 더 보여드릴게요

97
00:04:02,170 --> 00:04:05,230
포인터도 다른 변수들과 다를 바 없으므로

98
00:04:05,230 --> 00:04:07,569
말하자면 예를 들어

99
00:04:07,569 --> 00:04:11,020
"int *ptr2"를 선언하고 "ptr2 = ptr"라고 쓸 수도 있습니다

100
00:04:11,020 --> 00:04:15,190
주소를 가지고 있으니 문제없어요

101
00:04:15,190 --> 00:04:16,690
컴파일되는지 봅시다, 만약 된다면…

102
00:04:16,690 --> 00:04:18,579
제가 값 출력을 안 했고… 아직도 컴파일 중이네요

103
00:04:18,579 --> 00:04:19,959
여전히 "c" 부분에 문제가 있군요

104
00:04:19,959 --> 00:04:22,960
지워버립시다

105
00:04:22,960 --> 00:04:24,730
이제 동작하는 게 보이시죠

106
00:04:24,730 --> 00:04:27,760
제가 "ptr"도 다른 것들처럼 변수라고

107
00:04:27,760 --> 00:04:29,290
말씀드렸죠

108
00:04:29,290 --> 00:04:31,060
그렇기 때문에 ptr도 주소를 가집니다

109
00:04:31,060 --> 00:04:31,630
한눈에 보기 위해

110
00:04:31,630 --> 00:04:35,470
만약 제가 int *을 써서 포인터를 만들고

111
00:04:35,470 --> 00:04:38,080
*을 하나 더 붙여 "int **" 을 만들면
int형 포인터를 가리키는 포인터가 됩니다

112
00:04:38,080 --> 00:04:47,320
달리 말해 제 "ptr3"은 포인터의 주소를 가지게 되는 거죠, 보여드릴게요

113
00:04:47,320 --> 00:04:49,120
그래서 ptr3는 "ptr"의 주소를 가지고

114
00:04:49,120 --> 00:04:52,000
출력해보면

115
00:04:52,000 --> 00:04:58,120
아까 제가 "char"를 지웠었죠

116
00:04:58,120 --> 00:05:00,340
더는 경고가 뜨지 않을 겁니다, 아… 실패했네요

117
00:05:00,340 --> 00:05:02,200
죄송해요, 잠시만요, "ptr"을 출력했고…

118
00:05:02,200 --> 00:05:04,570
"ptr3"을 출력할 거니까…

119
00:05:04,570 --> 00:05:13,510
미안합니다, 이걸 보면 이제 어떤 변수의 주소든
가져올 수 있음을 볼 수 있어요

120
00:05:13,510 --> 00:05:15,460
포인터라고 주소를 가져올 수 없는 게 아니에요

121
00:05:15,460 --> 00:05:17,229
우리는 이것을 무한대로 반복하여 주소를 가져올 수 있습니다

122
00:05:17,229 --> 00:05:18,700
우리는 포인터의 주소를 찾을 수 있고

123
00:05:18,700 --> 00:05:19,690
포인터를 가리키는 포인터와 그걸 가리키는 포인터 등을

124
00:05:19,690 --> 00:05:20,410
만들 수 있습니다

125
00:05:20,410 --> 00:05:22,060
이건 다음 비디오에서 보여드릴게요

126
00:05:22,060 --> 00:05:23,680
이제 여러분은 포인터의 선언과 사용 방법을 알게 되었습니다
<< translated by inyang, chelee, mki, yeslee, mseo, ji-kim and jinchoi:) >>
