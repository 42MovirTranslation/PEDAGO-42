1
00:00:00,000 --> 00:00:04,560
이 영상에서 void, 더 정확하게는 void 포인터에 관해 이야기할 것입니다

2
00:00:04,560 --> 00:00:08,160
여러분은 이미 void를 본 적이 있고 직접 사용도 해 봤습니다

3
00:00:08,160 --> 00:00:10,590
일반적으로 이는 함수가 아무것도 반환하지 않을 때나

4
00:00:10,590 --> 00:00:14,009
어떤 매개 변수도 받지 않을 때 사용합니다
이제 다른 용도로 사용해볼 겁니다

5
00:00:14,009 --> 00:00:16,920
처음부터 포인터는 주솟값이라고 말했었죠

6
00:00:16,920 --> 00:00:18,660
그리고 주소는 주소입니다…

7
00:00:18,660 --> 00:00:23,279
이는 int * 또는 char * 등으로 표기합니다

8
00:00:23,279 --> 00:00:27,000
이렇게 씀으로써 이 주소에 들어 있는 값의 자료형을 정의할 수 있습니다

9
00:00:27,000 --> 00:00:31,470
그러나 현실은 주소는 주소일 뿐이죠… 이것이 키워드 "void *"이 사용되는 이유입니다

10
00:00:31,470 --> 00:00:36,270
소소한 예시를 보여드리겠습니다

11
00:00:36,270 --> 00:00:40,770
void *ptr을 선언했습니다, 그리고 int *ptr_i를 선언할 겁니다

12
00:00:40,770 --> 00:00:47,280
예를 들어 char *ptr_c를 선언하고

13
00:00:47,280 --> 00:00:50,579
ptr_c와 ptr_i가 같다고 적어보겠습니다

14
00:00:50,579 --> 00:00:57,809
어떻게 될까요? 경고가 뜨네요, 정상입니다

15
00:00:57,809 --> 00:00:59,399
컴파일러가 말합니다: 기다려!! 기다려요!!!

16
00:00:59,399 --> 00:01:03,840
뭐 하는 거예요? 오른쪽은 char *이고 왼쪽에는 int *인데요

17
00:01:03,840 --> 00:01:07,939
맞아요, 둘 다 주소이긴 한데 타입이 같지 않아서 문제가 생긴 겁니다

18
00:01:07,939 --> 00:01:12,600
왼쪽에 ptr, 오른쪽에 ptr_c를 써도 같은 오류가 발생할까요?

19
00:01:12,600 --> 00:01:16,890
더 이상 경고가 나오지 않습니다

20
00:01:16,890 --> 00:01:22,049
왜냐고요? 컴파일러는 *가 주소라는 것을 알기 때문에

21
00:01:22,049 --> 00:01:25,710
제가 컴파일러에게 이렇게 말하는 것과 같습니다:
"저도 제가 뭘 하는지 알고 있습니다, 저를 내버려 두세요

22
00:01:25,710 --> 00:01:29,520
제발 오른쪽에 있는 주소를 왼쪽의 변수에 넣어 주세요

23
00:01:29,520 --> 00:01:31,979
이건 void *이라고요, 제가 뭘 하려는지 저도 알아요

24
00:01:31,979 --> 00:01:35,189
제가 알아서 할 테니 신경 쓰지 마세요"

25
00:01:35,189 --> 00:01:39,960
이것은 모든 포인터 타입에서 동작합니다

26
00:01:39,960 --> 00:01:42,810
이렇게도 써볼 수 있어요… 바보같아 보이지만, 잘 작동할 겁니다

27
00:01:42,810 --> 00:01:46,470
ptr의 주소를 가져왔죠, ptr의 주소 또한 주소입니다

28
00:01:46,470 --> 00:01:51,329
이걸 다시 ptr에 넣어줬습니다, 동작하네요!
무슨 의미인지 궁금하지만 동작하긴 하네요

29
00:01:51,329 --> 00:01:54,750
기본적으로 저는 &ptr을 가지고 있고

30
00:01:54,750 --> 00:01:57,479
이는 void * … 아니 void를 가리키는 포인터를 가리키는 포인터입니다,
미안해요

31
00:01:57,479 --> 00:02:02,490
그말인 즉슨 같은 주소니까 동작할 겁니다

32
00:02:02,490 --> 00:02:07,099
더 흥미롭게 ptr = ptr_i를 넣어봅시다, 이것도 동작하지요

33
00:02:07,099 --> 00:02:11,110
좋아요! 다른 방향으로도 동작하네요

34
00:02:11,110 --> 00:02:14,720
이는 자료형을 직접 구체화할 수 있다는 것을 의미합니다

35
00:02:14,720 --> 00:02:18,500
자료형이 구체적으로 명시되지 않은 주소가 있어요: void *이죠
이걸 캐스팅 없이도 자료형을 구체화할 수 있어요

36
00:02:18,500 --> 00:02:21,320
예를 들어, 이것을 char *로 바꿔 볼게요, 잘 동작하죠

37
00:02:21,320 --> 00:02:25,040
int *에서도 잘 동작합니다… 적을 필요도 없이요…

38
00:02:25,040 --> 00:02:28,490
이것이 주로 사용되는 예시 중 하나는 write입니다

39
00:02:28,490 --> 00:02:33,860
한번 보여드릴게요… "write"는 실제로 어떤 것을 쓸 수 있게 합니다

40
00:02:33,860 --> 00:02:36,440
메모리나 주소에서 말이죠
write 함수에 인자로 주솟값을 주고

41
00:02:36,440 --> 00:02:39,110
write 함수는 바이너리 형식으로 작성하기 때문에
원하는 것을 마음껏 써도 됩니다

42
00:02:39,110 --> 00:02:43,550
char를 쓸 수도 있고
읽을 수 있는 문자든 읽을 수 없는 문자든 상관 없습니다

43
00:02:43,550 --> 00:02:46,670
여기에 void * 대신 char *가 있다면 어떨까요

44
00:02:46,670 --> 00:02:49,700
만약 제가 매번 메모리에 어떠한 값을 쓰고 싶어요

45
00:02:49,700 --> 00:02:55,580
그 값이 바이너리 형식이 아닌 int, 변수 등등의 값일 때 종종 사용됩니다:

46
00:02:55,580 --> 00:02:58,100
예를 들면 비디오 게임 같은 것 말이죠

47
00:02:58,100 --> 00:03:01,160
파일에 바이너리 값 또는 그 외의 무언가가 들어 있다면

48
00:03:01,160 --> 00:03:05,660
파일의 내용물이 읽을 수 있는 문자인지 아닌지 알 방법이 없습니다
변환을 하기 전까지는요

49
00:03:05,660 --> 00:03:08,300
여러분이 원하는 값을 가리키는 포인터를 갖고 있다면
여러분은 매번 강제로 이렇게 말했어야 할 겁니다:

50
00:03:08,300 --> 00:03:10,850
"아, 안돼 사실 그건 char* 였어"…
그리고 수많은 오류를 매번 마주했겠죠

51
00:03:10,850 --> 00:03:13,910
이제 우리는 포인터를 void *에 넣고 이렇게 말하면 됩니다:

52
00:03:13,910 --> 00:03:18,350
"이 주소 안에 어떤 값이 있는지 보고 싶어

53
00:03:18,350 --> 00:03:22,430
그리고 그 값을 표준 출력으로 파일에 써 줘… 이건 내가 관리할게"

54
00:03:22,430 --> 00:03:25,489
이건 하나의 예시이고, 다른 일반적인 예시를 들어 보자면:

55
00:03:25,489 --> 00:03:29,540
"내가 메모리를 동적할당하고 직접 관리할게"

56
00:03:29,540 --> 00:03:33,830
여러분은 수많은 메모리 영역을 할당받을 것이고 이를 직접 관리해야 합니다
그리고 이렇게 말할 수 있겠죠:

57
00:03:33,830 --> 00:03:36,830
"메모리의 이 부분은 int로 읽힐 것이고

58
00:03:36,830 --> 00:03:39,320
이 다른 부분은 float로 읽힙니다, 등등"

59
00:03:39,320 --> 00:03:43,880
이는 "void *"의 주요 용도 중 하나입니다

60
00:03:43,880 --> 00:03:47,989
메모리에 정확히 무엇이 들어있는지 모르는 채로 함수를 사용하거나

61
00:03:47,989 --> 00:03:51,290
또는 여러분이 직접 메모리를 관리하기 위해 사용하죠

62
00:03:51,290 --> 00:03:53,900
조심해서 사용하세요!!

63
00:03:53,900 --> 00:03:57,470
저는 이것을 사용하는 사람을 거의 못 봤습니다

64
00:03:57,470 --> 00:04:01,459
왜냐하면 아주 특별한 몇몇 케이스에서만 사용되거든요

65
00:04:01,459 --> 00:04:04,510
이제 "void *"가 무엇인지 알게 되었습니다!
<< translated by inyang, mki, ji-kim, yeslee, mseo and chelee :) >>
