1
00:00:05,660 --> 00:00:07,690
이번 영상에서 트리에 관해 이야기해봅시다.

2
00:00:08,440 --> 00:00:12,080
자, 프로그래밍 도구로서 트리 말이에요.

3
00:00:12,620 --> 00:00:15,720
트리란 무엇일까요? 트리는 그래프의 종류입니다.

4
00:00:16,129 --> 00:00:23,229
그래프는 한 데이터 집합에서 다른 데이터 집합으로 “이동"할 수 있도록 데이터를 구조화하는 방법입니다.

5
00:00:23,600 --> 00:00:27,609
그리고 트리는 그래프의 한 종류입니다.

6
00:00:27,820 --> 00:00:36,760
왜냐하면 단일 시작점 / 진입점에서 모든 데이터를 살펴볼 수 있기 때문입니다.

7
00:00:38,260 --> 00:00:48,020
그래서 연결리스트가 생각나실 것 같은데, 그건 정상입니다.

8
00:00:48,020 --> 00:00:49,460
연결리스트는 트리와 다를 바가 없습니다. 시작점에서 다른 한 개의 요소만 가리키고,

9
00:00:49,640 --> 00:00:58,160
그 다른 한 개의 요소도 또 다른 한 개를 가리키는 것입니다.

10
00:00:58,460 --> 00:01:00,460
그래서...

11
00:01:00,740 --> 00:01:05,140
두 개의 요소를 가리키는 트리가 있을 수 있습니다.

12
00:01:05,600 --> 00:01:11,100
Et qui vont avoir un maillon 'a' et un maillon 'b' et qui vont pointer l'un vers l'autr
And which will have a link 'a' and a link 'b' and which will point to one or another
그리고 이 트리는 두 개의 요소를 각각 연결하는 link ‘a’와 link ‘b’를 가질 것입니다.

13
00:01:11,420 --> 00:01:15,489
avec des conditions, il peut y avoir des arbres avec N conditions...
depending on certain conditions, there can be trees with N conditions ...
특정 조건에서는, N개의 조건을 가지는 트리가 있을 수 있겠군요.

14
00:01:16,100 --> 00:01:19,659
Un assez bon exemple de ça si vous vous souvenez.
A pretty good example of that if you remember.
여러분들이 알고 있는 꽤 좋은 예가 있습니다.

15
00:01:20,180 --> 00:01:22,540
C'est le T9 tout simplement.
It is simply the T9.
이건 T9를 간단하게 만든 것입니다.
(T9: 휴대전화 영어 텍스트 입력 방식의 종류)

16
00:01:23,750 --> 00:01:26,949
Alors le T9, je sais pas si ça vous rappelle quelque chose...
So the T9, I don't know if that reminds you of anything ...
자 T9를 여러분들이 기억하실지는 모르지만...

17
00:01:27,290 --> 00:01:30,429
Dans le passé à un moment, on avait des téléphones comme ça avec seulement 12 touches.
In the past, we had phones like this with only 12 buttons.
과거에는 이렇게 오직 12개의 버튼만 있는 핸드폰을 사용했습니다.

18
00:01:30,799 --> 00:01:37,419
Dont 10 chiffres et il y avait aussi des caractères d'écriture sur les lettres.
Including 10 digits and there were also writing characters on the buttons.
10개의 숫자를 포함해, 버튼에 알파벳도 있었습니다.

19
00:01:38,140 --> 00:01:43,760
Et donc pour que le T9 fonctionne
And so for the T9 to work
그리고 T9가 동작하려면

20
00:01:44,260 --> 00:01:46,260
on construisait des dictionnaires,
we built dictionaries,
입력한 알파벳 조합에 맞게 입력할 가능성이 있는

21
00:01:46,939 --> 00:01:50,319
avec à un moment donné toutes les possibilités
with all the possibilities
모든 단어를 가지고 있는 사전을 만들어야 했습니다.

22
00:01:51,110 --> 00:01:57,339
pour une combinaison possible enregistrée a un moment. Par exemple si on faisait la touche 3 puis la touche 2,
for a possible registered combination. For example if we press key 3 then key 2,
예를 들어 3을 누르고 2를 누르면,

23
00:01:57,979 --> 00:02:01,599
il y avait un endroit dans les mémoires on allait avoir tous les mots possibles
there was a place in our memories we were going to have all the possible words
‘d’와 ‘a’의 조합에 대한 모든 가능성 있는 단어들이 메모리에 저장되어 있습니다.

24
00:02:02,000 --> 00:02:08,440
pour cette combinaison. Et ça marche beaucoup mieux que de faire l'inverse et d'enregistrer tous les mots
for this combination. And it works much better than doing it the other way around: recording all the words
이런 방법은 다른 방식보다 더 효과적입니다.

25
00:02:08,620 --> 00:02:12,980
et ensuite les touches les touches correspondantes possibles.
and then the corresponding possible keys.
모든 단어를 기록하고, 가능한 키조합에 대응하기 때문입니다. 

26
00:02:13,940 --> 00:02:17,040
Mais aujourd'hui c'est des arbres binaires dont on va parler.
But today we are going to talk about binary trees.
그러나 오늘은 이진 트리에 대해 이야기해볼 겁니다.

27
00:02:17,520 --> 00:02:20,660
Alors pourquoi les arbres binaires ? Parce que c'est un exemple classique.
So why binary trees? Because it's a classic example.
그래서… 왜 이진 트리일까요? 왜냐면 가장 클래식한 예시이기 때문입니다.

28
00:02:21,129 --> 00:02:25,859
Avec une utilité directe que vous allez voir tout de suite, qui est vraiment intéressante.
With a direct utility that you will see right away, which is really interesting.
바로 볼 수 있는 예를 사용하면 아주 유용합니다.

29
00:02:26,110 --> 00:02:28,769
Et donc on va regarder tout de suite un petit exemple.
And so we will immediately look at a small example.
그래서! 아주 쉬운 예를 보겠습니다.

30
00:02:31,659 --> 00:02:38,789
Donc d'abord, on va se poser la question de "comment créer un arbre binaire" en termes de code.
So first, let's think about how to code binary trees.
자 먼저, 어떻게 이진 트리를 코드로 작성하는지 생각해봅시다.

31
00:02:39,790 --> 00:02:45,360
C'est assez simple et ça va beaucoup ressembler à ce que vous faites lorsque vous créez votre structure
It's quite simple and it will be pretty similar to how we create structures
연결리스트에서 구조체를 만들었던 방법이랑

32
00:02:45,849 --> 00:02:49,199
pour une liste chainée.
for a linked list.
거의 유사하고 간단합니다.

33
00:02:50,140 --> 00:02:52,739
Donc là on utilise 'typedef'
So here we use 'typedef'
여기에 “struct”의 반복을 피하고자 “typedef’를 쓰고,

34
00:02:55,180 --> 00:03:02,160
Pour pas avoir à répéter le mot struct à chaque fois et on va l'appeler "s_binary_tree".
to not have to repeat the word "struct" every time and we will call it "s_binary_tree".
이걸 “s_binary_tree”라고 합시다.

35
00:03:07,200 --> 00:03:11,060
Je vais pouvoir mettre ma donnée tout simplement.
I will be able to put my data, quite simply.
여기에 꽤 간단하게 데이터를 넣을 수 있습니다.

36
00:03:11,340 --> 00:03:19,080
Ça pourrait être, ça pourrait être un void*. Mais là on va faire simple, on va juste mettre un int a.
It could be a "void *" or anything else, but here we are going to keep it simple, we will just put an "int a".
“void *”가 될 수도 있고 아무거나 될 수 있습니다. 그냥 간단하게 “int a”로 하죠.

37
00:03:19,920 --> 00:03:25,280
Ensuite, on va avoir un pointeur vers une autre struct s_binary_tree.
Next, we will have pointers to other struct "s_binary_tree":
다음으로, 다른 "s_binary_tree"를 가리키는 포인터들을 만듭시다.

38
00:03:25,810 --> 00:03:28,019
Donc un premier pointeur left.
first a pointer named left,
첫 번째 포인터의 이름은 left로 하고,

39
00:03:35,540 --> 00:03:39,639
Et un autre pointeur qu'on va appeler tout simplement right.
and another pointer that we will simply call right.
다른 포인터는 right라고 하죠.

40
00:03:47,000 --> 00:03:50,350
Donc là c'est bon, j'ai ma structure.
So there it is, I have my structure.
자 끝났습니다. 구조체를 만들었어요.

41
00:03:56,000 --> 00:04:02,380
Là j'ai la structure de mon arbre binaire. Et la, vous allez me dire: "A quoi ça va bien pouvoir nous servir"
There I have the structure of my binary tree. And you may tell me: "Why is it useful for us?"
여기 이진 트리 구조체가 있습니다. 여러분들은 이런 의문이 들 거에요. "왜 이 구조체가 필요하죠?"

42
00:04:03,740 --> 00:04:06,760
Il ya quelque chose qui s'appelle la "recherche par dichotomie",
There is something called "dichotomy search",
생소하시겠지만, "이진 검색(dichotomy search)"이라고 불리는 개념이 있습니다.

43
00:04:07,460 --> 00:04:14,079
si ça vous dit rien, on va prendre l'exemple: imaginons qu'on a un tableau d'int de données.
is normal that it doesn't ring a bell, let's take an example: let's imagine that we have an array of data int.
예시를 하나 봅시다. int형 데이터 배열을 상상해보죠.

44
00:04:15,890 --> 00:04:22,270
Trié dans l'ordre croissant et on a une valeur qu'on veut insérer au bon endroit dans ce tableau trié.
Sorted in ascending order and we have a value that we want to insert in the right place in this sorted array.
오름차순으로 정렬되어있고, 이 배열의 올바른 위치에 새로운 값을 넣고 싶습니다.

45
00:04:23,630 --> 00:04:31,299
Deux méthodes: première méthode parcourir tout le tableau jusqu'à trouver l'endroit où insérer ma nouvelle valeur.
Two methods: first method browse the whole array until you find the place where to insert my new value.
이때 두 가지 방법이 있습니다. 첫 번째로 새로운 값을 넣을 곳을 찾을 때까지 전체 배열을 탐색하는 것입니다.

46
00:04:33,860 --> 00:04:35,860
Deuxième méthode, un peu plus habile...
Second method, a little more skillful …
두 번째 방법은, 약간 좀 기술이 필요한데...

47
00:04:36,650 --> 00:04:41,500
on va pouvoir aller regarder une valeur spécifique comme par exemple à la moitié du tableau.
we can look at a specific value, for example at the middle point of the array,
예를 들어 배열의 중간에 있는 특정 값을 보고,

48
00:04:42,170 --> 00:04:46,779
Et comparer nous avec la valeur qu'on veut insérer si c'est plus grand ou plus petit. On va ensuite
and compare it with the value we want to insert, if it's bigger or smaller.
우리가 집어넣을 값보다 더 큰지 혹은 작은지 비교합니다.

49
00:04:47,240 --> 00:04:50,799
On va faire la même chose mais en prenant la moitié de la moitié du tableau.
We are going to do the same thing but taking half of half of the table.
같은 작업을 또 할 거지만, 배열 1/4 값을 보고

50
00:04:50,900 --> 00:04:55,120
Et là de nouveau se dire est-ce que c'est plus grand plus petit et ainsi de suite...
And there again check if it is bigger or smaller and so on ...
더 큰지 작은지 확인합니다.

51
00:04:55,730 --> 00:04:58,809
Et ça en fait, ça va nous permettre d'économiser
And that in fact, that will allow us to reduce
이렇게 하면, 꽤나 많은 수의 연산을 줄일 수 있고,

52
00:04:59,480 --> 00:05:04,420
considérablement le nombre d'opérations qu'on va faire, cela va être beaucoup plus rapide. Par exemple pour un tableau de
considerably the number of operations, it will be much faster.
좀 더 빨라집니다.

53
00:05:04,730 --> 00:05:08,890
imaginez avec 2 milliards d'int on va faire seulement trente et une opération
In a 2 billion int array, we will only do 31 operations.
20억 크기 int 배열에서, 오직 31번의 연산을 합니다.

54
00:05:10,940 --> 00:05:13,959
parce que du coup à chaque fois forcément on divise par deux le
because each time we divide by two
왜냐하면, 매번 가능성 있는 수를 절반으로 줄이기 때문에

55
00:05:14,750 --> 00:05:17,170
nombre de possibilités c'est beaucoup plus efficace
the number of possibilities, is much more efficvérif
좀 더 효과적입니다.

56
00:05:17,840 --> 00:05:24,459
vous allez me dire quel est le rapport avec les arbres binaires. C'est assez simple, c'est qu'en fait ça va également être un moyen
You may be wondering what does this has to do with binary trees. It's quite simple, in fact it is a way
여러분들은 이게 이진 트리와 무슨 상관이 있는지 궁금할 겁니다.

57
00:05:25,100 --> 00:05:30,790
de faire cette recherche par dichotomie seulement là au lieu de faire des calculs
to do this "dichotomy research": instead of doing calculations
꽤 간단하지만 사실 계산하는 것 대신에 “이진 탐색”을 하는 것입니다.

58
00:05:31,000 --> 00:05:34,299
on va aller à gauche et à droite dans l'arbre binaire
we will go to the left or to the right in the binary tree.
이진 트리에서는 왼쪽이나 오른쪽으로 갈 겁니다

59
00:05:34,720 --> 00:05:42,280
pour que vous puissiez mieux le visualiser, on va regarder une représentation un peu schématique de l'arbre
For you to have a clearer vision, we will look at schematic representation of the tree.
여러분들이 잘 이해하실 수 있도록, 그림으로 표현된 트리를 보겠습니다.

60
00:05:44,400 --> 00:05:47,800
Voilà donc ça ça pourrait être une représentation
So this could be a representation
자, 이게 이진 트리 표현법이 되겠습니다.

61
00:05:49,330 --> 00:05:54,389
여기 보시다시피,

62
00:05:54,879 --> 00:05:58,438
이 그림은 이진 트리 구조입니다.

00:05:58,750 --> 00:06:06,449
여기 int a = 27이 있고, 왼쪽에 다른 이진 트리 구조체를 가리키는 포인터가 있습니다.

64
00:06:07,990 --> 00:06:13,949
여기 왼쪽 포인터와 오른쪽 포인터가 있고요. 이게 표현법입니다.

65
00:06:15,430 --> 00:06:21,870
이진 트리를 탐색하는 몇 가지 방법이 있는데, 가장 일반적인 방법은

66
00:06:22,330 --> 00:06:28,319
왼쪽 경로와 오른쪽 경로가 있습니다. 왼쪽 경로로 시작하죠.

67
00:06:28,659 --> 00:06:32,879
꽤 간단하게도, 왼쪽에 뭔가 있는 한 계속 진행하고,

68
00:06:33,009 --> 00:06:37,799
왼쪽에 아무것도 없을 때, 현재 값을 출력합니다. 현재 왼쪽 오른쪽 아무 데도 없기 때문에,

69
00:06:38,020 --> 00:06:43,259
다시 올라가서 이걸 계속할 겁니다: 왼쪽, 중앙, 오른쪽 확인하고  “int a” 출력.

70
00:06:44,409 --> 00:06:46,409
여기 왼쪽에 아무것도 없군요.

71
00:06:46,930 --> 00:06:48,930
9를 출력합니다.

72
00:06:49,060 --> 00:06:51,659
오른쪽도 마찬가지로 아무것도 없습니다. 위로 올라갑니다.

73
00:06:53,589 --> 00:06:58,919
왼쪽은 이미 봤기 때문에, 12를 출력하고 오른쪽에 아무것도 없어서 다시 올라갑니다.

74
00:06:59,620 --> 00:07:02,639
이번에도 왼쪽은 이미 봤기 때문에, 15를 출력하고 오른쪽으로 내려갑니다.

75
00:07:03,400 --> 00:07:06,539
여기 도착하고 보니, 왼쪽에 아무것도 없군요.

76
00:07:07,060 --> 00:07:10,440
그러니 20을 출력하고 오른쪽에도 아무것도 없음으로, 다시 올라갑니다.


77
00:07:11,770 --> 00:07:13,770
다시 21로 올라왔군요.

78
00:07:13,930 --> 00:07:15,959
왼쪽을 벌써 봤으므로, 21을 출력합니다.

79
00:07:16,659 --> 00:07:22,468
23으로 내려가서 왼쪽에 아무것도 없음으로 23을 출력하고 오른쪽으로 내려갑니다. 24에 도착했어요.

80
00:07:22,960 --> 00:07:26,909
24를 출력하고 오른쪽에 아무것도 없음으로 다시 올라갑니다. 그래서...

81
00:07:28,289 --> 00:07:30,718
여기서 깨달은 것은, 왼쪽 경로로 따라가면

82
00:07:31,000 --> 00:07:36,869
오름차순으로 정렬된 배열이 있다는 것입니다.

83
00:07:37,389 --> 00:07:39,718
이건 나중에 꽤 유용할 겁니다.


84
00:07:40,449 --> 00:07:42,219
이제 볼 것은,

85
00:07:42,219 --> 00:07:49,469
이 배열에 새로운 값을 집어넣는 경우입니다. 예를 들어서, 32를 넣어줄 겁니다.

86
00:07:50,349 --> 00:07:53,278
정말 간단하고, 적은 연산으로 할 수 있습니다.

87
00:07:53,529 --> 00:07:57,879
시작 점을 27로 하고 

88
00:07:58,400 --> 00:08:03,580
이진 탐색의 원리에 따라 물어볼 겁니다. “32가 27보다 작은가요? 큰가요?

89
00:08:03,890 --> 00:08:09,159
c'est plus grand donc je vais à droite plus petits ou plus grands de 38 c'est plus petit je vais à gauche
It's bigger (32 > 27), so I'm going to the right. Smaller or bigger than 38? Smaller,so I'm going to the left.
32가 더 크므로, 오른쪽으로 내려갑니다. 38보다 작은가요? 큰가요? 작군요.
그래서 왼쪽으로 내려갑니다.

90
00:08:09,380 --> 00:08:15,399
ah ça encore plus petit jeu la gauche et là tout de suite directement je sais que je peux inséré
Smaller than 36, left. Smaller than 34, left. We immediately know that I can insert
36보다 작고, 34보다 작으므로, 즉시 새로운 구조체를 만들어

91
00:08:16,160 --> 00:08:18,160
ma nouvelle valeur
my new value,
“int a” 값을 32로 줍니다.

92
00:08:27,170 --> 00:08:33,669
보시다시피 매우 빠르죠? 반면에 만약 배열을 사용한다면, (의역)

93
00:08:34,400 --> 00:08:38,229
값을 어디에 넣을지는 이진 탐색으로 더 빠르게 찾을 수 있었겠지만,

94
00:08:38,719 --> 00:08:43,719
모든 배열의 값을 복사해서 올바른 위치에 값을 넣어야 합니다.

95
00:08:44,780 --> 00:08:51,579
만약 연결리스트를 사용했다면, 리스트의 중간쯤에 값을 매우 쉽게 넣을 수 있었겠지만,

96
00:08:52,310 --> 00:08:53,360
이진 탐색을 사용해서 올바른 공간을 찾을 수 없었을 겁니다.

97
00:08:53,360 --> 00:08:59,500
왜나하면 연결리스트에서는 인덱스가 없어서

98
00:08:59,650 --> 00:09:01,869
쉽게 이동할 수 없기 때문입니다.

99
00:09:02,510 --> 00:09:07,539
그래서 이걸 위한 완벽한 구조체가 있습니다.

100
00:09:07,910 --> 00:09:11,559
이 방법은 가능한 효과적으로 값을 탐색할 수 있게 해줍니다.

101
00:09:12,440 --> 00:09:19,900
만약 지금 “43”을 넣고 싶다면, 아까 했던 것처럼 몇 번의 연산을 하면 됩니다.
27 > 43이 맞나요? 아니죠~ 오른쪽으로 내려갑니다.

102
00:09:20,360 --> 00:09:22,570
38 > 43 은요? 아니죠~ 오른쪽~

103
00:09:23,380 --> 00:09:25,809
45 > 43?은요? 맞죠~ 왼쪽으로 내려갑시다.

104
00:09:26,990 --> 00:09:32,770
41이 나왔고, 43을 넣을 겁니다.

105
00:09:34,640 --> 00:09:37,150
41의 오른쪽에 43을 넣어줍시다.

106
00:09:41,120 --> 00:09:48,650
이 방법이 좀 더 빠르다는걸 볼 수 있습니다.

107
00:09:48,839 --> 00:09:50,310
아주 작은 결점이 있습니다.

108
00:09:50,310 --> 00:09:55,609
만약에, 더 큰 값을 넣고 싶다면, 그 값들을 항상 오른쪽에 추가해야 합니다.

109
00:09:55,680 --> 00:10:00,500
예를 들어, 오른쪽에 55, 56을 넣고 57, 58, 59...를 계속 넣으면..

110
00:10:01,350 --> 00:10:02,520
etc

111
00:10:02,520 --> 00:10:05,599
결국 긴 연결리스트로 끝나게 되고,

112
00:10:05,970 --> 00:10:13,220
완전히 트리와 이진 탐색의 장점을 잃게 됩니다.

113
00:10:14,250 --> 00:10:17,750
이것이 이진 트리에 관한 마지막 개념을 봐야 하는 이유입니다.

114
00:10:18,510 --> 00:10:26,450
“having a balanced tree”라고 불리는 개념은, 균형 잡힌 트리를 갖기 위해서는

115
00:10:27,660 --> 00:10:29,339
트리의 왼쪽과 오른쪽 가지의 깊이 차가 1개 이하여야 한다는 내용입니다.

116
00:10:29,339 --> 00:10:34,609
이걸 꽤 쉽게 확인할 수 있습니다.

117
00:10:35,279 --> 00:10:38,479
이 예제가 균형이 잡혔는지 보겠습니다.

118
00:10:39,270 --> 00:10:46,249
9부터 시작할 수 있습니다. 9는 작은 이진 트리이고,
왼쪽도 오른쪽도 깊이가 0이어서 아주 균형 잡힌 트리입니다.

119
00:10:46,470 --> 00:10:53,930
위로 올라가면(12) 왼쪽으로 깊이가 1이고 오른쪽으로 0이어서 균형 잡혔습니다.

120
00:10:54,180 --> 00:10:55,410
다음도 보면(15) 왼쪽으로 2, 오른쪽으로 1이여서 균형 잡혔습니다.

121
00:10:55,410 --> 00:10:58,610
오른쪽으로 내려가면(20) 왼쪽도 오른쪽도 깊이가 0이어서 균형입니다.

122
00:10:59,459 --> 00:11:02,659
여기(21)는 왼쪽으로 3 오른쪽으로 2여서 균형이고,

123
00:11:03,300 --> 00:11:08,539
23은 왼쪽으로 0, 오른쪽으로 1이어서 균형, 24는 왼쪽 오른쪽 모두 0이어서 균형입니다.

124
00:11:09,480 --> 00:11:12,320
27은 왼쪽으로도 오른쪽으로도 4여서 균형입니다.

125
00:11:13,380 --> 00:11:16,820
38도 왼쪽 오른쪽 깊이가 3이어서 균형이고,

126
00:11:17,880 --> 00:11:19,589
그리고 여기 36에 도착했는데,

127
00:11:19,589 --> 00:11:21,410
더 이상 균형이 아닙니다.

128
00:11:21,410 --> 00:11:27,200
왼쪽으로 깊이가 2이고 오른쪽으로 0이군요.
그래서 만약 속도의 관점에서 최적화를 하고 싶다면,

129
00:11:27,690 --> 00:11:34,820
트리를 다시 균형 잡아야 합니다.

130
00:11:35,130 --> 00:11:36,779
몹시 어렵진 않을 겁니다.

131
00:11:36,779 --> 00:11:38,779
34를 옮기고 

132
00:11:39,450 --> 00:11:44,059
32를 여기에 넣고,

133
00:11:45,629 --> 00:11:47,809
36을 오른쪽으로 옮깁니다.

134
00:11:49,319 --> 00:11:53,179
이런 방식으로 트리를 다시 조정했습니다.

135
00:11:59,270 --> 00:12:06,189
이제 좋습니다. 만약 계속 확인을 한다면… 여기(45)는 왼쪽, 오른쪽 모두 깊이가 2입니다.

136
00:12:07,610 --> 00:12:09,560
균형입니다.

137
00:12:09,560 --> 00:12:12,640
41은 왼쪽은 0 오른쪽은 1이므로 균형이고, 55는 왼쪽으로 1 오른쪽으로 0이어서 균형입니다.

138
00:12:13,490 --> 00:12:17,740
이제 이 트리는 균형 잡힌 트리입니다.

139
00:12:18,080 --> 00:12:24,520
만약 어떤 새로운 데이터를 추가하면, 이 트리를 다시 재배치해야 합니다.

140
00:12:24,740 --> 00:12:29,260
가능한 균형 잡힌 트리의 이점은 데이터를 탐색하기 위해 가장 효과적이라는 것입니다.

141
00:12:29,750 --> 00:12:33,669
불편한 점은 균형 잡힌 트리를 만드는 것이 약간의 연산이 필요하다는 것입니다.

142
00:12:35,660 --> 00:12:37,340
결론적으로,

143
00:12:37,340 --> 00:12:43,329
이진 트리는 간단히말해 유사한 타입을 가리키는 두 개의 포인터를 가진 구조체입니다.

144
00:12:43,880 --> 00:12:49,270
데이터를 탐색할 때나 구조에 새로운 데이터를 넣을 때

145
00:12:50,030 --> 00:12:52,030
더 효율적이고

146
00:12:53,060 --> 00:12:59,440
더 좋은 성능을 보여준 이번 예시처럼,

147
00:12:59,690 --> 00:13:02,140
트리는 스마트한 구조를 만들 수 있도록 해줍니다.
<< translated by inyang, yeslee, ji-kim, mseo and mki :) >>