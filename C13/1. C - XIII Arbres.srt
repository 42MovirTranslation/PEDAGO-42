1
00:00:05,660 --> 00:00:07,690
이번 영상에서는 트리에 관해 이야기해봅시다

2
00:00:08,440 --> 00:00:12,080
프로그래밍 도구로서의 트리 말이에요

3
00:00:12,620 --> 00:00:15,720
트리란 무엇일까요? 트리는 그래프의 일종입니다

4
00:00:16,129 --> 00:00:23,229
그래프는 한 데이터 집합에서 다른 데이터 집합으로
"이동"할 수 있도록 데이터를 구조화하는 방법입니다

5
00:00:23,600 --> 00:00:27,609
그리고 트리는 그래프의 한 종류입니다

6
00:00:27,820 --> 00:00:36,760
단일 시작점 / 진입점에서부터 모든 데이터를 살펴볼 수 있기 때문입니다

7
00:00:38,260 --> 00:00:48,020
이 부분에서 연결리스트가 생각나실 수도 있겠네요, 정상입니다

8
00:00:48,020 --> 00:00:49,460
연결리스트는 트리와 다를 바가 없습니다

9
00:00:49,640 --> 00:00:58,160
시작점에서 어떠한 한 개의 요소를 가리키고
그 요소도 다른 하나의 요소를 가리키게 되겠죠

10
00:00:58,460 --> 00:01:00,460
이게 연속되고…

11
00:01:00,740 --> 00:01:05,140
두 개의 요소를 가리키는 트리가 있을 수 있습니다

12
00:01:05,600 --> 00:01:11,100
그리고 이 트리는 두 개의 요소를 각각 연결하는
link 'a'와 link 'b'를 가질 것입니다

13
00:01:11,420 --> 00:01:15,489
특정 조건으로 N개의 조건을 가지는 트리도 있을 수 있겠군요

14
00:01:16,100 --> 00:01:19,659
여러분들이 알고 있는 꽤 좋은 예가 있습니다

15
00:01:20,180 --> 00:01:22,540
이건 T9를 간단하게 만든 것입니다
(T9: 휴대전화 영어 텍스트 입력 방식의 종류)

16
00:01:23,750 --> 00:01:26,949
T9를 여러분들이 기억하실지는 모르지만…

17
00:01:27,290 --> 00:01:30,429
과거에는 이렇게 오직 12개의 버튼만 있는 핸드폰을 사용했습니다

18
00:01:30,799 --> 00:01:37,419
10개의 숫자를 포함해, 버튼에 알파벳도 있었습니다

19
00:01:38,140 --> 00:01:43,760
그리고 T9가 동작하려면

20
00:01:44,260 --> 00:01:46,260
입력한 알파벳 조합에 맞게

21
00:01:46,939 --> 00:01:50,319
작성 가능한 모든 단어를 포함한 사전을 만들어야 했습니다

22
00:01:51,110 --> 00:01:57,339
예를 들어 3을 누르고 2를 누르면

23
00:01:57,979 --> 00:02:01,599
'd'와 'a'의 조합에 대한 모든 가능한 단어들이 메모리에 저장되어 있습니다

24
00:02:02,000 --> 00:02:08,440
이런 방법은 다른 방식보다 더 효과적입니다

25
00:02:08,620 --> 00:02:12,980
모든 단어를 기록하며 가능한 키 조합에 대응하기 때문입니다

26
00:02:13,940 --> 00:02:17,040
그러나 오늘은 이진 트리에 관해 이야기해볼 겁니다

27
00:02:17,520 --> 00:02:20,660
그래서… 왜 이진 트리일까요? 이것이 가장 고전적인 예시이기 때문이죠

28
00:02:21,129 --> 00:02:25,859
직접적인 예시를 사용해서 확인해 보시죠, 흥미로울 겁니다

29
00:02:26,110 --> 00:02:28,769
아주 간단한 예시를 보겠습니다

30
00:02:31,659 --> 00:02:38,789
먼저 어떻게 이진 트리를 코드로 작성하는지 생각해 봅시다

31
00:02:39,790 --> 00:02:45,360
연결 리스트에서 구조체를 만들었던 방법이랑

32
00:02:45,849 --> 00:02:49,199
거의 유사하고 간단합니다

33
00:02:50,140 --> 00:02:52,739
여기에 "struct"의 반복을 피하고자 'typedef'를 사용하고

34
00:02:55,180 --> 00:03:02,160
이것을 "s_binary_tree"라고 합시다

35
00:03:07,200 --> 00:03:11,060
이곳에 꽤 간단하게 데이터를 넣을 수 있습니다

36
00:03:11,340 --> 00:03:19,080
"void *"가 될 수도 있고 다른 아무 값을 넣을 수도 있겠죠
여기서는 간단하게 "int a"로 합시다

37
00:03:19,920 --> 00:03:25,280
다음으로 다른 "s_binary_tree"를 가리키는 포인터들을 만듭시다

38
00:03:25,810 --> 00:03:28,019
첫 번째 포인터의 이름은 left로 하고

39
00:03:35,540 --> 00:03:39,639
다른 포인터는 right라고 할게요

40
00:03:47,000 --> 00:03:50,350
끝났습니다, 구조체를 만들었어요

41
00:03:56,000 --> 00:04:02,380
이제 이진 트리 구조체가 만들어졌습니다
여러분들은 이런 의문이 들 거에요, "이 구조체가 왜 필요한가요?"

42
00:04:03,740 --> 00:04:06,760
생소하시겠지만, "이진 검색(dichotomy search)"이라고 불리는 개념이 있습니다

43
00:04:07,460 --> 00:04:14,079
예시를 하나 봅시다, int형 데이터 배열을 상상해보죠

44
00:04:15,890 --> 00:04:22,270
오름차순으로 정렬되어 있어요
이 배열의 올바른 위치에 새로운 값을 넣고 싶습니다

45
00:04:23,630 --> 00:04:31,299
이때 두 가지 방법이 있습니다
첫 번째로 새로운 값을 넣을 곳을 찾을 때까지 전체 배열을 탐색하는 것입니다

46
00:04:33,860 --> 00:04:35,860
두 번째 방법은 약간 좀 기술이 필요한데…

47
00:04:36,650 --> 00:04:41,500
예를 들어 배열의 중간에 있는 특정 값을 보고

48
00:04:42,170 --> 00:04:46,779
우리가 넣을 값보다 더 큰지 혹은 작은지 비교합니다

49
00:04:47,240 --> 00:04:50,799
같은 작업을 배열의 1/4에 위치한 값에 대해 반복하여

50
00:04:50,900 --> 00:04:55,120
값이 더 큰지 작은지 확인합니다

51
00:04:55,730 --> 00:04:58,809
이렇게 하면 꽤 많은 수의 연산을 줄일 수 있고

52
00:04:59,480 --> 00:05:04,420
좀 더 빨라집니다

53
00:05:04,730 --> 00:05:08,890
20억 크기 int 배열에서 오직 31번의 연산을 합니다

54
00:05:10,940 --> 00:05:13,959
매번 경우의 수를 절반으로 줄이기 때문에

55
00:05:14,750 --> 00:05:17,170
좀 더 효율적입니다

56
00:05:17,840 --> 00:05:24,459
여러분들은 이게 이진 트리와 무슨 상관이 있는지 궁금할 겁니다

57
00:05:25,100 --> 00:05:30,790
꽤 간단합니다, 사실 계산 대신에 "이진 탐색"을 하는 것뿐입니다

58
00:05:31,000 --> 00:05:34,299
이진 트리에서는 왼쪽이나 오른쪽으로 탐색합니다

59
00:05:34,720 --> 00:05:42,280
여러분들이 잘 이해하실 수 있도록 그림으로 표현된 트리를 보겠습니다

60
00:05:44,400 --> 00:05:47,800
이것이 이진 트리 표현법이 되겠습니다

61
00:05:49,330 --> 00:05:54,389
여기 보시다시피

62
00:05:54,879 --> 00:05:58,438
이 그림은 이진 트리 구조입니다

63
00:05:58,750 --> 00:06:06,449
여기 int a = 27이 있고
왼쪽에 다른 이진 트리 구조체를 가리키는 포인터가 있습니다

64
00:06:07,990 --> 00:06:13,949
왼쪽 포인터와 오른쪽 포인터가 있지요
이렇게 표현됩니다

65
00:06:15,430 --> 00:06:21,870
이진 트리를 탐색하는 몇 가지 방법이 있습니다, 가장 일반적인 방법은

66
00:06:22,330 --> 00:06:28,319
왼쪽 경로 또는 오른쪽 경로로 가는 겁니다
왼쪽 경로로 시작하죠

67
00:06:28,659 --> 00:06:32,879
꽤 간단합니다, 왼쪽에 값이 있는 한 계속 진행하고

68
00:06:33,009 --> 00:06:37,799
왼쪽에 아무것도 없을 때 현재 값을 출력합니다
현재 왼쪽에도 오른쪽에도 값이 없기 때문에

69
00:06:38,020 --> 00:06:43,259
다시 올라가서 이걸 계속할 겁니다: 왼쪽 중앙 오른쪽 값 확인하고 "int a" 출력

70
00:06:44,409 --> 00:06:46,409
왼쪽에 아무 값도 없군요

71
00:06:46,930 --> 00:06:48,930
그러므로 9를 출력합니다

72
00:06:49,060 --> 00:06:51,659
오른쪽도 마찬가지로 아무것도 없습니다, 위로 올라갑니다

73
00:06:53,589 --> 00:06:58,919
왼쪽 값은 이미 확인했기 때문에 12를 출력하고
오른쪽에 아무 값도 없으므로 다시 올라갑니다

74
00:06:59,620 --> 00:07:02,639
이번에도 왼쪽 값은 이미 확인했으므로
15를 출력하고 오른쪽으로 내려갑니다

75
00:07:03,400 --> 00:07:06,539
여기 도착해 보니 왼쪽에 아무 값도 없군요

76
00:07:07,060 --> 00:07:10,440
20을 출력합니다, 오른쪽은 아무 값도 없으므로 다시 올라갑니다


77
00:07:11,770 --> 00:07:13,770
다시 21로 올라왔군요

78
00:07:13,930 --> 00:07:15,959
왼쪽 값을 이미 확인했으므로 21을 출력합니다

79
00:07:16,659 --> 00:07:22,468
23으로 내려가면 왼쪽에 아무 값도 없으므로 23을 출력하고
오른쪽으로 내려갑니다, 24에 도착했어요

80
00:07:22,960 --> 00:07:26,909
24를 출력하고 오른쪽에 아무 값도 없으므로 다시 올라갑니다, 그래서…

81
00:07:28,289 --> 00:07:30,718
여기서 깨달은 것은 왼쪽 경로로 따라가면

82
00:07:31,000 --> 00:07:36,869
오름차순으로 정렬된 배열이 있다는 것입니다

83
00:07:37,389 --> 00:07:39,718
이건 나중에 꽤 유용하게 쓰일 겁니다

84
00:07:40,449 --> 00:07:42,219
지금부터 볼 것은

85
00:07:42,219 --> 00:07:49,469
이 배열에 새로운 값을 집어넣는 경우입니다
예를 들어 32를 넣어 봅시다

86
00:07:50,349 --> 00:07:53,278
정말 간단합니다, 적은 연산으로 할 수 있습니다

87
00:07:53,529 --> 00:07:57,879
시작점을 27로 하고

88
00:07:58,400 --> 00:08:03,580
이진 탐색의 원리에 따라 물어봅니다: "32가 27보다 작은가요? 큰가요?"

89
00:08:03,890 --> 00:08:09,159
32가 더 크므로 오른쪽으로 내려갑니다
38보다 작은가요? 큰가요? 작네요, 왼쪽으로 내려갑니다

90
00:08:09,380 --> 00:08:15,399
36보다 작고 34보다 작으므로 즉시 새로운 구조체를 만들어

91
00:08:16,160 --> 00:08:18,160
ma nouvelle valeur
my new value,
"int a" 값을 32로 설정합니다

92
00:08:27,170 --> 00:08:33,669
보시다시피 매우 빠르죠? 반면에 만약 배열을 사용한다면

93
00:08:34,400 --> 00:08:38,229
값을 어디에 넣을지는 이진 탐색으로 더 빠르게 찾을 수 있었겠지만

94
00:08:38,719 --> 00:08:43,719
모든 배열의 값을 복사해서 올바른 위치에 값을 넣어야 합니다

95
00:08:44,780 --> 00:08:51,579
만약 연결리스트를 사용했다면
리스트의 중간쯤에 값을 매우 쉽게 넣을 수 있었겠지만

96
00:08:52,310 --> 00:08:53,360
이진 탐색을 사용해서

97
00:08:53,360 --> 00:08:59,500
올바른 공간을 찾을 수 없었을 겁니다, 연결리스트에서는 인덱스가 없어서

98
00:08:59,650 --> 00:09:01,869
쉽게 이동할 수 없기 때문이죠

99
00:09:02,510 --> 00:09:07,539
이걸 위한 완벽한 구조체가 있습니다

100
00:09:07,910 --> 00:09:11,559
이 방법은 가능한 효과적으로 값을 탐색할 수 있게 해줍니다

101
00:09:12,440 --> 00:09:19,900
만약 지금 "43"을 넣고 싶다면 아까 했던 것처럼 몇 번의 연산을 하면 됩니다
27 > 43이 맞나요? 아니죠~ 오른쪽으로 내려갑니다

102
00:09:20,360 --> 00:09:22,570
38 > 43은요? 아니죠~ 오른쪽으로 가죠

103
00:09:23,380 --> 00:09:25,809
45 > 43은 어떨까요? 맞죠~ 왼쪽으로 내려갑시다

104
00:09:26,990 --> 00:09:32,770
41까지 내려왔네요, 여기에 43을 넣을 겁니다

105
00:09:34,640 --> 00:09:37,150
41의 오른쪽에 43을 삽입합시다

106
00:09:41,120 --> 00:09:48,650
이 방법이 좀 더 빠르다는걸 볼 수 있습니다

107
00:09:48,839 --> 00:09:50,310
다만 아주 작은 결점이 있습니다…

108
00:09:50,310 --> 00:09:55,609
만약 더 큰 값을 넣고 싶다면 그 값들을 항상 오른쪽에 추가해야 합니다

109
00:09:55,680 --> 00:10:00,500
예를 들어 오른쪽에 55, 56을 넣고 이어서 57, 58, 59를 넣으면…

110
00:10:01,350 --> 00:10:02,520
등등

111
00:10:02,520 --> 00:10:05,599
결국 엄청나게 긴 연결리스트가 만들어질 뿐

112
00:10:05,970 --> 00:10:13,220
트리와 이진 탐색의 장점을 잃게 됩니다

113
00:10:14,250 --> 00:10:17,750
이것이 이진 트리에 관한 마지막 개념인

114
00:10:18,510 --> 00:10:26,450
"having a balanced tree"를 알아두어야 하는 이유입니다
균형 잡힌 트리를 갖기 위해서는

115
00:10:27,660 --> 00:10:29,339
트리의 왼쪽과 오른쪽 가지의 깊이 차가 1개 이하여야 한다는 내용이죠

116
00:10:29,339 --> 00:10:34,609
꽤 쉽게 확인이 가능합니다

117
00:10:35,279 --> 00:10:38,479
이 예제가 균형이 잡혀 있는지 보겠습니다

118
00:10:39,270 --> 00:10:46,249
여기 9부터 시작해 보겠습니다: 9도 작은 이진 트리라 할 수 있죠
왼쪽도 오른쪽도 깊이가 0이므로 아주 균형 잡힌 트리입니다

119
00:10:46,470 --> 00:10:53,930
위로 올라가면(12) 왼쪽으로 깊이가 1이고 오른쪽으로 0이네요
균형 잡힌 트리입니다

120
00:10:54,180 --> 00:10:55,410
다음도 보면(15) 왼쪽으로 2이고 오른쪽으로 1이네요
균형 잡혀 있네요

121
00:10:55,410 --> 00:10:58,610
오른쪽으로 내려가면(20) 왼쪽도 오른쪽도 깊이가 0
좋습니다

122
00:10:59,459 --> 00:11:02,659
여기(21)는 왼쪽으로 3 오른쪽으로 2
균형적이고

123
00:11:03,300 --> 00:11:08,539
23은 왼쪽으로 0, 오른쪽으로 1이어서 균형적이며
24는 왼쪽 오른쪽 모두 0이어서 균형적입니다

124
00:11:09,480 --> 00:11:12,320
27은 왼쪽으로도 오른쪽으로도 4이므로 균형적이죠

125
00:11:13,380 --> 00:11:16,820
38도 왼쪽 오른쪽 깊이가 각각 3이므로 균형 잡혀 있죠

126
00:11:17,880 --> 00:11:19,589
그리고 여기 36에 도착했는데

127
00:11:19,589 --> 00:11:21,410
36은 더이상 균형 잡혀 있지 않습니다…

128
00:11:21,410 --> 00:11:27,200
왼쪽으로 깊이가 2이고 오른쪽으로 0이군요
만약 속도의 관점에서 최적화를 하고 싶다면

129
00:11:27,690 --> 00:11:34,820
트리를 다시 균형 있게 만들어야 합니다

130
00:11:35,130 --> 00:11:36,779
그렇게 어렵진 않을 거예요

131
00:11:36,779 --> 00:11:38,779
34를 옮기고

132
00:11:39,450 --> 00:11:44,059
32를 여기에 넣고

133
00:11:45,629 --> 00:11:47,809
36을 오른쪽으로 옮깁니다

134
00:11:49,319 --> 00:11:53,179
이런 방식으로 트리를 재조정했습니다

135
00:11:59,270 --> 00:12:06,189
좋아요, 만약 계속 확인을 한다면…
여기(45)는 왼쪽과 오른쪽 모두 깊이가 2입니다

136
00:12:07,610 --> 00:12:09,560
균형 있네요

137
00:12:09,560 --> 00:12:12,640
41은 왼쪽은 0 오른쪽은 1이므로 균형 잡혀 있고
55는 왼쪽으로 1 오른쪽으로 0이기 때문에 균형적입니다

138
00:12:13,490 --> 00:12:17,740
이제 이 트리는 균형 잡힌 트리라 할 수 있습니다

139
00:12:18,080 --> 00:12:24,520
만약 새로운 데이터를 추가하면 이 트리의 원소를 재배치해야 합니다

140
00:12:24,740 --> 00:12:29,260
최대한 균형 잡혀 있는 트리의 이점은
데이터를 탐색하기 위해 가장 효과적이라는 것입니다

141
00:12:29,750 --> 00:12:33,669
불편한 점은 균형 잡힌 트리를 만드는 것이 약간의 연산이 필요하다는 것입니다

142
00:12:35,660 --> 00:12:37,340
결론은

143
00:12:37,340 --> 00:12:43,329
이진 트리는 간단히 말해 유사한 타입을 가리키는
두 개의 포인터를 가진 구조체입니다

144
00:12:43,880 --> 00:12:49,270
데이터를 탐색할 때나 구조에 새로운 데이터를 넣을 때

145
00:12:50,030 --> 00:12:52,030
더 효율적이고

146
00:12:53,060 --> 00:12:59,440
더 좋은 성능을 보여준 이번 예시처럼

147
00:12:59,690 --> 00:13:02,140
트리는 스마트한 구조를 만들 수 있도록 해줍니다
<< translated by inyang, yeslee, ji-kim, mseo and mki :) >>
