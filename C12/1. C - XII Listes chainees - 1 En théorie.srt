1
00:00:00,480 --> 00:00:04,320
이 비디오에서는 연결 리스트에 대해 알려드리겠습니다
연결 리스트는 자료구조이고

2
00:00:04,480 --> 00:00:07,560
특별히 c에서만 사용되는 독특한 형태는 아닙니다

3
00:00:07,820 --> 00:00:09,580
어떤 언어에서든 고유한 특징을 가지는 자료구조이죠

4
00:00:09,820 --> 00:00:13,040
연결 리스트는 자료들을 배열처럼 기록할 수 있도록 해줍니다

5
00:00:13,300 --> 00:00:16,980
배열과 비교하면 장단점이 있긴 하지만요, 이건 뒷부분에서 말하도록 하겠습니다

6
00:00:17,220 --> 00:00:20,860
먼저 C에서는 어떻게 연결 리스트를 만들 수 있는지 보여드릴게요

7
00:00:21,680 --> 00:00:27,400
C에서 연결 리스트를 만들기 위해서는 "s_list"와 같은 구조체가 필요합니다

8
00:00:28,520 --> 00:00:31,920
이 구조체는 제 연결 리스트에서의 노드(연결)을 나타냅니다

9
00:00:32,040 --> 00:00:33,940
이 "노드"에 대해서는 머지않아 알게 될 거예요

10
00:00:33,940 --> 00:00:36,140
아무튼 구조체 s_list 안에

11
00:00:36,800 --> 00:00:39,800
int i, char c가 있다고 해봅시다

12
00:00:39,940 --> 00:00:41,180
간단히 말하자면 데이터예요

13
00:00:42,320 --> 00:00:44,460
그리고 무엇보다도

14
00:00:44,660 --> 00:00:46,240
이게 있어야 연결 리스트가 됩니다

15
00:00:46,820 --> 00:00:50,260
구조체 s_list에는 포인터가 있어요, 잠시만요!

16
00:00:51,380 --> 00:00:57,460
이 포인터는 "next"라고 부를 구조체 s_list를 가리킵니다
다음 항목으로 이동할 수 있도록 도와주죠

17
00:00:57,580 --> 00:01:01,800
이걸로 연결 리스트의 원칙에 대해 조금 이해하게 되었군요

18
00:01:01,900 --> 00:01:07,840
사실 struct s_list는 데이터이면서 다음 노드를 가리키는 포인터이기도 합니다

19
00:01:07,840 --> 00:01:11,240
그러니까 struct s_list는 다음 구조체 (struct s_list)를 가리킵니다

20
00:01:11,620 --> 00:01:14,320
슬슬 이해되실 거예요, 가장 먼저…

21
00:01:14,340 --> 00:01:15,220
첫 번째 구조체 s_list가 있죠

22
00:01:15,220 --> 00:01:21,440
여기에는 두 번째 구조체를 가리키는 포인터가 있어요
두 번째 구조체의 포인터는 세 번째 구조체를 가리키고, 세 번째는 네 번째를 가리키고…

23
00:01:21,540 --> 00:01:25,900
여기서 여러분은 여러 개의 자료 세트들을 차례로 연결할 수 있음을 알 수 있습니다

24
00:01:25,900 --> 00:01:27,760
순서대로 말이죠, 배열이랑 좀 더 비슷하겠네요

25
00:01:28,200 --> 00:01:31,280
배열처럼 연속된 메모리가 아니라는 점을 제외하면요

26
00:01:31,340 --> 00:01:32,980
또한 다섯 번째 노드에 접근하기 위해서는

27
00:01:33,020 --> 00:01:34,340
먼저 네 번째 노드에 접근해야만 하죠

28
00:01:34,340 --> 00:01:36,380
네 번째에 접근하기 위해서는 세 번째에 먼저 접근해야 하고

29
00:01:36,400 --> 00:01:37,940
세 번째에 접근하기 위해서는 두 번째에 접근해야 할 겁니다

30
00:01:37,940 --> 00:01:39,500
두 번째에 접근하기 위해서는 첫 번째에 먼저 접근해야만 하고요

40
00:01:40,180 --> 00:01:42,420
이게 연결 리스트의 단점 중 하나입니다

41
00:01:42,760 --> 00:01:45,920
이제 연결 리스트와 배열 간의 차이점을 보여드릴게요

42
00:01:45,940 --> 00:01:49,680
정확히는 그림을 통해 장단점을 보여드리겠습니다, 이해하기 쉽게 말이죠

43
00:01:51,060 --> 00:01:51,560
짠

44
00:01:51,700 --> 00:01:54,880
여기 제가 미리 준비해둔 그림이 있습니다

45
00:01:55,260 --> 00:02:00,920
ptr_tab 포인터가 어딜 가리키냐면… 어… 색깔이에요

46
00:02:01,160 --> 00:02:03,980
첫 번째 색깔의 주소를 가지고 있는 곳을 가리킵니다

47
00:02:03,980 --> 00:02:06,480
지금의 경우에는 색을 가진 메모리 6개가 있죠

48
00:02:06,680 --> 00:02:08,700
지금 저는 배열의 크기가 6이라는 것을 알고 있습니다

49
00:02:09,080 --> 00:02:09,580
좋아요

50
00:02:10,400 --> 00:02:15,100
ptr_list 포인터는 색을 하나 가지고 있는 struct s_list를 가리킵니다

51
00:02:15,340 --> 00:02:20,060
이 포인터는 struct s_list를 가리켜요, 여기서 노드의 원칙을 볼 수 있습니다

52
00:02:20,160 --> 00:02:23,500
무슨 뜻이냐면… 이 struct s_list는 다음 s_list의 위치를 알고 있다는 거죠

53
00:02:23,540 --> 00:02:28,960
결국 이 구조체의 위치를 나타내는 포인터를 가진 구조체의
위치 포인터를 나타내는 구조체의 위치를 알고 있는 포인터… 를 반복합니다

54
00:02:29,360 --> 00:02:31,240
여기서 소소한 특징을 볼 수 있습니다

55
00:02:31,540 --> 00:02:33,880
제 리스트의 마지막 노드는

56
00:02:34,280 --> 00:02:36,160
값이 0인 포인터예요

57
00:02:36,600 --> 00:02:38,260
0을 가리키는 포인터입니다

58
00:02:38,300 --> 00:02:40,680
포인터 관련 비디오에서 "null" 포인터에 대해 말했었죠

59
00:02:40,820 --> 00:02:42,720
null 포인터는 특별한 포인터입니다

60
00:02:42,920 --> 00:02:43,640
관습적으로 사용되죠

61
00:02:43,880 --> 00:02:46,180
어떠한 변수도 0을 주소로 가질 수 없습니다, 절대로요

62
00:02:46,260 --> 00:02:49,040
그러므로 우리가 포인터 값을 0으로 준다는 건 곧
이 변수는 사용되지 않는다는 의미입니다

63
00:02:49,060 --> 00:02:50,480
혹은 가리키는 게 없을 때도 쓰이죠

64
00:02:50,800 --> 00:02:55,480
그리고 이건… 우리가 리스트를 사용할 때
마지막 노드에 도달했음을 아는 방법의 하나입니다

65
00:02:56,080 --> 00:02:58,560
게다가 이건 단순한 포인터죠

66
00:02:58,880 --> 00:03:00,100
만약 이 구조체가 0의 값을 가진다면

67
00:03:00,420 --> 00:03:02,540
제 리스트에 0개의 노드가 있다는 뜻입니다

68
00:03:03,000 --> 00:03:04,260
이렇게나 간단해요

69
00:03:05,020 --> 00:03:06,900
그럼 한번 사용해 봅시다

70
00:03:07,840 --> 00:03:11,060
만약 제가 여기 제 배열의 첫 번째 빨간색에 접근하고 싶다고 해봅시다

71
00:03:11,900 --> 00:03:13,900
프로세서가 실제로 뭘 하든 간에 이건 다 멍청한 짓이에요

72
00:03:14,060 --> 00:03:15,920
프로세서는 ptr_tab에 저장된 주소를 가져올 겁니다

73
00:03:16,800 --> 00:03:19,980
색의 크기의 세 배만큼을 더할 거고요

74
00:03:20,640 --> 00:03:23,680
그러면 프로세서는 새로운 주소를 갖게 될 거예요
메모리에서 이 부분의 주소 말이죠

75
00:03:23,820 --> 00:03:26,460
그 주소에는 뭐가 있는지 확인해 보면 빨간색 요소가 있다는 걸 알게 되겠죠

76
00:03:26,460 --> 00:03:27,840
이게 이 부분에 접근하는 방법이에요

77
00:03:28,680 --> 00:03:31,180
ptr_lst… 리스트에는

78
00:03:31,960 --> 00:03:33,380
첫 번째 노드의 주소가 있습니다

79
00:03:34,140 --> 00:03:39,960
이제 첫 번째 노드의 주소를 가지고 있을 두 번째 포인터가 있어야겠죠

80
00:03:40,520 --> 00:03:43,920
첫 번째 노드에 있는 주소는 두 번째 노드에 접근할 수 있도록 해 줍니다

81
00:03:44,520 --> 00:03:47,020
그리고 두 번째 노드에 담긴 주소는 세 번째 노드와 연결하기 위한 주소예요

82
00:03:47,440 --> 00:03:49,420
세 번째 주소에 담긴 값은

83
00:03:49,520 --> 00:03:51,200
빨간색이 있는 네 번째 노드에 접근할 수 있도록 해 주죠

84
00:03:51,200 --> 00:03:55,560
마침내 이 구조체에서 이 노드의 자료를 볼 수 있게 됐군요

85
00:03:56,100 --> 00:03:59,860
여기서 연결 리스트를 넘나들기 위해서는
엄청 많이 돌아다녀야 한다는 사실을 알 수 있습니다

86
00:04:00,300 --> 00:04:01,000
배열보다 말이에요

87
00:04:01,660 --> 00:04:05,040
연결 리스트의 엄청난 단점이 바로 이것입니다

88
00:04:05,180 --> 00:04:08,020
메모리가 연속적이지 않아요, 그렇기 때문에 단순 연산만 할 수 있습니다

89
00:04:08,020 --> 00:04:09,660
많은 노드를 돌아다닐 수밖에 없습니다

90
00:04:09,900 --> 00:04:13,100
만약 이천 개의 노드가 있다면
저는 리스트의 끝에 실질적으로 도달하기 위해 이천 개의 노드들을 거쳐야겠죠

91
00:04:13,120 --> 00:04:14,280
제 연결 리스트 마지막의

92
00:04:14,400 --> 00:04:15,780
마지막 노드에 도달하기 위해서요

93
00:04:15,960 --> 00:04:17,580
단점 중 하나입니다

94
00:04:17,640 --> 00:04:19,660
하지만 연결 리스트에는 엄청난 이점이 있습니다

95
00:04:20,240 --> 00:04:21,100
보세요

96
00:04:21,640 --> 00:04:24,240
만약 제가 파란색과 빨간색 사이 여기에

97
00:04:24,500 --> 00:04:26,940
요소를 추가하고 싶다고 해볼게요

98
00:04:26,940 --> 00:04:28,540
제 배열에 새 요소를 넣고 싶어요

99
00:04:28,800 --> 00:04:31,740
뒤에서는 어떤 식으로 동작할까요?

100
00:04:32,080 --> 00:04:33,520
가장 먼저

101
00:04:34,220 --> 00:04:35,420
새 포인터가 있어야 합니다

102
00:04:35,480 --> 00:04:36,740
그래서 여기… 다른 포인터를 생성했어요

103
00:04:37,360 --> 00:04:39,240
이건 임시 포인터예요

104
00:04:39,380 --> 00:04:42,380
제가 할당하고자 하는 새로운 메모리 구역을 가리킬 거고요

105
00:04:42,460 --> 00:04:44,540
사실 제가 이걸 늘릴 수 없기 때문이에요

106
00:04:44,980 --> 00:04:48,300
여섯 개의 색만큼 주소를 할당했었는데 이제는 일곱 개의 공간이 필요해요

107
00:04:48,520 --> 00:04:49,840
1, 2, 3…

108
00:04:49,840 --> 00:04:50,640
4, 5…

109
00:04:50,640 --> 00:04:51,140
6!

110
00:04:51,140 --> 00:04:52,840
됐다, 이제 7개의 자리가 있어요

111
00:04:53,260 --> 00:04:55,660
이제 이 값들을 복사해야죠

112
00:04:56,240 --> 00:04:58,520
첫 번째… 첫 번째 파란색을 여기에 복사해야 해요

113
00:04:58,780 --> 00:05:00,780
두 번째 파란색은 여기에 넣어야 합니다

114
00:05:01,060 --> 00:05:03,220
세 번째 파란색은 여기에 넣고요

115
00:05:03,500 --> 00:05:06,400
이제 복사는 끝났습니다

116
00:05:06,860 --> 00:05:07,740
더해볼게요

117
00:05:07,760 --> 00:05:08,260
아… 미안해요

118
00:05:08,260 --> 00:05:08,760
홉!

119
00:05:08,880 --> 00:05:10,860
일련의 값들을 다 복사했으니 이제 여기에

120
00:05:11,700 --> 00:05:13,620
평범하게 검은색을 넣어봅시다

121
00:05:13,620 --> 00:05:14,360
해볼까요! 미안합니다

122
00:05:14,940 --> 00:05:16,180
검은색을 넣을게요

123
00:05:17,060 --> 00:05:19,220
이제 이 뒤에다가 마저 복사해야 하는데, 지금, 어…

124
00:05:19,260 --> 00:05:20,880
이것도 복사했으니까…

125
00:05:20,980 --> 00:05:22,800
붉은색을 넣어 줄게요… 한 번 더…

126
00:05:22,800 --> 00:05:23,760
그리고 한 번 더…

127
00:05:24,500 --> 00:05:25,040
이제

128
00:05:25,540 --> 00:05:28,540
복사가 다 끝났네요, 마지막 작업은 아직 남아있지만요

129
00:05:29,180 --> 00:05:30,340
마지막으로 해야 할 일은

130
00:05:30,760 --> 00:05:32,180
이 표를 삭제하는 거예요

131
00:05:32,560 --> 00:05:33,860
그래서 짠! 지울게요

132
00:05:34,420 --> 00:05:35,320
할당을 해제해줬습니다

133
00:05:35,340 --> 00:05:38,100
이 메모리를 해제했으니 이제 ptr_tab은

134
00:05:38,160 --> 00:05:39,200
앗, 미안합니다

135
00:05:39,220 --> 00:05:42,160
ptr_tab은 이제

136
00:05:43,200 --> 00:05:45,800
제 새 배열을 가리키고요

137
00:05:45,980 --> 00:05:46,480
얍

138
00:05:46,540 --> 00:05:48,140
이건 지워졌어요

139
00:05:48,260 --> 00:05:49,860
이 포인터는 이제 더는 쓸모없고요

140
00:05:50,860 --> 00:05:51,360
짠

141
00:05:51,540 --> 00:05:52,040
또 짠!

142
00:05:52,080 --> 00:05:52,580
끝이에요

143
00:05:52,680 --> 00:05:53,180
어휴

144
00:05:53,340 --> 00:05:54,020
제법 오래 걸렸네요

145
00:05:55,180 --> 00:05:56,380
연결 리스트로

146
00:05:57,120 --> 00:05:58,640
같은 동작을 해볼게요

147
00:05:59,160 --> 00:06:00,680
이 방식이 훨씬 간단하다는 걸 알게 될 거예요

148
00:06:01,380 --> 00:06:05,920
새로운 포인터를 하나 만드는 것으로 충분해요

149
00:06:07,840 --> 00:06:09,060
새로운 포인터들은 어… 예를 들면

150
00:06:09,500 --> 00:06:12,680
찾아갈 겁니다, 먼저 첫 번째 노드를 찾아갈 거예요…

151
00:06:12,700 --> 00:06:14,320
잠시만요, 첫 번째 노드에

152
00:06:14,760 --> 00:06:15,700
도착했다면

153
00:06:16,140 --> 00:06:18,960
첫 번째 요소를 가지게 되겠죠
이 주소를 제 포인터에 넣어줍니다

154
00:06:18,960 --> 00:06:21,100
이번에는 두 번째 요소를 향해 갈 거예요

155
00:06:21,480 --> 00:06:25,260
여기 도달하면 두 번째 요소에 있겠죠
주소도 가지고 있어요, 제 포인터에 넣어줬습니다 짠

156
00:06:25,500 --> 00:06:26,600
세 번째 요소에 가 볼게요

157
00:06:27,240 --> 00:06:30,100
세 번째 요소에서 탐색을 멈출 겁니다
저는 세 번째 요소를 수정하고 싶으니까요

158
00:06:30,100 --> 00:06:32,500
이제 이 포인터는 더는 저 주소를 가리키지 않을 겁니다

159
00:06:33,060 --> 00:06:34,460
새로운 곳을 가리킬 거예요

160
00:06:35,520 --> 00:06:37,740
실은… 새 주소를 가리키는 거죠, 그러니까 저는

161
00:06:38,120 --> 00:06:39,220
두 번째 포인터를 만들어야만 해요

162
00:06:39,800 --> 00:06:40,300
짠

163
00:06:40,680 --> 00:06:42,320
새 요소를 위치시킬 곳에 말이죠

164
00:06:42,760 --> 00:06:43,960
새 구조체가 생겼습니다

165
00:06:44,860 --> 00:06:48,300
구조체에다가

166
00:06:48,600 --> 00:06:49,580
검은색을 넣었어요

167
00:06:49,860 --> 00:06:51,320
제가 원했던 새로운 요소를 완성했어요

168
00:06:52,180 --> 00:06:53,360
이제 뭘 할 거냐면

169
00:06:53,960 --> 00:06:58,880
이전… 이전 포인터들의 값을 저장해 줘야 해요…

167
00:07:00,000 --> 00:07:01,600
이 노드가 여길 가리키도록 하면 이전 포인터의 값을 간직하게 됩니다

168
00:07:02,220 --> 00:07:03,080
보세요

169
00:07:03,640 --> 00:07:04,880
여기에 이전 포인터를 가리키도록 했죠

170
00:07:05,640 --> 00:07:09,940
이제 이 노드가 새로운 노드의 주소를 가리키도록 수정했습니다

171
00:07:10,880 --> 00:07:14,780
여기 이건 이제 지워도 되겠네요…

172
00:07:14,820 --> 00:07:16,040
다 끝났습니다!

173
00:07:17,040 --> 00:07:18,300
쉽죠!

174
00:07:18,300 --> 00:07:21,620
방금 노드 하나를 새로 추가했습니다

175
00:07:22,180 --> 00:07:24,220
연결 리스트는 중간에 노드를 삽입할 수 있게 해줘요

176
00:07:24,720 --> 00:07:25,980
메모리 할당하듯 해 주었죠

177…
00:07:26,320 --> 00:07:27,580
실제로는 내용물을 복사하지 않았어요

178
00:07:27,580 --> 00:07:31,020
서로 다른 두 장소에 포인터의 주소를 복사했을 뿐이에요, 이게 다예요!

179
00:07:31,800 --> 00:07:35,420
눈치채셨겠지만, 배열보다 믿을 수 없을 만큼 시간을 절약했습니다

180
00:07:36,260 --> 00:07:38,580
이것이 연결 리스트의 장점입니다

181
00:07:39,380 --> 00:07:42,860
배열 전체를 돌아다니다가 중간에 요소들을 추가할 일이 잦을 때

182
00:07:43,320 --> 00:07:45,860
유용하게 사용할 수 있을 거예요

183
00:07:45,900 --> 00:07:46,540
왜냐하면 결국

184
00:07:46,640 --> 00:07:49,880
배열 전체를 불러오는 거나 연결 리스트 전체를 불러오는 거나 거의 비슷하거든요

185
00:07:50,580 --> 00:07:51,700
말인즉슨…

186
00:07:51,740 --> 00:07:54,940
만약 임의의 요소에 접근하기만을 원한다면

187
00:07:55,440 --> 00:07:57,340
연결 리스트는 별로 효율적이지 않아요

188
00:07:57,480 --> 00:07:59,660
왜냐하면 그건 제가 세 번째와 여섯 번째

189
00:07:59,660 --> 00:08:00,640
그리고 두 번째 요소에 접근하기를 원한다면

190
00:08:00,880 --> 00:08:03,320
매번 세 번째 요소까지 돌아가서

191
00:08:03,320 --> 00:08:04,680
여섯 번째로 간 다음에

192
00:08:04,680 --> 00:08:05,640
두 번째까지 가야 하죠

193
00:08:05,640 --> 00:08:07,180
이럴 때는 배열이 더 효율적이죠

194
00:08:07,800 --> 00:08:10,720
여러분이 어떻게 사용하느냐에 달렸어요
만약 리스트 중간에 집어넣을 요소나 삭제할 요소 등등이 많다면

195
00:08:10,720 --> 00:08:12,880
확실히 연결 리스트가 더 유용하겠죠

196
00:08:13,440 --> 00:08:15,200
추가하거나 삭제할 요소가 많지 않은데

197
00:08:15,200 --> 00:08:17,600
읽어야 할 요소나 임의의 원소로 이동이 잦다면

198
00:08:17,780 --> 00:08:20,080
아마 배열이 더 유용할 거고요

199
00:08:20,680 --> 00:08:23,600
이제부터 연결 리스트와 배열 중 적절히 선택하여 사용하세요

200
00:08:23,820 --> 00:08:26,260
연결 리스트의 개념에 대해 이해하셨으니까요

201
00:08:26,300 --> 00:08:27,160
어떻게 동작하는지도 말이죠

202
00:08:27,300 --> 00:08:29,820
지금까지 자료 구조의 새로운 타입을 보셨습니다

203
00:08:29,820 --> 00:08:31,660
이 구조는 여러분이 더 많은 행동을 할 수 있도록 돕고

204
00:08:31,980 --> 00:08:34,480
단순 배열보다 훨씬 빠르게 동작하며 시간을 절약할 수 있도록 해주죠
<<Translated by (helee, ji-kim, mki, mseo, yeslee and inyang :) >>
