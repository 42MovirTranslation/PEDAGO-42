1
00:00:00,000 --> 00:00:01,240
이번 영상에선

2
00:00:01,240 --> 00:00:05,280
그래프 대신 더욱 실질적인 예시를 보여드리겠습니다

3
00:00:05,528 --> 00:00:09,268
c 언어를 사용해서 연결 리스트 안에서 어떻게 이동하는지 보여드리죠

4
00:00:09,460 --> 00:00:14,729
하지만 그 전에 우선 연결된 리스트를 만들어야겠죠
"s_list" 구조체를 생성했습니다

5
00:00:15,070 --> 00:00:20,760
전과 같이 "int i"와 "char c"
그리고 다른 "s_list"를 가리키는 포인터 "next"를 포함합니다

6
00:00:21,160 --> 00:00:23,399
좋아요, 연결 리스트를 만들 준비물을 모두 갖췄습니다

7
00:00:24,440 --> 00:00:32,140
이제 연결 리스트에 세 요소를 엮을 겁니다
먼저 "struct s_list"를 불러오겠습니다

8
00:00:33,219 --> 00:00:35,219
첫 번째 요소는 "elem1"이라고 부를게요

9
00:00:36,119 --> 00:00:39,119
두 번째는 "elem2"이고 세 번째는 "elem3"입니다

10
00:00:39,299 --> 00:00:43,419
배열을 사용해도 되지만 그러지 않았습니다, 이 세 요소가 전부

11
00:00:43,520 --> 00:00:47,520
분리된 요소라는 것을 보여드리고 싶었거든요
메모리가 연속되지 않은 완전히 별개의 요소들입니다

12
00:00:48,359 --> 00:00:55,989
이제 "struct s_list begin", 아니 "* begin"을 만들게요

13
00:00:55,988 --> 00:01:00,598
이것은 첫 요소를 가리키는 포인터입니다, 이걸 통해

14
00:01:01,030 --> 00:01:03,960
요소들을 전부 뭉친 리스트를 만들 겁니다
간단해요

15
00:01:05,159 --> 00:01:08,140
"begin"은 어떠한 값을 가질까요?
"elem1"의 주소입니다

16
00:01:09,400 --> 00:01:16,300
"elem1.next"는 "elem2"의 주소를 가집니다

17
00:01:17,480 --> 00:01:19,859
"elem2.next"는

18
00:01:20,540 --> 00:01:23,200
"elem3"의 주소를 가지죠

19
00:01:23,579 --> 00:01:28,159
그리고 "elem3.next"는 0을 가집니다

20
00:01:28,659 --> 00:01:30,759
그렇다면 "begin"은

21
00:01:30,939 --> 00:01:35,980
"elem1"을 가리키고 있고요
"elem1"의 안에 있는 포인터 "next"는 "elem2"를 가리키죠

22
00:01:36,540 --> 00:01:42,480
"elem2"의 포인터는 "elem3"을 가리키며
"elem3"의 포인터는 연결 리스트가 끝났다는 의미인 0을 가리킵니다

23
00:01:42,959 --> 00:01:44,959
됐습니다, 아주 간단하죠

24
00:01:45,188 --> 00:01:52,108
이제 이것을 어떻게 사용하는지 몇 가지 속성을 보여드리겠습니다
예를 들어, "elem3" 안의 요소인

25
00:01:53,409 --> 00:01:57,929
"i"의 값에 42를 넣습니다, 이게 다예요
이제 이걸 출력해보겠습니다

26
00:02:00,968 --> 00:02:03,838
"%d\n"을 적고

27
00:02:04,599 --> 00:02:07,519
"elem3.i"

28
00:02:07,900 --> 00:02:12,599
괄호를 닫고 세미콜론을 쓴 뒤 저장합니다
컴파일하면 42가 출력됩니다


29
00:02:12,979 --> 00:02:15,859
이번에는 "elem2"를 이용하여 "elem3"에 접근하고 싶군요

30
00:02:17,000 --> 00:02:21,800
"elem2.next"는 "elem3->"의 주소를 갖고 있습니다

31
00:02:22,360 --> 00:02:26,300
이렇게 "elem3"으로 이동했습니다
이제 "elem3"의 어느 부분에 접근해야 할까요

32
00:02:26,960 --> 00:02:28,960
"i" 에 접근하고 싶네요

33
00:02:29,870 --> 00:02:34,780
다시 42가 출력되었습니다, 완벽합니다
이번엔 "elem1"로 같은 동작을 해보고 싶군요

34
00:02:35,090 --> 00:02:37,929
"elem1"은 "elem2"에 접근할 수 있습니다, 간단하네요

35
00:02:38,599 --> 00:02:40,599
"elem1.next->"

36
00:02:41,159 --> 00:02:45,719
여기에 화살표를 넣어주면, 이제 "elem2"에 접근한 겁니다
다음으로 "elem2"의 "next"에 접근해 볼게요

37
00:02:45,800 --> 00:02:50,320
지금은 "elem2"의 next에 있으므로
결국 "elem3->i"의 주소와 같지요, 홉

38
00:02:50,590 --> 00:02:57,819
다시 한번 전과 같은 곳에 도달했기 때문에 항상 42를 출력할 수 있습니다
완벽해요, 이번엔 리스트의 시작점인 "begin"에서 시작해봅시다

39
00:03:00,469 --> 00:03:02,469
"begin"은 포인터이므로 화살표를 씁니다

40
00:03:02,539 --> 00:03:09,419
이 안에서 역참조를 했으니 "elem1"의 안에 와 있는 겁니다
그러니 이 "next"는 "elem1"의 것이죠

41
00:03:10,180 --> 00:03:15,819
이다음 "next->"로 역참조를 했으므로 "elem2"의 ".next"를 가리킵니다

42
00:03:16,259 --> 00:03:19,099
다시 화살표를 만났으므로 역참조를 하면 지금은

43
00:03:19,419 --> 00:03:24,559
"elem3"의 "i"를 보고 있는 겁니다, 이제 똑같은 값이 나올 겁니다
좋아요

44
00:03:25,360 --> 00:03:28,320
일련의 방법으로 모두 "elem3"에 도달할 수 있음을 깨달았습니다

45
00:03:28,840 --> 00:03:31,800
매우 길고 지루하며 딱히 실용적이지 않네요

46
00:03:32,500 --> 00:03:35,460
게다가 예를 들어 "elem1"의 값이나

47
00:03:35,659 --> 00:03:39,039
"elem2", "elem3"의 값을 출력한다고 생각해 보세요

48
00:03:40,419 --> 00:03:43,979
"elem1"에는 98이라는 값을 넣고

49
00:03:45,240 --> 00:03:47,240
"elem2"에는 109를 넣어 볼게요, 좋아요

50
00:03:48,379 --> 00:03:52,060
이 모든 값을 출력한다고 해봅시다

51
00:03:52,960 --> 00:03:56,180
그러면 이제 이렇게 해야겠죠

52
00:03:56,560 --> 00:04:01,840
이렇게 직접적으로 적으면 이 줄은 "elem1"을
이것은 "elem2" 그리고 이것은 "elem3"를 출력합니다

53
00:04:02,099 --> 00:04:04,539
그다지 실용적이지 않네요

54
00:04:05,039 --> 00:04:11,759
특히 만약 새로운 요소를 추가한다면 코드는 아무래도…
한 땀 한 땀 손으로 직접 추가해야 하겠죠

55
00:04:11,840 --> 00:04:15,860
알맞은 개수의 요소들 등등을 생각해서 말이죠
그리고 만약 사용자 입력을 저장하는 연결 리스트였다면

56
00:04:16,060 --> 00:04:20,139
모든 게 매우 복잡해집니다
제 리스트 전부를 탐색하고 각각의 요소들을 출력할 수 있는

57
00:04:20,860 --> 00:04:23,860
함수를 만들어야 합니다

58
00:04:24,519 --> 00:04:28,840
한번 해 봅시다

59
00:04:30,000 --> 00:04:35,839
현재 요소의 값을 출력하고 다음으로 넘어가는 함수를 만들어 볼게요
탐색하고 출력하는 함수 말이죠

60
00:04:36,699 --> 00:04:45,489
어떻게 하면 될까요? 우선 aff_list라 불리는 "void" 함수를 만들어서
"struct s_list" 형식의 포인터를 인자로 받도록 합시다

61
00:04:45,490 --> 00:04:47,960
이 인자의 이름은 "begin"이라고 하죠

62
00:04:48,540 --> 00:04:50,540
좀 더 알아보기 쉽겠네요

63
00:04:52,319 --> 00:04:55,439
이것으로 함수의 시작부터 하나 혹은 그 이상의 요소에 대한 포인터를 가지고 있게 됩니다

64
00:04:55,920 --> 00:04:58,780
그리고 저는 제 리스트를 그다지 정확하게

65
00:04:58,920 --> 00:05:01,600
알고 있지 않습니다, 얼마나 많은 요소를 담고 있는지 몰라요

66
00:05:01,860 --> 00:05:05,240
좀 전에 말했듯이 만약 "begin"이 0과 같다면
아무런 요소도 없다는 뜻입니다

67
00:05:05,860 --> 00:05:08,480
좋아요, 그럼 이렇게 적을 수 있겠죠

68
00:05:10,079 --> 00:05:13,699
"if (!begin)"… 즉 "begin"이 0이라면

69
00:05:15,060 --> 00:05:19,199
"return" 하라, 그 말인즉슨 요소가 없다면 이 함수를 마쳐라

70
00:05:21,519 --> 00:05:25,819
이제 반복문을 만듭니다, 각 요소를 탐색하기 위해서요

71
00:05:25,959 --> 00:05:30,899
이 반복문에 들어오면… 제가 여기에 무엇을 적는지 보세요

72
00:05:31,779 --> 00:05:36,329
저 "if"문은 아직은 필요 없을지 모르겠지만
일단은 어떠한 목적을 갖고 적었으니 놔두겠습니다

73
00:05:36,668 --> 00:05:38,668
제 반복문이 궁금하시죠?

74
00:05:38,939 --> 00:05:43,680
현재 어느 요소에 있는지 출력할 겁니다
"begin"이 어떤 요소를 가리킬 테니 그 안에 있는 것을 출력하는 거죠

75
00:05:46,000 --> 00:05:51,800
"printf"로 "%d\n"를 해서 "begin->i"를 출력합시다

76
00:05:54,060 --> 00:05:56,759
이 요소를 출력했으니 이번에는 다음 요소로 넘어가고 싶군요

77
00:05:57,180 --> 00:06:02,900
아시다시피 다음 요소의 주소는 "begin->next"입니다

78
00:06:03,339 --> 00:06:06,980
그러니 예를 들어 이렇게 했다면

79
00:06:07,589 --> 00:06:13,789
"aff_list"의 "begin"은 맘대로 바꿔도 됩니다, 왜냐하면 매개변수로 건네받은

80
00:06:13,790 --> 00:06:15,510
복사본이기 때문이지요

81
00:06:15,509 --> 00:06:19,420
처음에 "begin"은 첫 번째 요소를 가리킵니다

82
00:06:20,240 --> 00:06:23,680
그다음 여기 두 번째 요소의 주소를 찾으러 갑니다

83
00:06:24,300 --> 00:06:27,978
그 주소를 제 begin에 넣으면 이제 제 "begin"은 두 번째 요소를 가리키겠죠

84
00:06:28,620 --> 00:06:30,620
그럼 이제

85
00:06:30,839 --> 00:06:33,799
리스트를 한 번 돌고 나면 이때

86
00:06:34,050 --> 00:06:38,028
"begin"은 마지막 요소인 0을 가집니다

87
00:06:38,699 --> 00:06:44,269
만약 "begin"이 0이 아닌 값을 가지면 반복문을 돌지만
0이라면 반복문을 탈출합니다

88
00:06:44,490 --> 00:06:46,790
그리고 이 "if"문이 무용지물이라는 것이 판명 났네요

89
00:06:48,240 --> 00:06:55,189
좋아요, 리스트를 전부 탐색하고 출력하는 반복문을 만들었습니다
매우 간단하죠

90
00:06:56,779 --> 00:07:02,379
이제 이걸 모두 지우겠습니다
그리고 제 함수를 불러와서 "aff_list"의 인자로 "begin"을 넘겨주도록 합시다

91
00:07:04,439 --> 00:07:06,290
무슨 일이 일어나는지 볼까요

92
00:07:06,290 --> 00:07:10,819
98 109 42 잘 동작하는군요, 다시 한번 정리하면

93
00:07:11,579 --> 00:07:14,199
"begin"은 첫 번째 요소 "elem1"의 주소를 가지고 있습니다

94
00:07:15,120 --> 00:07:18,439
"begin"의 값이 0인가요? 아니죠

95
00:07:18,810 --> 00:07:23,178
완벽해요, 그럼 이제 반복문으로 들어가고
"begin"이 가리키는 주소에 무엇이 있는지 봅니다

96
00:07:23,430 --> 00:07:30,170
"i"가 있고 그 값은 98이군요, "elem1.i"는 98이니까요
좋아요

97
00:07:30,959 --> 00:07:32,959
다음으로

98
00:07:33,060 --> 00:07:38,119
"begin"이 가리키는 주소 안에 있는 "next"를 받아옵니다
"next"는 다음 주소를 가리키는 포인터죠

99
00:07:38,120 --> 00:07:42,949
즉 "elem2"의 주소를 받아온 겁니다, 그 주소를 "begin"에 저장합니다

100
00:07:43,339 --> 00:07:45,779
그리고 반복합니다, "begin"의 값이 0입니까? 아니네요

101
00:07:46,100 --> 00:07:50,640
그럼 다시 "begin"이 가리키는 주소로 가서 "i"를 찾고 출력합니다.

102
00:07:51,300 --> 00:07:54,590
그 다음 똑같이 "begin"이 가리키는 주소의

103
00:07:54,810 --> 00:07:58,488
"next"에서 주솟값을 받아오면 begin은 "next"의 주소를 가지겠죠

104
00:07:59,029 --> 00:08:06,078
"elem2"의 "next"는 "elem3"의 주소입니다
"begin"의 값이 0인가요? 아니네요! 그러므로 여기로 이동합니다

105
00:08:06,500 --> 00:08:12,420
해당 주소로 가서 "i"의 값을 가져와 출력하고
현재 주소의 "next"를 받아옵니다

106
00:08:12,540 --> 00:08:15,800
이를 다시 "begin"에 넣어주고요
하지만 이번에 "elem3"의 "next"는 0을 가지고 있지요

107
00:08:16,350 --> 00:08:17,550
여기로 와서 다시 질문합니다

108
00:08:17,550 --> 00:08:21,480
"begin"이 0이 아닌 다른 값을 가지고 있나요?
아니요, 그렇지 않아요, 0입니다

109
00:08:21,699 --> 00:08:26,120
이것으로 리스트를 한 번 돌았습니다, 연결 리스트를 전부 탐색했네요

111
00:08:26,670 --> 00:08:29,299
이렇게 하는 겁니다, 이것이 연결 리스트를 탐색하는 코드의 예시입니다

112
00:08:30,000 --> 00:08:36,019
연결 리스트를 탐색할 때에는 리스트를 가리키는 포인터나
그 포인터의 포인터를 자주 사용합니다

113
00:08:36,360 --> 00:08:40,099
예를 들면 "next"에 직접적으로 접근할 수 있기 때문이지요

114
00:08:40,769 --> 00:08:43,490
나중에 활용 예제 등등을 보게 될 거에요

115
00:08:43,830 --> 00:08:49,730
이것이 연결 리스트 안을 어떻게 돌아다니는지 보여주는 첫 예시였습니다
<< translated by mseo, inyang, mki, yeslee, and ji-kim :D >>
