1
00:00:00,240 --> 00:00:04,860
이번 비디오에서는 힙, malloc 그리고 free에 관해 이야기해봅시다

2
00:00:05,289 --> 00:00:11,819
힙은 낮은 메모리 주소 영역이며 스택과 달리 제어할 수 있습니다

3
00:00:12,459 --> 00:00:15,599
더 정확하게는 지금까지 스택에 대해 말씀드렸다시피

4
00:00:15,969 --> 00:00:21,629
함수를 호출했는지 또는 변수를 선언했는지에 따라
값이 더 커지거나 작아지는 것을 보실 수 있습니다

5
00:00:22,029 --> 00:00:26,939
이와 달리 힙에서는 메모리 영역을 요청하는 함수를 사용해야 하고

6
00:00:27,300 --> 00:00:32,600
이 메모리는 스택과 다르게 여러분의 프로그램을 "가로지를" 수 있습니다:

7
00:00:32,600 --> 00:00:35,970
어디에서나 사용할 수 있다는 말이죠
이에 관련된 문제를 만나 봅시다

8
00:00:36,330 --> 00:00:40,139
문제를 보여주는 가장 좋은 방법은 역시 예시를 드는 것입니다

9
00:00:40,840 --> 00:00:47,759
우선 현재 스택에 있는 메모리 주소를 반환하는 함수를 상상해 봅시다

10
00:00:49,270 --> 00:00:53,459
이를 위해 간단하게 "i"의 주소를 반환하는 함수를 만들었습니다

11
00:00:58,220 --> 00:01:00,540
그리고 그 반환 값은 "main"에서 받아옵니다

12
00:01:04,080 --> 00:01:13,200
"ptr"은 "get ()"과 같습니다
"* ptr"을 "printf"에서 "%d\n" 형식으로 출력해 보겠습니다

13
00:01:13,570 --> 00:01:16,110
그 전에 "* ptr"의 값은 19라고 해 두죠

14
00:01:18,340 --> 00:01:19,720
좋아요

15
00:01:19,720 --> 00:01:23,260
그렇게 했더니 문제가 발생했네요

16
00:01:23,260 --> 00:01:25,499
첫 번째 문제는 컴파일러가 지금의 우리처럼 똑똑하지 않다는 것입니다

17
00:01:25,660 --> 00:01:29,429
컴파일러는 이렇게 말하고 있죠: "당신은 스택에 있는 주소를 반환하고 있어!!"

18
00:01:29,800 --> 00:01:31,800
스택에 있는 주소를 보내는 것은

19
00:01:32,350 --> 00:01:34,680
별로 좋은 생각이 아니에요

20
00:01:34,700 --> 00:01:40,400
이 공간(int i)은 "get"을 떠난 순간부터 더는 우리 소유가 아닙니다

21
00:01:41,080 --> 00:01:46,440
별로 기쁘지 않네요
(걱정하지 마세요, 다이어그램을 그려서 좀 더 잘 설명해줄게요)

22
00:01:47,170 --> 00:01:49,410
운 좋게도, 음… 운이 좋은 건지 나쁜 건지

23
00:01:50,259 --> 00:01:51,800
이건 사실 경고일 뿐입니다

24
00:01:51,800 --> 00:01:55,700
하지만 "-Werror" 플래그 때문에 오류로 바뀌어서 컴파일할 수가 없습니다

25
00:01:55,700 --> 00:01:58,690
그러나 모든 플래그, 모든 안전벨트를 해제해 준다면

26
00:01:58,690 --> 00:02:00,929
동작해요! 19가 출력됐네요

27
00:02:03,759 --> 00:02:06,839
저는 숫자 "12"를 더 선호하니까 "12"를 넣을게요

28
00:02:07,630 --> 00:02:14,000
자, 이제 "set"이라는 이름을 가진 또 다른 함수를 만들고

29
00:02:14,540 --> 00:02:22,520
printf("%d\n", *ptr)하면 "set"에서 특별한 것을 볼 수 있을까요?

30
00:02:23,420 --> 00:02:28,800
동일한 프로토타입을 가진 함수를 만들어 볼게요
(스택의 헤더와 관련된 내용 때문인데요, 이 부분은 나중에 배울 겁니다)

31
00:02:32,300 --> 00:02:37,429
"lol"이라는 변수를 선언하고 여기서 "return (0)"을 합니다

32
00:02:38,340 --> 00:02:42,000
그리고 "lol"에 "78"을 넣어줍니다

33
00:02:43,769 --> 00:02:45,769
무슨 일이 일어날까요?

34
00:02:45,800 --> 00:02:51,920
12가 출력되고 그다음에 78이 출력됐습니다, 좋아요!
제가 이걸 적는 동안 결괏값을 예상하셨을 수도 있겠네요

35
00:02:52,439 --> 00:02:56,089
어떻게 된 걸까요? "get"을 호출했습니다
스택은 더욱 커지고/높아집니다

36
00:02:56,970 --> 00:03:05,300
get은 "i"와 "i" 의 주소를 위한 메모리 공간을 차지하고, 이를 다시 돌려보냅니다
이건 스택 상의 메모리 주소에요, 주소 말입니다

37
00:03:05,609 --> 00:03:11,418
주소 안에 아무런 값이 없다는 것이지 주소 자체가 존재하지 않는다는 뜻은 아닙니다

38
00:03:11,418 --> 00:03:13,418
이게 주소라면 주소인 겁니다

39
00:03:13,418 --> 00:03:14,430
따라서

40
00:03:14,430 --> 00:03:15,959
여기서 주소를 반환했죠

41
00:03:15,959 --> 00:03:17,250
반환된 주소를 "ptr"에 저장했고요

42
00:03:17,250 --> 00:03:21,000
그리고 이 주소에 값을 넣어줬습니다, 좀 이상하긴 하지만…
원래대로라면 값을 쓰려던 시점에 프로그램이 강제종료되어야 합니다

43
00:03:21,000 --> 00:03:27,859
현재 스택의 바깥쪽에서 스택을 건드리고 있기 때문이죠…
때로는 약간 융통성이 있네요, 주소에 값이 잘 쓰였네요

44
00:03:28,409 --> 00:03:30,409
여기까지 다 실행되면

45
00:03:30,419 --> 00:03:35,719
출력도 정상적으로 되니 문제없습니다
이번에는 "set"을 불렀을 때, 무슨 일이 일어날까요?

46
00:03:36,389 --> 00:03:39,918
함수가 다시 스택 영역을 넓히고 있습니다:
"i"라고 불렸던 메모리가 이제는 "lol"이라고 불립니다

47
00:03:40,049 --> 00:03:48,200
사실, 컴파일러 시점에는 "i"도 "lol"도 없습니다
단지 스택 상의 메모리일 뿐입니다: "int" 형식의 메모리 영역 말이죠

48
00:03:48,200 --> 00:03:53,359
그리고 우리가 그 공간에 "78"을 넣었습니다, 문제없어요
그러면 컴파일러는 "i"가 차지하던 공간에 이번에는 "78"을 넣습니다

49
00:03:53,669 --> 00:03:58,039
결국 이 공간은 "ptr"이 가리키는 곳과 같고
"12"와 "78"이 출력되는 이유이기도 합니다

50
00:03:58,379 --> 00:04:03,589
다이어그램을 그려봄으로써 이해를 도울 수 있겠네요
여기 다이어그램을 한번 봅시다

51
00:04:03,840 --> 00:04:08,209
이것은 메모리 영역이고 주솟값은 아래에서 위로 올라갑니다
이것들은 메모리의 주솟값들입니다

52
00:04:08,519 --> 00:04:13,519
스택은 위에서 아래로 내려가지요
상상해보세요, 조금 전에 스택에 있었을 때…

53
00:04:14,790 --> 00:04:17,299
음, 여기 있었다고 가정해보겠습니다

54
00:04:17,910 --> 00:04:20,850
"ptr"은 여기에 있다고 합시다

55
00:04:21,430 --> 00:04:30,400
현재 "ptr"은 값을 가지고 있습니다, 내용물은 무엇이든 딱히 상관없기 때문에
일단은 "124c"라고 해두겠습니다

56
00:04:31,270 --> 00:04:34,170
그리고 "스택의 끝" 은 여기에요, "ptr" 바로 아래에 있습니다

57
00:04:34,270 --> 00:04:37,200
"ptr"은 스택의 마지막 요소이죠, 아래에는 아무것도 없고요

58
00:04:37,450 --> 00:04:41,819
이제 "get"을 호출합니다, "get"을 부르면 어떻게 될까요?

59
00:04:42,280 --> 00:04:46,559
함수 헤더가 나타납니다, 이 헤더가 몇 바이트만큼의 메모리를 차지한다고 해봅시다

60
00:04:47,470 --> 00:04:49,470
조금 더 필요할 수도 있겠네요

61
00:04:49,930 --> 00:04:52,590
이전과는 약간 다른 변화가 있습니다

62
00:04:53,320 --> 00:05:00,509
이제 여기 있는 "i"를 갖게 됩니다

63
00:05:05,440 --> 00:05:09,630
이건 "i"이고 스택에 위치하기 때문에 해당 메모리 주소를 갖고 있습니다
문제없어요

64
00:05:10,270 --> 00:05:14,489
"i" 에는 값을 넣지 않을 겁니다, 지금은 중요하지 않으니까요

65
00:05:14,950 --> 00:05:16,950
스택의 바닥은 현재 여기에 있습니다

66
00:05:17,200 --> 00:05:24,659
그리고 "i"의 주소를 반환하니 "ff18" 이 반환되었습니다
이제 더는 "124c"를 갖고 있지 않은 대신 "ff18"을 갖게 되었죠

67
00:05:25,480 --> 00:05:26,740
좋아요

68
00:05:26,740 --> 00:05:28,740
이제 함수를 빠져나왔습니다

69
00:05:31,700 --> 00:05:33,700
(헤더 이미지는 유지하되 일단 저 옆에 치워둘게요)

70
00:05:34,250 --> 00:05:36,250
함수에서 나온 상태입니다

71
00:05:36,350 --> 00:05:44,300
무슨 일이 일어나고 있나요?
저는 "ff18"을 여기에 갖고 있고 이는 메모리 주소 중 하나입니다

72
00:05:44,400 --> 00:05:48,100
이번에는 여기에 "78" 대신 "12"를 넣어 보겠습니다

73
00:05:48,350 --> 00:05:54,969
여기에 "12"를 넣었고 바로 출력해 주었습니다
이제 "set"을 호출하면 아까와 마찬가지로: 헤더가 나타납니다

74
00:05:55,970 --> 00:06:05,990
그리고 여기 같은 부분의 함수 헤더 바로 뒤에 "lolo"라는 변수를 갖습니다
("lolo"인지 "lol"인지 어떻게 불러야 할지 모르겠네요)

75
00:06:06,100 --> 00:06:15,200
이번에는 함수 내에서 무엇을 했나요?
여기에 "12" 대신 "78"을 넣어볼게요

76
00:06:15,680 --> 00:06:19,869
함수에서 빠져나왔습니다
헤더와 기타 등등은 이제 없지만 제 스택은 아직 여기에 있습니다

77
00:06:20,300 --> 00:06:26,300
ptr의 값은 변하지 않았습니다: 여전히 "ff18" 이라는 값을 가지고 있고 이는 같은 주소를 가리킵니다
확인해보면 78이라는 값은 아직 남아있습니다

78
00:06:26,300 --> 00:06:31,790
이 때문에 스택을 이용하여 스택의 주솟값을 반환하면 여러 문제가 발생할 위험이 있는 겁니다

79
00:06:31,800 --> 00:06:35,710
다른 함수를 호출하게 되면 해당 주소가 다시 사용되기 때문이죠

80
00:06:36,350 --> 00:06:38,350
이 문제를 피하고자 "힙"을 사용합니다

81
00:06:38,720 --> 00:06:45,160
어떻게 "힙"에서 메모리를 얻을 수 있을까요? 우리는 "malloc"이라는 함수를 사용할 겁니다

82
00:06:45,500 --> 00:06:49,030
(그리고 뒤에서 "free"라는 함수도 보여드리겠습니다)

83
00:06:49,550 --> 00:06:53,020
자, "malloc"이 어떻게 동작하는지 바로 봅시다

84
00:06:53,020 --> 00:07:00,900
"malloc"의 "man"을 봐봅시다, 좋아요

85
00:07:01,000 --> 00:07:08,229
"malloc"은 어떻게 동작할까요? "size_t size"라는 매개변수가 필요합니다
"size_t"는 typedef입니다, 한 번 봅시다

86
00:07:08,960 --> 00:07:12,759
그리고 "size"는… 바이트 단위의 크기를 받네요

87
00:07:12,980 --> 00:07:18,249
맞아요, "malloc"은 우리에게 메모리를 "내줄" 것”입니다
그리고 이 메모리는 "int", "float", "char", "char" 배열,

88
00:07:18,250 --> 00:07:21,460
"int" 배열, "float" 배열 등의 형식이 될 수 있겠죠
원소의 개수가 1개이든 1000개이든 간에…

89
00:07:22,280 --> 00:07:26,170
크기는 바이트 단위로 입력되고, 방금 본 것처럼 malloc은
무엇이든 담을 수 있는 메모리 영역을 제공합니다

90
00:07:26,690 --> 00:07:31,390
다시 한번 말해줄게요:

91
00:07:31,760 --> 00:07:35,619
메모리는 실제로 "0"과 "1"의 모임입니다, 우선은 "void" 형식을 띠며
어떤 형식으로 읽을지는 여러분의 프로그램이 결정합니다

92
00:07:36,200 --> 00:07:45,000
malloc은 쓰기 권한이 있는 메모리의 시작 주소를 반환하기 때문에
"*"를 반환하는 것입니다

93
00:07:45,100 --> 00:07:50,919
여러분은 16바이트의 메모리를 요구할 수 있으며 이를 원하는 대로 사용하실 수 있습니다
"int"형 4개가 될 수도 있고 "char"형 16개가 될 수도 있겠네요

94
00:07:51,050 --> 00:07:54,820
여러분 마음대로 사용하실 수 있습니다
구조체로 사용해도 되고요, 저는 모르겠습니다, 여러분 마음이니까요

95
00:07:55,460 --> 00:07:58,600
우선 구조체는 다음 비디오에서 자세히 보도록 하고

96
00:07:58,699 --> 00:08:00,410
여기 "void *"가 있습니다

97
00:08:00,410 --> 00:08:04,929
void는 무엇이든지 될 수 있습니다
"malloc"은 우리에게 메모리를 할당해 주고

98
00:08:04,930 --> 00:08:06,800
메모리는 우리 마음대로 사용해도 됩니다, 정말 끝내주죠

99
00:08:06,800 --> 00:08:08,780
"malloc"을 사용하러 가 봅시다

100
00:08:08,780 --> 00:08:11,049
다시 프로그래밍 창으로 돌아왔습니다

101
00:08:11,900 --> 00:08:16,630
먼저 malloc을 사용하기 위해서는 파일 상단에 이걸 포함해야 합니다
문제없어요, 포함해 줄 거니까요

102
00:08:17,150 --> 00:08:20,799
(비디오에서 .h 파일과 프로세서가 있는 것을 볼 수 있습니다)

103
00:08:21,710 --> 00:08:25,900
이제 malloc을 호출할 수 있게 되었네요

104
00:08:26,300 --> 00:08:30,970
"int *tab"을 선언해 주고 tab은 malloc 값을 갖는다고 적습니다

105
00:08:31,789 --> 00:08:37,269
int형 1개를 할당하기 위해 여기에 4를 적습니다

106
00:08:37,940 --> 00:08:47,439
다만 만약 운영체제가 바뀌면 이 코드는 더는 유효하지 않습니다
sizeof(int)를 대신 사용합시다

107
00:08:48,500 --> 00:08:55,570
이건 일단은 유효하지만, 만약 제가 내일 "int *tab"의 자료형을
"long int"로 바꾼다고 생각해 보세요

108
00:08:56,570 --> 00:09:01,209
그러려면 "tab"을 이용하여 malloc한 곳을 전부 찾아
long int로 바꿔주어야 합니다

109
00:09:01,459 --> 00:09:03,519
이를 위한 더 현명한 방법이 있습니다:

110
00:09:04,250 --> 00:09:08,619
사실 sizeof에 굳이 자료형을 인자로 넣을 필요는 없습니다
변수를 인자로 넣어주어도 괜찮습니다 (나중에 해당 변수의 자료형을 확인하니까요)

111
00:09:08,620 --> 00:09:13,929
여기에 *tab을 넣으면 왼쪽(tab)에 있는 변수의 자료형을 넣는 것과 같습니다

112
00:09:14,270 --> 00:09:18,500
이제 저는 이 자료형을 가진 요소 한 개만큼의 공간을
할당하였다는 사실을 알고 있습니다

113
00:09:20,620 --> 00:09:24,609
둘 이상을 할당하려면 이렇게 하면 되고

114
00:09:25,580 --> 00:09:28,479
이렇게 하면 int 자료형 크기의 9배만큼의 공간이 할당되겠네요

115
00:09:29,240 --> 00:09:34,750
자, "*int"(주솟값)가 반환되었으므로 tab 변수를 사용할 수 있습니다

116
00:09:35,000 --> 00:09:37,000
여기에 tab을 넣겠습니다

117
00:09:37,880 --> 00:09:39,050
좋아요!

118
00:09:39,050 --> 00:09:42,700
9는 사실 그렇게 중요한 값이 아니기 때문에 일단 그대로 두겠습니다

119
00:09:43,070 --> 00:09:48,520
모든 걸 컴파일했고 반드시 동작해야 합니다
이제 12와 12가 출력되는 걸 볼 수 있습니다!!

120
00:09:49,040 --> 00:09:51,940
힙의 메모리 영역을 요청했고

121
00:09:52,649 --> 00:09:55,099
요청한 만큼의 메모리 영역을 할당받았죠, 주소를 얻었습니다
그리고 저는 이 주소를 반환했죠

122
00:09:55,250 --> 00:09:58,369
스택은 이 과정 도중에 값이 바뀔 수도 있지만
힙은 그렇지 않기 때문에 아무런 문제도 되지 않습니다!!

123
00:09:58,500 --> 00:10:04,279
이 메모리 공간은 제 것이므로 다른 사람들은 사용할 권한이 없습니다

124
00:10:05,220 --> 00:10:08,540
그리고 제가 요청해서 할당받은 메모리는

125
00:10:08,790 --> 00:10:13,639
"되돌려줘야" 한다는 사실을 알아두셔야 합니다
스택의 장점은 우리가 사용했던 메모리가 자동으로 반환된다는 것이었죠

126
00:10:13,639 --> 00:10:15,639
하지만 이제는 우리가 직접 반환해줘야 합니다

127
00:10:15,899 --> 00:10:18,409
malloc과 함께 사용되는 "free"라는 함수가 있습니다

128
00:10:19,079 --> 00:10:25,279
"free"는 malloc이 반환한 주소인 "void *ptr"를 매개변수로 받습니다

129
00:10:25,279 --> 00:10:30,768
free를 사용하면 malloc에게 이렇게 말하는 것과 같습니다:

130
00:10:31,290 --> 00:10:33,349
"전에 저에게 할당해 준 이 공간, 다시 가져가셔도 돼요
마음껏 사용하세요, 저는 더는 필요가 없으니까요"

131
00:10:33,870 --> 00:10:38,839
이것이 메모리를 해제하는 방법입니다
다시 한번 말하지만, 최대한 빠르게 메모리를 해제하는 것은 정말 중요합니다

132
00:10:39,029 --> 00:10:44,809
메모리 영역이 더는 필요하지 않다면, 즉시 free하세요
왜일까요? 비디오 게임을 예시로 들어볼게요

133
00:10:45,060 --> 00:10:49,849
상대방을 죽일 때마다 이 대상의 모든 정보를 기억한다고 가정해 봅시다…

134
00:10:50,339 --> 00:10:54,349
여러분은 레벨 1, 2, 3, 4 등을 통과하면서 죽인 적의 정보를 전부 저장하지만

135
00:10:54,350 --> 00:10:58,159
이 적들은 두 번 다시 등장하지 않기에 저장한 정보는 사용될 일이 없습니다

136
00:10:58,529 --> 00:11:03,109
그리고 이 때문에 프로그램이 강제종료될 정도로 많은 메모리를 차지하게 되겠죠!

137
00:11:03,540 --> 00:11:07,279
컴퓨터는 이렇게 말할 겁니다: "멈춰! 충분해, 난 네게 메모리를 더 이상 줄 수 없어"

138
00:11:07,740 --> 00:11:11,630
그렇기 때문에 메모리 영역을 사용하지 않을 때 해제하는 것은 매우 중요합니다

139
00:11:12,269 --> 00:11:16,879
메모리를 좀 더 "유연하게" 활용할 수 있을 겁니다

140
00:11:17,120 --> 00:11:22,880
아직 할당받은 영역을 사용해야 한다면 free 하지 마세요!
하지만 가능한 한 free 하는 것을 망설이지 마세요, 메모리 반환은 중요하니까요

141
00:11:23,040 --> 00:11:26,659
메모리 공간을 free 하면 더 이상 해당 메모리를 사용할 권한이 없어집니다
주의 깊게 사용하세요!

142
00:11:27,480 --> 00:11:32,420
free는 주소를 매개변수로 사용합니다, 그건 사실 주솟값의 복사본이죠

143
00:11:32,730 --> 00:11:35,930
마지막으로 한 번만 더 말하겠습니다
만약 프로그램의 끝에서 "free(ptr)"을 한다면

144
00:11:37,730 --> 00:11:43,389
ptr에는 현재 힙에 위치한 메모리 주솟값이 들어 있으므로

145
00:11:44,329 --> 00:11:50,019
여기에서는 값이 변경되지 않습니다!!
직접 보여줄게요, 이해하기 쉽게 말이죠

146
00:11:51,649 --> 00:11:56,619
짠! free 전후를 보여드릴게요

147
00:11:59,720 --> 00:12:02,980
ptr에 들어 있는 주솟값은 변하지 않았습니다!!

148
00:12:03,560 --> 00:12:09,729
사실 free 전후의 값이 그대로인 것은 정상적인 현상입니다!
free는 ptr 값의 복사본을 가져가기 때문이죠, 그 값은 단지 주소일 뿐이고요

149
00:12:09,730 --> 00:12:15,279
그리고 free는 이렇게 말합니다: "야! 이 주소를 free 해!"
만약 여러분이 더는 여러분의 소유가 아닌 집에 돌아가면

150
00:12:15,500 --> 00:12:18,309
문제가 발생하겠죠? 여러분은 집을 해제했으니까요!!

151
00:12:18,470 --> 00:12:23,949
집주인인 malloc에게 집을 되돌려 달라고 부탁하기 전까진 접근하지 마세요
아마도 같은 집 주소를 돌려줄지도 모르지요…

152
00:12:23,949 --> 00:12:29,979
하지만 그 부분은 여러분이 제어할 수 없습니다
주소가 있는 포인터를 해제할 땐 꼭 조심하세요

153
00:12:30,320 --> 00:12:33,339
해제한 뒤에는 접근할 수도 없고 사용할 수도 없으니까요!

154
00:12:34,220 --> 00:12:37,959
메모리를 해제하고 나서 포인터가 NULL을 가리키게 하는 것도
문제를 방지하기 위한 좋은 아이디어입니다, 그럴 필요까진 없지만요…

155
00:12:38,870 --> 00:12:40,870
어떻게 할지는 여러분에게 달렸습니다…

156
00:12:40,970 --> 00:12:43,839
좋아요! 우리는 힙에 관한 꽤 긴 비디오를 보았습니다

157
00:12:43,910 --> 00:12:47,709
스택이 실제로 어떻게 동작하는지와 힙에 대해 알아보았고

158
00:12:47,870 --> 00:12:52,779
malloc으로 메모리를 할당받는 방법과
할당받은 메모리를 free를 통해 돌려주는 방법을 배웠습니다
<< translated by mki, mseo, ji-kim, inyang and yeslee :) >>
