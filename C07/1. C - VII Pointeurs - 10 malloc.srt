1
00:00:00,240 --> 00:00:04,860
이번 비디오에서는 힙, malloc 그리고 free에 대해 이야기해봅시다

2
00:00:05,289 --> 00:00:11,819
힙은 낮은 메모리 주소입니다. 스택과 달리 제어할 수 있습니다

3
00:00:12,459 --> 00:00:15,599
더 정확하게는 지금까지 스택에 대해 말했고

4
00:00:15,969 --> 00:00:21,629
함수를 호출했는지 또는 변수를 선언했는지에 따라 값이 더 커지거나 작아지는 것을 보았습니다

5
00:00:22,029 --> 00:00:26,939
힙에서는 메모리를 요청하는 함수를 사용해야 하고

6
00:00:27,300 --> 00:00:32,600
이 메모리는 여러분의 프로그램에서 스택과 다르게 어디에서나 사용할 수 있습니다

7
00:00:32,600 --> 00:00:35,970
문제를 봐봅시다

8
00:00:36,330 --> 00:00:40,139
다시 한번 문제를 보여주는 가장 좋은 방법은 예시를 드는 것입니다

9
00:00:40,840 --> 00:00:47,759
그리고, 현재 스택에 있는 주소를 반환하는 함수를 상상해봅시다

10
00:00:49,270 --> 00:00:53,459
그래서, 단순히 “i”의 주소를 반환하는 함수를 만들었습니다.

11
00:00:58,220 --> 00:01:00,540
그리고 그 반환값은 “main”에서 받습니다.

12
00:01:04,080 --> 00:01:13,200
“ptr”은 “get()”과 같고, *ptr을 “printf”의 “%d\n”로 출력해보겠습니다.

13
00:01:13,570 --> 00:01:16,110
그 전에 *ptr은 19입니다.

14
00:01:18,340 --> 00:01:19,720
좋아요.

15
00:01:19,720 --> 00:01:23,260
그렇게 했더니, 문제가 생겼습니다.

16
00:01:23,260 --> 00:01:25,499
첫 번째 문제는 컴파일러가 지금 우리처럼 똑똑하지 않다는 것입니다.

17
00:01:25,660 --> 00:01:29,429
그리고 말합니다: “당신은 스택에 있는 주소를 반환하고 있어!!”

18
00:01:29,800 --> 00:01:31,800
스택에 있는 주소를 보내려고 합니다

19
00:01:32,350 --> 00:01:34,680
별로 좋은 생각은 아니네요.

20
00:01:34,700 --> 00:01:40,400
이 공간(int i)는 “get”을 떠난 순간부터, 더는 우리 소유가 아닙니다.

21
00:01:41,080 --> 00:01:46,440
별로 기쁘지 않네요. (걱정 말아요, 다이어그램을 그려서 좀 더 잘 설명해줄게요).

22
00:01:47,170 --> 00:01:49,410
운 좋게도, 음… 운이 좋은 건지 나쁜 건지

23
00:01:50,259 --> 00:01:51,800
이건 사실 경고일 뿐입니다

24
00:01:51,800 --> 00:01:55,700
하지만 “-Werror” 플래그 때문에 오류가 발생해서 컴파일할 수 없습니다.

25
00:01:55,700 --> 00:01:58,690
그러나 지금 모든 플래그, 모든 안전벨트를 제거한다면,(-Wall -Wextra -Werror)

26
00:01:58,690 --> 00:02:00,929
동작해요! 19가 출력됐네요.

27
00:02:03,759 --> 00:02:06,839
저는 숫자 “12”를 더 선호해서 “12”를 넣을게요.
 
28
00:02:07,630 --> 00:02:14,000
자, 이제 “set”이라는 이름을 가진 또 다른 함수를 만들고

29
00:02:14,540 --> 00:02:22,520
“printf(“%d\n”, *ptr)하면 “set”에서 특별한 것을 볼 수 있을까요?

30
00:02:23,420 --> 00:02:28,800
동일한 프로토타입을 가진 함수를 만들게요(스택의 헤더와 관련된 내용 때문에요, 나중에 확인하세요)

31
00:02:32,300 --> 00:02:37,429
“lol”이라는 변수를 선언하고 “return (0)”을 해서

32
00:02:38,340 --> 00:02:42,000
“lol”에 “78”을 넣어줍니다.

33
00:02:43,769 --> 00:02:45,769
무슨 일이 일어나나요?

34
00:02:45,800 --> 00:02:51,920
12가 출력되고 그다음에 78이 출력됐습니다. 좋아요! 여러분은 제가 쓰는 동안 이미 예상했을 수도 있습니다.

35
00:02:52,439 --> 00:02:56,089
어떻게 된 걸까요? “get”을 호출했습니다. 스택은 더욱 커지고/높아집니다

36
00:02:56,970 --> 00:03:05,300
“i” 주소를 메모리 공간으로부터 가져와 다시 보냅니다. 스택에 있는 주소에요. 주소 말이죠.

37
00:03:05,609 --> 00:03:11,418
주소 안에 아무런 값이 없다는 거지 주소 자체가 존재하지 않는다는 뜻은 아닙니다

38
00:03:11,418 --> 00:03:13,418
만약 주소라면, 주소입니다.

39
00:03:13,418 --> 00:03:14,430
따라서,

40
00:03:14,430 --> 00:03:15,959
주소를 반환합니다.

41
00:03:15,959 --> 00:03:17,250
“ptr”에 저장합니다.

42
00:03:17,250 --> 00:03:21,000
이렇게 적습니다. 벌써 좀 이상한데… 보통 거기에 적었을 때 충돌했었어야 했습니다.

43
00:03:21,000 --> 00:03:27,859
분명히 스택의 바깥쪽에 있기 때문이죠… 하지만, 때로는 약간 융통성 있게 적용됩니다. 그래요, 써봤는데 효과가 있습니다.

44
00:03:28,409 --> 00:03:30,409
이후에는,

45
00:03:30,419 --> 00:03:35,719
정확하게 표시하고 있고, 문제없습니다. “set”을 불렀을 때, 무슨 일이 일어날까요?
다시 스택을 넓히고 있습니다.

46
00:03:36,389 --> 00:03:39,918
“i”라고 불렸던 메모리가 이제는 “lol”이라고 불립니다

47
00:03:40,049 --> 00:03:48,200
사실, 컴파일러는 “i”도 “lol”도 없습니다. 단지 스택 메모리일 뿐입니다: “int”로요.

48
00:03:48,200 --> 00:03:53,359
그리고 거기에 “78”을 넣습니다. 문제없어요. 그럼 “i”였던 같은 장소에 “78”을 넣습니다.

49
00:03:53,669 --> 00:03:58,039
그래서, “ptr”이 가리키는 곳이기도 하고 “12” “78”을 출력하는 이유입니다.

50
00:03:58,379 --> 00:04:03,589
그것을 이해하는 또 다른 방법은 다이어그램을 그리는 것입니다. 여기 다이어그램이 있어요.

51
00:04:03,840 --> 00:04:08,209
이것은 메모리고 주소는 올라갑니다. 여기 메모리에 있는 주소들입니다.

52
00:04:08,519 --> 00:04:13,519
스택이 내려가고 있어요, 상상해보세요, 조금 전에 스택에 있었을 때...

53
00:04:14,790 --> 00:04:17,299
음, 여기 있다고 말하겠습니다

54
00:04:17,910 --> 00:04:20,850
“ptr”은 바로 저기 있습니다.

55
00:04:21,430 --> 00:04:30,400
현재 “ptr”은 정말로 무엇이든 간에, 단지 주소이기 때문에 “124c”라고 말할 거예요, 그 값에 개의치 않습니다.

56
00:04:31,270 --> 00:04:34,170
현재 “스택의 끝”은 여기에요, “ptr” 바로 아래에 있습니다.

57
00:04:34,270 --> 00:04:37,200
“ptr”은 스택의 마지막 요소입니다. 아래에는 아무것도 없습니다.

58
00:04:37,450 --> 00:04:41,819
자, 이제 “get”을 부르겠습니다. “get”을 부르면 어떻게 될까요?

59
00:04:42,280 --> 00:04:46,559
함수 헤더가 나타납니다. 자, 몇 바이트면 됩니다.

60
00:04:47,470 --> 00:04:49,470
조금 더 필요할 수도 있고요

61
00:04:49,930 --> 00:04:52,590
이전과는 약간 다른 변화가 있습니다.

62
00:04:53,320 --> 00:05:00,509
이제 여기 있는 “i”를 갖게 됩니다

63
00:05:05,440 --> 00:05:09,630
이건 “i”입니다. “i”는 현재 스택에 있어서, 그 주소를 갖고 있습니다. 문제없어요.

64
00:05:10,270 --> 00:05:14,489
그래서 여기에 값을 쓰지 않을 겁니다, 지금 중요하지 않아요.

65
00:05:14,950 --> 00:05:16,950
스택의 바닥은 바로 여기 있습니다.

66
00:05:17,200 --> 00:05:24,659
그래서 “i”의 주소를 반환하고, “ff18”을 반환합니다.
그래서 더는 “124c”를 갖고 있지 않습니다. 지금은 “ff18”을 갖고 있습니다.

67
00:05:25,480 --> 00:05:26,740
좋아요.

68
00:05:26,740 --> 00:05:28,740
이제 함수를 종료합니다.

69
00:05:31,700 --> 00:05:33,700
(헤더를 유지하고 넣은 채)

70
00:05:34,250 --> 00:05:36,250
함수에서 빠져나옵니다.

71
00:05:36,350 --> 00:05:44,300
무슨 일이 일어나고 있나요? 여기 “ff18”이 있고 “ff18”은 메모리의 일부입니다.

72
00:05:44,400 --> 00:05:48,100
그래서 안에 “78”말고 “12”를 씁니다.

73
00:05:48,350 --> 00:05:54,969
여기에 “12”를 썼습니다. 이제 “set”을 호출합시다. “set”을 부르는 순간에도, 마찬가지입니다:

74
00:05:55,970 --> 00:06:05,990
여기 같은 장소에서 함수 헤더 바로 뒤에 “lolo” (어떻게 불러야 하는지 모르는 “lolo” 또는 “lol”)가 있을 겁니다.

75
00:06:06,100 --> 00:06:15,200
이번에는, 함수 내에서 무엇을 했나요? 여기에 “12” 대신 “78”을 넣어봅시다. 

76
00:06:15,680 --> 00:06:19,869
함수에서 떠났습니다. 헤더고 뭐고(by inyang) 더 이상 없지만, 스택은 아직 여기 있습니다.

77
00:06:20,300 --> 00:06:26,300
ptr은 변하지 않았습니다: 여전히 “ff18”이고, “ff18”은 여전히 같은 주소입니다.
확인해보니 78이라는 값은 남아있습니다.

78
00:06:26,300 --> 00:06:31,790
그렇기 때문에 스택을 사용해 스택에서 주소를 반환하면, 손실 문제가 발생할 위험이 있습니다.

79
00:06:31,800 --> 00:06:35,710
또 다른 함수를 호출하면 바로 이 주소가 다시 사용되기 때문입니다.

80
00:06:36,350 --> 00:06:38,350
이 문제를 피하고자, “힙”이 존재합니다.

81
00:06:38,720 --> 00:06:45,160
어떻게 “힙”에서 메모리를 얻을 수 있을까요? 우리는 “malloc”이라는 함수를 사용할 겁니다.

82
00:06:45,500 --> 00:06:49,030
(그리고 후에 “free”라는 함수를 보여드리겠습니다.)

83
00:06:49,550 --> 00:06:53,020
자, "malloc”이 어떻게 동작하는지 바로 봅시다.

84
00:06:53,020 --> 00:07:00,900
“malloc”의 “man”을 봐봅시다. 좋아요.

85
00:07:01,000 --> 00:07:08,229
자, “malloc”은 어떻게 동작할까요? “size_t size”라는 매개변수가 필요합니다.
“size_t”는 typedef입니다, 한 번 봅시다.

86
00:07:08,960 --> 00:07:12,759
그리고 “size”는.. 바이트 단위입니다.

87
00:07:12,980 --> 00:07:18,249
예, “malloc”은 우리에게 메모리를 “내줄 것”입니다.
“int”, “float”, “char” 또는 “char” 세트(문자열),

88
00:07:18,250 --> 00:07:21,460
“int” 세트, “float”세트; 1개든 1000개가 되던.. 

89
00:07:22,280 --> 00:07:26,170
크기는 바이트 단위로 표시되고, 방금 본 것처럼 무엇이든 담을 수 있는 메모리 공간을 줄 수 있습니다.

90
00:07:26,690 --> 00:07:31,390
다시 한번 말해줄게요:

91
00:07:31,760 --> 00:07:35,619
메모리는 실제  “0”과 “1” 입니다. 어떻게 읽힐지 결정하는 건 프로그램이 하므로 “void *”입니다. 

92
00:07:36,200 --> 00:07:45,000
malloc은 쓰기 권한이 있는 메모리의 시작 주소를 반환하기 때문에 “*”를 반환합니다

93
00:07:45,100 --> 00:07:50,919
따라서 16바이트를 요구하고 그 16바이트는 원하는 대로 사용할 수 있습니다.
“int”형 4개가 될 수 있고요. “char”형 16개가 될 수도 있고요.

94
00:07:51,050 --> 00:07:54,820
무엇을 원하든 할 수 있습니다. 구조체가 될 수도 있습니다. 저는 몰라요. 여러분이 원하는 대로요.

95
00:07:55,460 --> 00:07:58,600
하지만 구조체는 다음 비디오에서 볼 수 있습니다.

96
00:07:58,699 --> 00:08:00,410
자 여기 “void *”가 있습니다,

97
00:08:00,410 --> 00:08:04,929
뭐든지 될 수 있습니다. 끝내주죠. “malloc”은 우리를 위해 메모리를 할당해주고

98
00:08:04,930 --> 00:08:06,800
우리 마음대로 쓸 수 있으니까요.

99
00:08:06,800 --> 00:08:08,780
가봅시다. “malloc”을 사용할 겁니다.

100
00:08:08,780 --> 00:08:11,049
지금 프로그래밍을 할 때

101
00:08:11,900 --> 00:08:16,630
먼저 malloc을 사용하기 위해서는 파일 상단에 이 것(stdlib.h)을 포함시켜야합니다.
문제없어요, 그렇게 하죠.

102
00:08:17,150 --> 00:08:20,799
(비디오에서 .h 파일과 프로세서가 있는 것을 볼 수 있습니다.)

103
00:08:21,710 --> 00:08:25,900
자, 지금 malloc을 호출할 수 있어야 하는데

104
00:08:26,300 --> 00:08:30,970
“int *tab”을 할 것이고 tab은 malloc과 동일합니다.

105
00:08:31,789 --> 00:08:37,269
int형 1개를 할당하려고 합니다: 4를 써줍니다. 

106
00:08:37,940 --> 00:08:47,439
문제는 운영체제를 변경하면 코드는 더이상 유효하지 않기 때문에 sizeof(int)로 씁시다.

107
00:08:48,500 --> 00:08:55,570
그것은 유효하지만, 만약 내일 “int *tab” 대신 “long int *tab”으로 변경을 원할 거라고 생각해봅시다

108
00:08:56,570 --> 00:09:01,209
그러면 “tab”으로 malloc을 한 곳을 long int로 바꿔야 합니다.

109
00:09:01,459 --> 00:09:03,519
이를 위한 더 현명한 방법이 있습니다:

110
00:09:04,250 --> 00:09:08,619
실제로 “sizeof”에 형으로 전달할 필요는 없으며 변수를 사용할 수도 있습니다
(이후에 해당 변수의 유형을 확인해봅니다)

111
00:09:08,620 --> 00:09:13,929
그래서, *tab을 붙이면, 왼쪽(tab)에 있는 변수의 유형이 됩니다.

112
00:09:14,270 --> 00:09:18,500
이 타입의 요소 하나만큼의 공간을 할당한 것으로 알고 있습니다.

113
00:09:20,620 --> 00:09:24,609
둘 이상을 할당하려면 이렇게 할 수 있고,

114
00:09:25,580 --> 00:09:28,479
int형 1 * int형 9크기가 할당될 것입니다.

115
00:09:29,240 --> 00:09:34,750
자, * int(주소)로 반환되므로 이제 tab을 사용할 수 있습니다.

116
00:09:35,000 --> 00:09:37,000
여기에 tab을 넣겠습니다

117
00:09:37,880 --> 00:09:39,050
좋아요!

118
00:09:39,050 --> 00:09:42,700
9는 사실 그렇게 중요하지 않기 때문에 냅둬도 됩니다.

119
00:09:43,070 --> 00:09:48,520
모든 걸 컴파일했고 반드시 동작해야 합니다. 이제 12와 12가 출력되는 걸 볼 수 있습니다!!

120
00:09:49,040 --> 00:09:51,940
힙에서 메모리를 찾았지만,

121
00:09:52,649 --> 00:09:55,099
그러고 나서 값과 주소를 얻었습니다; 그다음엔 이 주소를 반환했습니다,

122
00:09:55,250 --> 00:09:58,369
스택은 이 과정 중에 변경되었을 수도 있지만, 힙은 변경되지 않았기 때문에 문제가 되지 않습니다!

123
00:09:58,500 --> 00:10:04,279
이 메모리 공간은 제 것이므로 그 누구도 사용할 권리가 없습니다

124
00:10:05,220 --> 00:10:08,540
또한 제가 요청해서 할당받은 메모리는

125
00:10:08,790 --> 00:10:13,639
“되돌려줘야”합니다. 스택의 장점은 메모리를 가져가면 자동으로 반환된다는 것입니다.

126
00:10:13,639 --> 00:10:15,639
하지만 이제는 그렇게 해야 합니다.

127
00:10:15,899 --> 00:10:18,409
“free”라고 불리는 malloc과 함께 다니는 함수가 있습니다

128
00:10:19,079 --> 00:10:25,279
“free”는 malloc이 반환한 주소인 “void *ptr”를 매개변수로 받습니다.

129
00:10:25,279 --> 00:10:30,768
그래서 free를 하면 malloc에게 말합니다:

130
00:10:31,290 --> 00:10:33,349
“전에 제게 준 이 공간 다시 가져가서 맘대로 해요, 저는 더이상 필요 없어요”

131
00:10:33,870 --> 00:10:38,839
이것이 어떻게 메모리를 free 하는지에 대한 이야기입니다.
다시 한번 말하면, 가능한 한 빨리 메모리를 해제하는 것은 정말 중요합니다.

132
00:10:39,029 --> 00:10:44,809
정말 더 이상 필요하지 않다면, 즉시 free 하세요.
왜일까요? 비디오 게임을 상상해봅시다.

133
00:10:45,060 --> 00:10:49,849
상대방을 죽일 때마다 이 상대편의 모든 정보를 기억한다고 쳐봅시다...

134
00:10:50,339 --> 00:10:54,349
음, 여러분은 레벨 1, 레벨 2, 레벨 3, 레벨 4 등을 통과하면서

135
00:10:54,350 --> 00:10:58,159
죽인 적들의 정보는 다시 쓸 필요가 없지만, 저장을 합니다

136
00:10:58,529 --> 00:11:03,109
잠시 후 프로그램이 중단될 정도로 많은 메모리를 소모하게 됩니다!

137
00:11:03,540 --> 00:11:07,279
컴퓨터는 말합니다: “멈춰! 충분해, 난 네게 메모리를 더 이상 줄 수 없어”

138
00:11:07,740 --> 00:11:11,630
그래서, 메모리를 사용하지 않을 때, free 하는 것은 매우 중요합니다.

139
00:11:12,269 --> 00:11:16,879
메모리를 좀 더 유연하게 활용할 수 있을 겁니다.

140
00:11:17,120 --> 00:11:22,880
아직 쓴다면 free 하지 마세요. 하지만 가능한 한 free 하는 것을 망설이지 마세요
메모리를 반환하는 것은 중요합니다

141
00:11:23,040 --> 00:11:26,659
메모리 공간을 free 하면 더 이상 사용할 권한이 없으므로, 주의하세요!

142
00:11:27,480 --> 00:11:32,420
free는 주소를 매개변수로 사용합니다. 그것은 실제로 복사본이고, 마지막으로 한 번만 말하겠습니다,

143
00:11:32,730 --> 00:11:35,930
만약 프로그램의 끝에서 “free(ptr)”을 했다면,

144
00:11:37,730 --> 00:11:43,389
ptr에는 현재 힙에 있는 주소가 있으므로

145
00:11:44,329 --> 00:11:50,019
여기에서는 변경되지 않습니다!! 보여줄게요, 그게 더 쉬울 거에요.

146
00:11:51,649 --> 00:11:56,619
짠! 전후를 보여줄게요.

147
00:11:59,720 --> 00:12:02,980
ptr을 포함한 주소는 변하지 않았습니다!!

148
00:12:03,560 --> 00:12:09,729
사실, free하기 전후는 같습니다. 정상입니다!
free는 값의 복사본을 가져가기 때문에, 그 값은 단지 주소일 뿐입니다.

149
00:12:09,730 --> 00:12:15,279
free는 말합니다: “야! 이 주소를 free 해!”. 그러니 더 이상 네 소유가 아닌 집으로 돌아가면

150
00:12:15,500 --> 00:12:18,309
문제가 생길 겁니다, 너는 집을 free 했습니다!

151
00:12:18,470 --> 00:12:23,949
만약 주인인 malloc에게 집을 되돌려달라고 부탁하지 않은 한, 가지 마세요, 아마도 같은 집을 줄 것입니다

152
00:12:23,949 --> 00:12:29,979
하지만 통제할 수 없습니다. 주소가 있는 포인터를 free 시킬 때 조심하세요

153
00:12:30,320 --> 00:12:33,339
더 이상 접근하거나 사용할 수 없습니다!

154
00:12:34,220 --> 00:12:37,959
free 할 때 NULL을 가리키는 것이 좋을 수도 있습니다, 문제가 생기지 않을 겁니다
하지만 그럴 필요는 없을 수도 있습니다…

155
00:12:38,870 --> 00:12:40,870
그건 여러분에게 달렸습니다...

156
00:12:40,970 --> 00:12:43,839
좋아요! 우리는 힙에 관해 꽤 긴 비디오를 보았습니다

157
00:12:43,910 --> 00:12:47,709
그래서 스택이 실제 어떻게 동작하는지와 힙에 대해 보고

158
00:12:47,870 --> 00:12:52,779
메모리를 할당할 수 있는 malloc을 사용하고 free 시키는 방법을 보았습니다
<< translated by mki, mseo, ji-kim, inyang and yeslee :) >>
