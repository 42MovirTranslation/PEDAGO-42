1
00:00:00,190 --> 00:00:03,470
이 비디오에서는 비교 연산자에 대해 알아봅시다.

2
00:00:03,470 --> 00:00:08,049
비교 연산자에는 세 가지 유형이 있습니다. (1) 단일 변수에 대해 작동하는 단항 연산자,

3
00:00:08,119 --> 00:00:15,069
(2) 두 변수를 비교하는 비교 연산자, (3) 논리 연산자가 있습니다.

4
00:00:15,169 --> 00:00:19,899
그리고 이 연산자는 작동하지 않을 수도 있습니다. 이 경우는 나중에 볼 거예요.

5
00:00:20,450 --> 00:00:24,009
언제나처럼 예시로 시작해보죠.

6
00:00:24,470 --> 00:00:29,200
변수 a와 b를 선언했습니다. a는 43이고, b는 32입니다.

7
00:00:29,260 --> 00:00:34,989
변수들을 표시해봅시다. a와 b를 넣는 걸 까먹었군요.

8
00:00:35,809 --> 00:00:37,809
봅시다.

9
00:00:37,999 --> 00:00:44,199
따란, a와 b가 표시되었습니다. 완벽해요.

10
00:00:45,109 --> 00:00:47,349
이제 비교 연산자를 시작하겠습니다.

11
00:00:47,569 --> 00:00:49,069
비교 연산자들은 두 변수,

12
00:00:49,069 --> 00:00:54,999
또는 두 개의 계산을 비교할 수 있게 해줍니다.

13
00:00:55,249 --> 00:00:58,959
결국 두 개의 값을 비교할 수 있습니다. 첫 번째로 볼 것은 == 입니다.

14
00:01:00,079 --> 00:01:05,469
= 와는 다릅니다. =는 할당 연산자이므로

15
00:01:06,080 --> 00:01:10,270
오른쪽의 값을 가져와 왼쪽의 변수에 대입합니다.

16
00:01:10,520 --> 00:01:12,849
‘==’은 두 개의 변수가 있어야 합니다.

17
00:01:13,160 --> 00:01:15,399
그리고 두 값이 같은 값인지 확인할 것입니다.

18
00:01:16,970 --> 00:01:24,669
43과 32가 같습니까? 절대 아니죠! 그래서 이 연산은 0을 반환합니다.

19
00:01:25,070 --> 00:01:27,070
만약 두 변수에 같은 값을 입력하면

20
00:01:30,590 --> 00:01:32,420
(보통 42…)

21
00:01:32,420 --> 00:01:34,040
짜잔!

22
00:01:34,040 --> 00:01:38,169
1을 반환합니다.

23
00:01:38,540 --> 00:01:41,379
(TMI : 1이 반환 되는 것은 C의 표준이 아닙니다)

24
00:01:42,350 --> 00:01:46,330
0이 아닌 모든 값이 될 수 있습니다.

25
00:01:46,670 --> 00:01:53,949
그래서, 0은 0이고, 만약 0이 아닌 값이라면

26
00:01:54,380 --> 00:01:59,740
‘==’은 참으로 인식하고 0이 아닌 값을 반환합니다.

27
00:02:00,470 --> 00:02:06,370
지금까지 두 변수, 또는 두 계산이 동일한 지 알 수 있는 ‘==’ 를 보았습니다.

28
00:02:07,250 --> 00:02:08,919
이제 ‘==’와 반대 되는 비교 연산자를 보겠습니다. 

29
00:02:08,919 --> 00:02:11,489
‘!=’ 를 쓰면 됩니다. (느낌표와 등호)

30
00:02:11,800 --> 00:02:18,990
‘!=’은 두 변수가 다른지 알려줍니다. 43과 43이 다른가요? 아니죠.

31
00:02:19,300 --> 00:02:21,300
그래서 반환 값은 0입니다.

32
00:02:22,330 --> 00:02:24,310
좋아요, 이것도 봅시다.

33
00:02:24,310 --> 00:02:26,310
‘>’ 를 예로 봅시다.

34
00:02:28,990 --> 00:02:36,150
a가 b보다 큰가요? 그러니까 43이 43보다 큰가요? 절대 아니죠.

35
00:02:38,350 --> 00:02:42,359
이제 ‘>=’를 써봅시다. 이 연산자 또한 ~보다 큰 것을 나타냅니다.

36
00:02:43,060 --> 00:02:45,060
그리고 같은 것도 나타내죠.

37
00:02:45,610 --> 00:02:50,160
43이 43보다 크거나 같습니까? 맞아요. 그렇죠. 다음은 ‘~보다 작음’을 볼게요.

38
00:02:52,780 --> 00:02:55,530
따란, ‘보다 작음'을 썼습니다.

39
00:02:56,140 --> 00:03:01,050
43이 43보다 작나요? 저얼대 아니죠. 그래서 0이 반환됩니다.

40
00:03:02,920 --> 00:03:04,920
이제 ‘작거나 같음'을

41
00:03:06,400 --> 00:03:08,400
써 봅시다. 얍.

42
00:03:09,280 --> 00:03:10,450
짜잔!

43
00:03:10,450 --> 00:03:14,159
43은 43보다 작거나 같죠? 적어도 43과 같으므로

44
00:03:14,350 --> 00:03:17,610
1을 반환합니다 (0이 아닌 값을 반환함)

45
00:03:18,130 --> 00:03:21,570
지금까지 첫 번째 유형의 비교 연산자를 살펴보았습니다.

46
00:03:22,300 --> 00:03:27,600
이제 ‘부정 연산자'를 살펴보겠습니다.

47
00:03:28,210 --> 00:03:32,879
단항 연산자라서 하나의 변수에 사용할 수 있습니다.

48
00:03:34,240 --> 00:03:36,240
예시를 볼까요?

49
00:03:37,900 --> 00:03:39,900
여기에 부정 연산자를 넣어볼게요.

50
00:03:41,830 --> 00:03:43,780
그리고...

51
00:03:43,780 --> 00:03:50,190
!43은 0입니다. 43은 0과 다르기 때문이죠.

52
00:03:50,830 --> 00:03:58,170
만약 사용하려는 변수가 0이면, 0이 아닌 값을 반환합니다. (이 경우에서는 1이죠)

53
00:03:58,600 --> 00:04:04,170
항상 1의 값을 가지지는 않기에, 그저 0이 아닌 값을 반환한다고 이해해야합니다.

54
00:04:05,290 --> 00:04:08,969
부정 연산자였습니다. 자, 아직 볼 부분들이 남아 있습니다.

55
00:04:09,550 --> 00:04:12,689
우리는 방금 본 것들을 조합 할 수도 있습니다.

56
00:04:13,930 --> 00:04:18,298
재미있는 조합을 시도해볼까요. 전 아까 미리 했죠.

57
00:04:18,298 --> 00:04:20,069
부정연산자를

58
00:04:20,070 --> 00:04:22,070
괄호와 함께 쓰면서요.

59
00:04:24,840 --> 00:04:28,340
이걸 어떻게 읽어야 할까요?

60
00:04:28,920 --> 00:04:34,039
먼저 괄호 안에 있는 작업을 수행해야합니다. a가 b보다 작거나 같습니까?

61
00:04:34,040 --> 00:04:36,040
그리고 그 결과를 부정(!) 으로 표시합니다.

62
00:04:36,960 --> 00:04:43,220
그래서, 43이 43보다 작거나 같습니까? 당연하죠! 따라서 0이 아닌 값을 반환합니다.

63
00:04:43,620 --> 00:04:47,149
여기서 부정 연산자는 0이 아닌 값을 0으로 반환합니다.

64
00:04:47,940 --> 00:04:53,179
원하는 경우, 앞에 또 부정연산자를 붙일 수 있을 것 같아요. 컴파일러가 이 작업을 좋아할지 모르겠네요.

65
00:04:57,810 --> 00:04:59,810
여기도 넣겠습니다. 야호!

66
00:05:01,410 --> 00:05:04,969
동작할까요? 네, 동작합니다!

67
00:05:05,520 --> 00:05:11,660
그래서, 43이 43보다 작거나 같습니까? 네. 그래서 0이 아닌 값을 반환합니다. 그런 다음 0이 아닌 값의 부정은 0이고, 다시 0의 부정은 1입니다.

68
00:05:12,180 --> 00:05:15,230
따라서 연산자를 결합하여 더 복잡한 논리를 구현할 수 있습니다.

69
00:05:16,140 --> 00:05:19,429
이제 몇 가지 비교를 수행하는 다른 연산자가 있습니다.

70
00:05:19,530 --> 00:05:22,160
그들은 0이거나 0이 아닌 값들을 

71
00:05:22,680 --> 00:05:26,840
비교하는 방식이 약간 다릅니다.

72
00:05:27,750 --> 00:05:29,750
연산자 and/and (&&) 와 or/or (||) 입니다

73
00:05:30,419 --> 00:05:32,419
먼저 and/and (&&)를 보겠습니다.

74
00:05:35,190 --> 00:05:36,750
그래서, &&는

75
00:05:36,750 --> 00:05:38,750
어떻게 작동할까요?

76
00:05:38,850 --> 00:05:40,850
이항연산자 and (&)와 비슷합니다.

77
00:05:41,669 --> 00:05:44,839
생각해봅시다.

78
00:05:45,300 --> 00:05:51,560
and에서 0은 0이고, 0이 아닌 값은 1을 반환합니다.

79
00:05:51,780 --> 00:05:56,450
이제 같은지 봅니다. 만약 43 && 43이라고 쓰면

80
00:05:56,880 --> 00:05:59,869
0이 아닌 값을 반환합니다. 왜일까요?

81
00:05:59,960 --> 00:06:04,130
그 이유는 왼쪽에 0이 아닌 값이 있고, 오른쪽에도 있기 때문입니다. 그래서 연산자 &&는 0이 아닌 값을 반환합니다.

82
00:06:04,500 --> 00:06:09,980
두 값이 모두 0이 아니면 0을 반환합니다.

83
00:06:10,200 --> 00:06:12,259
만약 b = 0 을 넣으면

84
00:06:14,610 --> 00:06:17,240
43 과 0, 둘 중 하나가 0이므로 0을 반환합니다.

85
00:06:18,750 --> 00:06:25,130
이제 or/or (||)이 있습니다. 이 연산자는 이항연산자 |와 같습니다.

86
00:06:26,040 --> 00:06:28,609
0과 0이 아닌 값이 있으면

87
00:06:29,400 --> 00:06:31,970
0이 아닌 값을 반환합니다. 그리고

88
00:06:34,290 --> 00:06:37,999
둘 다 0일 경우, 0을 반환합니다.

89
00:06:39,510 --> 00:06:44,869
이제 모든 연산자를 다 보았습니다. 마지막으로 이해해야 할 것이 남아있습니다.

90
00:06:45,360 --> 00:06:49,699
작업은 왼쪽에서 오른쪽으로 진행되며, 

91
00:06:50,040 --> 00:06:52,040
&&와 ||을 사용할 때 실행되지 않는 작업이 있습니다.

92
00:06:52,560 --> 00:06:55,339
예를 들어 설명해보겠습니다.

93
00:06:56,190 --> 00:07:00,619
왼쪽의 모든 항목을 제거하겠습니다.

94
00:07:02,370 --> 00:07:07,459
그리고 a == b

95
00:07:08,970 --> 00:07:12,109
&& a, (a !=b)를 쓰는 걸 생각해보세요.

96
00:07:15,540 --> 00:07:16,500
자, 그래서.

97
00:07:16,500 --> 00:07:21,259
a and b의 값이 무엇이든

98
00:07:21,260 --> 00:07:26,070
반환 값은 0이 될겁니다. 항상요.

99
00:07:26,070 --> 00:07:28,070
왜냐하면 그들 중 하나가 거짓 (0)일 것이기 때문입니다.

100
00:07:28,070 --> 00:07:31,790
a가 b와 같습니까? a가 b와 같지 않습니까? 그 중 하나는 무조건 거짓(0)입니다.

101
00:07:31,790 --> 00:07:35,839
그래서 &&는 항상 거짓이고, 항상 0을 반환합니다.

102
00:07:36,180 --> 00:07:41,000
중요한 건, 가능하다면 첫 번째 계산만 수행한 다음

103
00:07:41,300 --> 00:07:45,560
이것이 0이 아니면 두 번째 작업을 수행합니다.

104
00:07:45,810 --> 00:07:50,810
여기, a == b 가 있습니다 . 2와 4가 같습니까?

105
00:07:51,300 --> 00:07:55,490
저얼대 아니죠. 그래서 이건 0이기 때문에

106
00:07:55,950 --> 00:07:58,550
나머지는 작업 하지 않습니다.

107
00:07:58,680 --> 00:08:02,120
이것은 중요합니다. 나중에 굉장히 유용할 것입니다.

108
00:08:02,580 --> 00:08:08,540
&&가 끝나면, 왼쪽에 0이 있다는

109
00:08:09,600 --> 00:08:13,549
단순한 사실만으로도 최종 값을 충분히 알 수 있습니다.

110
00:08:13,760 --> 00:08:15,510
오른쪽 값이 무엇이든 결국에는 0이 반환됩니다.

111
00:08:15,510 --> 00:08:18,980
그래서 오른쪽 부분을 계산하지 않을 것입니다.

112
00:08:20,190 --> 00:08:25,190
이걸 이용해서 최적화 할 수 있습니다.

113
00:08:25,650 --> 00:08:30,919
여기에 a와 b가 같다면, 왼쪽을 계산합니다. 지금은 0이 아니에요. (2 == 2 -> 1)

114
00:08:30,920 --> 00:08:36,379
이제 왼쪽 부분이 유효하다는 것을 알고 오른쪽을 테스트합니다. ||도 마찬가지입니다.

115
00:08:37,380 --> 00:08:43,189
여기에 ||를 입력하고 이제 a == b.

116
00:08:43,729 --> 00:08:46,429
이것은 참이므로 0이 아닌 값을 반환합니다.

117
00:08:46,709 --> 00:08:50,539
따라서 ||은 오른쪽을 계산할 필요가 없습니다.

118
00:08:50,779 --> 00:08:52,779
더 이상 상관없어요, 쓸모없다구

119
00:08:53,100 --> 00:08:54,420
The "or / or"
연산자 || 는

120
00:08:54,420 --> 00:08:59,510
왼쪽에 0이 아닌 값이 있다는 것을 알기 때문에, 오른쪽을

121
00:08:59,510 --> 00:09:00,360
계산할 필요가 없습니다.

122
00:09:01,649 --> 00:09:03,420
이걸 이해하는 것은 매우 중요합니다.

123
00:09:03,420 --> 00:09:08,360
이를 통해 코드를 최적화 할 수 있습니다. 특히 나중에 일부 계산을 피할 수 있습니다.

124
00:09:08,970 --> 00:09:12,800
실제로 중요한 부분입니다. && 아니면 ||를 사용하면 특정 계산을 피할 수 있습니다.

125
00:09:13,440 --> 00:09:15,799
You cannot force the compiler to do these calculations.

126
00:09:16,050 --> 00:09:20,269
유일한 방법은 이전에 계산을 수행한 다음, 그 결과를 사용하는 것입니다.

127
00:09:20,550 --> 00:09:28,250
예를 들어, 좋은 생각은 아니지만 이렇게 해볼 수 있습니다..

128
00:09:34,620 --> 00:09:36,649
짠, 여기서 마지막으로 확인하게 합니다.

129
00:09:38,820 --> 00:09:41,570
이와 같이 컴파일러를 강제로 이 계산에

130
00:09:42,180 --> 00:09:44,180
한 번 이상 실행하게 하면...

131
00:09:44,250 --> 00:09:45,269
짜잔

132
00:09:45,269 --> 00:09:48,409
이건 별로 좋은 아이디어는 아니네요. 조금 위험합니다.

133
00:09:48,839 --> 00:09:51,349
권장하지 않지만 정말 필요하다면...

134
00:09:51,529 --> 00:09:55,369
여기서는 a와 b가 변수이기 때문에 큰 문제는 아니지만

135
00:09:55,459 --> 00:10:00,379
특정 상황에서는 변수가 아닌 함수가 들어갈 수 있고,

136
00:10:00,480 --> 00:10:05,510
함수는 다른 함수를 호출 할 수 있기 때문에 더 복잡해질거예요.

137
00:10:05,510 --> 00:10:07,510
그래서 알고 있으세요.

138
00:10:07,800 --> 00:10:12,709
순서가 있고, 표현식을 실행할지 여부를 알고 있는 것은,

139
00:10:12,930 --> 00:10:16,489
이면에서 일어나는 일을 최적화하고 아는데 매우 중요합니다.

140
00:10:17,279 --> 00:10:21,919
우리는 모든 비교 연산자를 보았으므로, 이제 모든 것을 알고 있는겁니다!

translated by inyang, chelee, mki, yeslee, mseo and ji-kim :)

