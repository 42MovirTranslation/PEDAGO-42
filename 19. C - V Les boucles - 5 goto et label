https://youtu.be/mSs4wrlXGLY?list=PLVQYiy6xNUxz5wbzZn4tfUhF4djgzscB-
 
1
00:00:00,000 --> 00:00:01,860
이번 비디오에서는
 
2
00:00:01,860 --> 00:00:05,000
레이블과 ‘goto’ 키워드의 사용법을 알려드리겠습니다.
 
3
00:00:05,000 --> 00:00: 07,740
‘goto’라는 키워드는 최초의 프로그래밍 언어에서부터
 
4
00:00:07,740 --> 00:00:09,269
왔다는 사실을 설명해드리면서
 
6
00:00:09,269 --> 00:00:10,650
시작하도록 하겠습니다.
 
7
00:00:10,650 --> 00:00:13,139
이 키워드는 코드 내에서라면
 
8
00:00:13,139 --> 00:00:14,880
어디로든 “go” 할 수 있는 키워드입니다.
 
9
00:00:14,880 --> 00:00: 17,369
제어 구조를 가진 함수, 혹은 다른 것들이 없던 때에,
 
10
00:00:17,369 --> 00:00:21,300
그래서 컴파일이 무식하게 되던 때에,
 
11
00:00:21,300 --> 00:00:24,390
컴파일러는 똑똑하지 않았기 때문에 명령을 받았습니다 :
 
12
00:00:24,390 --> 00:00:26,400
“이 부분으로 가서, 뭔가 있으면 뭔가를 해,
 
13
00:00:26,400 --> 00:00:28,439
그리고 프로그램의 이 줄로 가.”
 
14
00:00:28,439 --> 00:00:31,170
지금은 함수들이 있습니다. 여러분은 나중에 보게 되시겠지만,
 
15
00:00:31,170 --> 00:00:36,350
프로그램을 컨트롤할 수 있는 것들이 많습니다. ‘while’ 반복문 같은 거요.
 
16
00:00:36,350 --> 00:00:38,940
‘goto’는 ‘while’ 반복문의 조상입니다.
 
17
00:00:38,940 --> 00:00:43,680
그리고 거의 쓰이지 않았습니다. 굉장히 위험한 도구이기 때문입니다.
 
18
00:00:43,680 --> 00:00:47,940
대부분의 경우, ‘goto’를 사용하고 싶다면 당신이 무엇을 하고자 하는지 분명히 알아야만 합니다.
 
19
00:00:47,940 --> 00:00:50,879
그렇지 않다면, 사용하지 마세요.
 
20
00:00:50,879 --> 00:00:52,320
하지만 여기서는 여러분에게 ‘goto’를 보여줄 거예요.
 
21
00:00:52,320 --> 00:00:53,489
C에서 가능한 모든 것들을 보여주고 싶으니까요.
 
22
00:00:53,489 --> 00:00:57,090
시작해볼까요.
 
23
00:00:57,090 --> 00:00:58,559
다시 ‘while’ 반복문을 예시로 가져왔습니다.
 
24
00:00:58,559 --> 00:01:00,690
정수 i가 있고,
 
25
00:01:00,690 --> 00:01:03,420
I = 0;
while (i < 10)
 
26
00:01:03,420 --> 00:01:08,430
printf(“%d\n”, i);
i++; 다른 점은 없습니다.
 
27
00:01:08,430 --> 00:01:11,970
좋아요. 이건 무슨 결과를 내놓을까요?
 
28
00:01:11,970 --> 00:01:12,920
이렇습니다.
 
29
00:01:12,920 --> 00:01:18,390
좋아요. 이제 ‘goto’와 레이블을 쓰는 법을 알아봅시다.
 
30
00:01:18,390 --> 00:01:19,860
먼저 레이블을 선언해야합니다.
 
31
00:01:19,860 --> 00:01:21,060
레이블 선언은 어떻게 할까요?
 
32
00:01:21,060 --> 00:01:22,290
식별자를 기입해야합니다.
 
33
00:01:22,290 --> 00:01:23,280
뭐든 상관없어요.
 
34
00:01:23,280 --> 00:01:26,700
예를 들어, 여기서는
 
35
00:01:26,700 --> 00:01:27,110
bla: 라고 써보겠습니다.
 
36
00:01:27,110 --> 00:01:30,030
이렇게 방금 레이블을 정의했습니다.
 
37
00:01:30,030 --> 00:01:31,290
이 ‘bla:’는 일종의 기준점입니다.
 
38
00:01:31,290 --> 00:01:36,299
레이블을 쓸 수 있도록 ‘goto’ 키워드를 사용할 겁니다.
 
39
00:01:36,299 --> 00:01:38,430
goto라고 붙여서 쓰고 식별자를 적습니다.
 
40
00:01:38,430 --> 00:01:44,960
이렇게 하고, 어떻게 되는지 봅시다.
 
41
00:01:46,260 --> 00:01:49,140
0이 계속 나와요, 왜일까요?
 
42
00:01:49,140 --> 00:01:51,930
i를 먼저 선언했고, bla 레이블을 선언했죠.
 
43
00:01:51,930 --> 00:01:57,450
i = 0 이에요. 그리고 i가 10보다 작은 동안은,
 
44
00:01:57,450 --> 00:01:59,580
현재 i의 값인 0을 출력할 거고,
 
45
00:01:59,580 --> 00:02:01,080
다시 bla:로 돌아갈 겁니다. 여기로 돌아왔어요.
 
46
00:02:01,080 --> 00:02:03,600
 ‘while’ 반복문을 벗어나면서,
 
47
00:02:03,600 --> 00:02:05,640
이하의 것들을 다 무시하고
 
48
00:02:05,640 --> 00:02:07,520
여기(bla:)로 돌아온 거예요.
 
49
00:02:07,520 --> 00:02:13,650
이 시점에서 설정된 변수들의 값과 함께요.
 
50
00:02:13,650 --> 00:02:16,080
이 시점의 값과 다른 변수들이 꽤 난장판이군요…
 
51
00:02:16,080 --> 00:02:21,360
bla:로 돌아왔을 때, i의 값은 ‘goto bla:’ 까지의 값에서 변화가 없는 거죠.
 
52
00:02:21,360 --> 00:02:23,820
재밌는 걸 해보려구요.
 
53
00:02:23,820 --> 00:02:25,310
여기서도 i의 값을 출력해볼게요.
 
54
00:02:25,310 --> 00:02:27,120
왜 goto가 위험한지 알게 되실 겁니다.
 
55
00:02:27,120 --> 00:02:32,640
코드를 읽기가 극도로 복잡해졌네요.
 
56
00:02:32,640 --> 00:02:37,790
제가 이렇게 한다면, 이렇게 출력하겠죠…
 
57
00:02:37,790 --> 00:02:44,280
아! 친절하네요. i = 0이라고 써줬어야 해요.
 
58
00:02:44,280 --> 00:02:46,770
사용하기 전에는 분명히 초기화를 해줘야죠.
 
59
00:02:46,770 --> 00:02:48,030
테스트로 돌아가봅시다.
 
60
00:02:48,030 --> 00:02:50,610
0 1 0 1…….이 출력됐네요.
 
61
00:02:50,610 --> 00:02:56,760
왜 0, 1일까요? 처음 시작값이 뭐든 상관없지만, 여기서 i는 처음에 0의 값을 가지죠.
 
62
00:02:56,760 --> 00:03:02,880
i의 값을 출력하니 0이 나오고, i는 다시 0이 되네요. 0은 확실히 10보다 작죠.
 
63
00:03:02,880 --> 00:03:06,900
i의 값을 출력하면 다시 0, i++을 하고, ‘goto bla’로 들어가죠.
 
64
00:03:06,900 --> 00:03:08,250
여기서 ‘while’ 반복문을 탈출해
 
65
00:03:08,250 --> 00:03:11,600
여기(bla:)로 돌아갑니다. 이제 i의 값은 1이죠.
 
66
00:03:11,600 --> 00:03:14,280
그래서 코드를 위에서 아래로 읽는다면,
 
67
00:03:14,280 --> 00:03:19,860
일반적으로 이 시점에서 i의 값은 0이지만, 문제는 우리가 ‘goto’를 사용했을 때부터입니다..
 
68
00:03:19,860 --> 00:03:21,750
제가 goto 위에 코드 400줄을 더하고,
 
69
00:03:21,750 --> 00:03:26,130
많은 동작을 하게끔 만들어서, i를 400번 수정한 후, 여기로 돌아오면
 
70
00:03:26,130 --> 00:03:28,110
i가 새로운 값을 가지게 됩니다.
 
71
00:03:28,110 --> 00:03:32,000
이러면 코드 읽기가 끔찍하게 어려워지겠죠! 위험합니다!
 
72
00:03:32,000 --> 00:03:34,230
‘goto’는 매우 특정한 상황에서 유용합니다.
 
73
00:03:34,230 --> 00:03:43,410
그 중 하나는 우리가 한 번에 여러 개의 ‘while’ 반복문을 나갈 때입니다.
 
74
00:03:43,410 --> 00:03:45,000
‘while’ 반복문들이 뒤엉켰을 때,
 
75
00:03:45,000 --> 00:03:48,480
마지막에 ‘break’ 키워드를 넣으면 반복문을 탈출할 수 있었습니다.
 
76
00:03:48,480 --> 00:03:52,230
‘goto’를 이용한다면, 첫 번째 반복문의 시작 부분에서 반복문을 탈출하거나 돌아올 수 있습니다.
 
77
00:03:52,230 --> 00:03:53,290
하나 이상의 반복문에서,
 
78
00:03:53,290 --> 00:03:54,459
첫 번째 반복문의 첫머리로 돌아갈 수 있습니다.
 
79
00:03:54,459 --> 00:03:57,099
일종의 슈퍼 ’continue’를 쓴 것 처럼요.
 
80
00:03:57,099 --> 00:04:00,609
20개의 if가 없이도 같은 기능을 하는 단 하나의 ‘continue’를요.
 
81
00:04:00,609 --> 00:04:02,349
이건 ‘goto’ 키워드 사용법의 한 예시였습니다.
 
82
00:04:02,349 --> 00:04:07,030
너무 위험해서 거의 사용되지는 않지만요.
 
83
00:04:07,030 --> 00:04:10,840
저도 회사에서 실제로 사용되는 코드 중에는 거의 보지 못했습니다.
 
84
00:04:10,840 --> 00:04:15,180
아주 강력하지만 몹시 위험한 거니까요.
 
85
00:04:15,180 --> 00:04:21,668
If, break, continue를 올바로 사용하는 게 훨씬 낫습니다.
 
86
00:04:21,668 --> 00:04:23,740
자! 복습해볼까요. 레이블을 쓰는 법입니다:
 
87
00:04:23,740 --> 00:04:28,300
식별자, 쌍점, 뒤에는 아무것도 쓰지 말기.
 
88
00:04:28,300 --> 00:04:31,060
이제 ‘goto’를 쓰는 법이요:
 
89
00:04:31,060 --> 00:04:32,650
goto 레이블 이름.
 
90
00:04:32,650 --> 00:04:33,849
이 줄에 도착하게 되면,
 
91
00:04:33,849 --> 00:04:36,250
프로세서에게는 이렇게 명령하게 됩니다:
 
92
00:04:36,250 --> 00:04:41,020
“저기(bla:)로 돌아가. 거기서부터 다시 시작해.”
 
93
00:04:41,020 --> 00:04:46,020
드디어! ‘goto’와 레이블들의 사용법을 알게 되었군요!
 
 
translated by inyang, chelee, mki, yeslee, mseo and ji-kim:)
